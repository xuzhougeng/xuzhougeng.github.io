<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>洲更的第二大脑</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="洲更的第二大脑">
<meta property="og:url" content="http://xuzhougeng.top/page/18/index.html">
<meta property="og:site_name" content="洲更的第二大脑">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="xuzhougeng">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="洲更的第二大脑" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">洲更的第二大脑</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xuzhougeng.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-服务器上安装RStudio-server-Install-RStudio-server-in-Server" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/14/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%AE%89%E8%A3%85RStudio-server-Install-RStudio-server-in-Server/" class="article-date">
  <time class="dt-published" datetime="2019-10-14T16:00:45.418Z" itemprop="datePublished">2019-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/14/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%AE%89%E8%A3%85RStudio-server-Install-RStudio-server-in-Server/">服务器上安装RStudio-server</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="服务器上安装RStudio-server"><a href="#服务器上安装RStudio-server" class="headerlink" title="服务器上安装RStudio-server"></a>服务器上安装RStudio-server</h1><p>如果想在服务器上安装一个RStudio-server，你需要先保证自己拥有管理员权限，之后参考<a href="/archives/Install-R-in-Linux">如何在服务器上安装最新的R</a>安装R语言，一定要<strong>注意</strong>在<code>./configure</code>的时候加上<code>--enable-R-shlib</code>，否则后续会出错。</p>
<p>RStudio-server分为两种版本，一种是开源免费版，另一个是商业专业版本。个人觉得两者最大的区别在于，商业版支持在多个版本的R语言之间进行切换，而开源免费版不行。</p>
<h2 id="CentOS篇"><a href="#CentOS篇" class="headerlink" title="CentOS篇"></a>CentOS篇</h2><p>如果服务器安装的是CentOS&#x2F;RedHat，那么需要保证它们的发行版本不等于6</p>
<p>从官方上下载rpm文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download2.rstudio.org/server/centos6/x86_64/rstudio-server-rhel-1.2.5001-x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>如果是第一次安装，那么就是运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install rstudio-server-rhel-1.2.5001-x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>假如是需要升级RStudio-server，比如我原先的是<code>1.1.456</code>最新的是<code>1.2.5001</code>, 需要先暂停当前的服务并卸载</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/sbin/rstudio-server stop</span><br><span class="line">yum remove rstudio-server</span><br></pre></td></tr></table></figure>

<p>之后才是安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install rstudio-server-rhel-1.2.5001-x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>安装完成之后，我们可以通过修改<code>/etc/rstudio/rserver.conf</code>更改端口和R所在路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">www-port=8080 <span class="comment"># 端口, 默认8787</span></span><br><span class="line">www-address=0.0.0.0</span><br><span class="line">rsession-which-r=/opt/sysoft/R-3.6.1/bin/R <span class="comment"># 安装R的路径</span></span><br></pre></td></tr></table></figure>

<p>修改完成之后，用<code>rstudio-server restart</code>重启服务，没有任何信息就表示安装成功了。</p>
<p>当然你要是不放心，你还可以用<code>rstudio-server verify-installation</code>来验证下，如果没有任何输出信息就表示安装成功，假如出现下面这条信息，意味着你需要先用<code>rstudio-server stop</code>先暂停服务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server is running and must be stopped before running verify-installation</span><br></pre></td></tr></table></figure>

<p>其实最直接的方法就是直接访问”IP:端口”，能够出现RStudio的登陆界面就意味着安装成功了。</p>
<h2 id="Ubuntu篇"><a href="#Ubuntu篇" class="headerlink" title="Ubuntu篇"></a>Ubuntu篇</h2><p>我没有一台Ubuntu系统的服务器，只有一台Windows 10电脑有一个Linux子系统安装的是 Ubuntu 16.04.6 LTS。</p>
<p>下载Deb文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install gdebi-core</span><br><span class="line">wget https://download2.rstudio.org/server/trusty/amd64/rstudio-server-1.2.5001-amd64.deb</span><br></pre></td></tr></table></figure>

<p>如果不是第一次安装，需要是升级已有的RStudio-server，那么也需要先停用并卸载已有的RStudio-server</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/sbin/rstudio-server stop</span><br><span class="line">sudo apt-get remove rstudio-server </span><br></pre></td></tr></table></figure>

<p>然后安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gdebi rstudio-server-1.2.5001-amd64.deb</span><br></pre></td></tr></table></figure>

<p>如果是在Windows的子系统下安装，会出现如下的警告，允许访问即可。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/1571039719464-278ec32cdcb94ca1ad185f592228e4e1.png" alt="Windows中警告"></p>
<p>如果能够打开<a target="_blank" rel="noopener" href="http://127.0.0.1:8787/">http://127.0.0.1:8787</a>, 就说明安装成功了。</p>
<p>如果想修改RStudio-server的端口和调用R版本，参考CentOS篇</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://rstudio.com/products/rstudio/download-server/redhat-centos/">https://rstudio.com/products/rstudio/download-server/redhat-centos/</a></li>
<li><a target="_blank" rel="noopener" href="https://rstudio.com/products/rstudio/download-server/debian-ubuntu/">https://rstudio.com/products/rstudio/download-server/debian-ubuntu/</a></li>
<li><a target="_blank" rel="noopener" href="https://support.rstudio.com/hc/en-us/articles/216079967-Upgrading-RStudio-Server">https://support.rstudio.com/hc/en-us/articles/216079967-Upgrading-RStudio-Server</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/10/14/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E5%AE%89%E8%A3%85RStudio-server-Install-RStudio-server-in-Server/" data-id="clm1xkn7r00a4dpnie8gkajgx" data-title="服务器上安装RStudio-server" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Rcpp学习笔记之简化版table-Rcpp_learn_note_simplified_table" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/14/Rcpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AE%80%E5%8C%96%E7%89%88table-Rcpp_learn_note_simplified_table/" class="article-date">
  <time class="dt-published" datetime="2019-10-14T13:53:46.564Z" itemprop="datePublished">2019-10-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/R/">R</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/14/Rcpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AE%80%E5%8C%96%E7%89%88table-Rcpp_learn_note_simplified_table/">Rcpp学习笔记之简化版table</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>R语言有一个自带的函数<code>table</code>能够统计输入变量中不同元素出现的次数，举个例子</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d <span class="operator">&lt;-</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;A&quot;</span><span class="punctuation">,</span><span class="string">&quot;B&quot;</span><span class="punctuation">,</span><span class="string">&quot;C&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">10</span><span class="punctuation">)</span></span><br><span class="line">table<span class="punctuation">(</span>d<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>果子老师曾写一篇推送，自己写了一个简化版的table，比R自带的table 运行的速度更快，如下</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">tableGZ <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="keyword">if</span><span class="punctuation">(</span><span class="built_in">sum</span><span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">==</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    data <span class="operator">&lt;-</span> x</span><br><span class="line">    input <span class="operator">&lt;-</span> unique<span class="punctuation">(</span>x<span class="punctuation">,</span> fromLast <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">    dd <span class="operator">&lt;-</span> sapply<span class="punctuation">(</span>input<span class="punctuation">,</span> </span><br><span class="line">                 <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="punctuation">&#123;</span><span class="built_in">sum</span><span class="punctuation">(</span>data<span class="operator">==</span>x<span class="punctuation">)</span><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line">    <span class="built_in">names</span><span class="punctuation">(</span>dd<span class="punctuation">)</span> <span class="operator">&lt;-</span> unique<span class="punctuation">(</span>data<span class="punctuation">,</span> fromLast <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">    dd</span><br><span class="line">  <span class="punctuation">&#125;</span> <span class="keyword">else</span><span class="punctuation">&#123;</span></span><br><span class="line">    data <span class="operator">&lt;-</span> x<span class="punctuation">[</span><span class="operator">!</span><span class="built_in">is.na</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">    input <span class="operator">&lt;-</span> unique<span class="punctuation">(</span>x<span class="punctuation">,</span> fromLast <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line">    dd <span class="operator">&lt;-</span> sapply<span class="punctuation">(</span>input<span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="built_in">sum</span><span class="punctuation">(</span>data <span class="operator">==</span> x<span class="punctuation">)</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line">    dd <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>dd<span class="punctuation">,</span> <span class="built_in">sum</span><span class="punctuation">(</span><span class="built_in">is.na</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">    <span class="built_in">names</span><span class="punctuation">(</span>dd<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>input<span class="punctuation">,</span> <span class="string">&#x27;NA&#x27;</span><span class="punctuation">)</span></span><br><span class="line">    dd</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们通过运行1000次代码，来比较下两者的运行速度</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bench<span class="operator">::</span>system_time<span class="punctuation">(</span><span class="keyword">for</span> <span class="punctuation">(</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">1000</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  tableGZ<span class="punctuation">(</span>d<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">process    real </span><br><span class="line"> <span class="number">42.9</span>ms  <span class="number">42.4</span>ms </span><br><span class="line"></span><br><span class="line">bench<span class="operator">::</span>system_time<span class="punctuation">(</span><span class="keyword">for</span> <span class="punctuation">(</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">1000</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  table<span class="punctuation">(</span>d<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">process    real </span><br><span class="line">  <span class="number">107</span>ms   <span class="number">106</span>ms  </span><br></pre></td></tr></table></figure>

<p>在我的电脑上，果子老师的代码运行速度比R自带的table快了将近3倍。当然这是有原因的，因为R的table的代码功能更加复杂，能够比较多个变量之间的关系，例如<code>table(d,d)</code>。</p>
<p>既然是简单的统计每个元素的次数，那么我就想着能不能写出一个比果子老师速度更快的函数。 于是，我抽空写了下面的代码</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">tableZG <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  </span><br><span class="line">  NA_pos <span class="operator">&lt;-</span> <span class="built_in">is.na</span><span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">  NA_num <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>NA_pos<span class="punctuation">)</span></span><br><span class="line">  </span><br><span class="line">  x <span class="operator">&lt;-</span> x<span class="punctuation">[</span><span class="operator">!</span>NA_pos<span class="punctuation">]</span></span><br><span class="line">  </span><br><span class="line">  out <span class="operator">&lt;-</span> vector<span class="punctuation">(</span><span class="built_in">length</span> <span class="operator">=</span> <span class="built_in">length</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  out_name <span class="operator">&lt;-</span> <span class="built_in">rep</span><span class="punctuation">(</span><span class="literal">NA</span><span class="punctuation">,</span>  <span class="built_in">length</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> <span class="punctuation">(</span>i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="built_in">length</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">&#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="punctuation">(</span>j <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="built_in">length</span><span class="punctuation">(</span>out_name<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="keyword">if</span> <span class="punctuation">(</span> <span class="built_in">is.na</span><span class="punctuation">(</span>out_name<span class="punctuation">[</span>j<span class="punctuation">]</span><span class="punctuation">)</span> <span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">          out_name<span class="punctuation">[</span>j<span class="punctuation">]</span> <span class="operator">&lt;-</span> x<span class="punctuation">[</span>i<span class="punctuation">]</span></span><br><span class="line">          out<span class="punctuation">[</span>j<span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="number">1</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> <span class="punctuation">(</span> out_name<span class="punctuation">[</span>j<span class="punctuation">]</span> <span class="operator">==</span> x<span class="punctuation">[</span>i<span class="punctuation">]</span> <span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">        out<span class="punctuation">[</span>j<span class="punctuation">]</span> <span class="operator">&lt;-</span> out<span class="punctuation">[</span>j<span class="punctuation">]</span> <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="punctuation">&#125;</span> </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> <span class="punctuation">(</span>NA_num <span class="operator">&gt;</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    na_end <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span><span class="operator">!</span><span class="built_in">is.na</span><span class="punctuation">(</span>out_name<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">    out_name<span class="punctuation">[</span>na_end <span class="operator">+</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> <span class="string">&#x27;NA&#x27;</span></span><br><span class="line">    out<span class="punctuation">[</span>na_end <span class="operator">+</span> <span class="number">1</span><span class="punctuation">]</span> <span class="operator">&lt;-</span> NA_num</span><br><span class="line">    </span><br><span class="line">  <span class="punctuation">&#125;</span> </span><br><span class="line">  na_pos <span class="operator">&lt;-</span> <span class="built_in">is.na</span><span class="punctuation">(</span>out_name<span class="punctuation">)</span></span><br><span class="line">  out_name <span class="operator">&lt;-</span> out_name<span class="punctuation">[</span><span class="operator">!</span>na_pos<span class="punctuation">]</span></span><br><span class="line">  out <span class="operator">&lt;-</span> out<span class="punctuation">[</span><span class="operator">!</span>na_pos<span class="punctuation">]</span></span><br><span class="line">  <span class="built_in">names</span><span class="punctuation">(</span>out<span class="punctuation">)</span> <span class="operator">&lt;-</span> out_name</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span>out<span class="punctuation">)</span></span><br><span class="line">  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>虽然我的代码更长了，但是并没有让速度提高，反而比果子老师的代码慢，甚至还不如R自带的table。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">system.time<span class="punctuation">(</span><span class="keyword">for</span> <span class="punctuation">(</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">1000</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  tableZG<span class="punctuation">(</span>d<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">process    real </span><br><span class="line">  <span class="number">148</span>ms   <span class="number">148</span>ms </span><br></pre></td></tr></table></figure>

<p>当然那么一长串代码并不是白写的，因为我特意避免了使用R特有的内容，所以代码能够很容易改写成<code>C++</code>代码使用<code>Rcpp</code>调用，从而提高速度</p>
<p>新建一个<code>tableC.cpp</code>文件，代码内容如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Rcpp.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Rcpp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [[Rcpp::export]]</span></span><br><span class="line"><span class="function">NumericVector <span class="title">tableC</span><span class="params">(CharacterVector cv)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// initialize variable</span></span><br><span class="line">  CharacterVector na = CharacterVector::<span class="built_in">create</span>(<span class="string">&quot;NA&quot;</span>);</span><br><span class="line">  NumericVector out = <span class="built_in">rep</span>(NumericVector::<span class="built_in">create</span>(<span class="number">0</span>), cv.<span class="built_in">size</span>());</span><br><span class="line">  CharacterVector out_name = <span class="built_in">rep</span>(na, cv.<span class="built_in">size</span>());</span><br><span class="line">  <span class="type">int</span> unique_num = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cv.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cv.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> ( out_name[j] == <span class="string">&quot;NA&quot;</span> )&#123;</span><br><span class="line">        out_name[j] = cv[i] ;</span><br><span class="line">        out[j] = <span class="number">1</span>;</span><br><span class="line">        unique_num += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> ( out_name[j] == cv[i] )&#123;</span><br><span class="line">        out[j] = out[j] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  out.<span class="built_in">attr</span>(<span class="string">&quot;names&quot;</span>) = out_name;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>然后在R里面用Rcpp这个C++代码，替换掉之前代码中的循环部分</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Rcpp<span class="operator">::</span>sourceCpp<span class="punctuation">(</span><span class="string">&quot;tableC.cpp&quot;</span><span class="punctuation">)</span></span><br><span class="line">tableZG <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  </span><br><span class="line">  NA_pos <span class="operator">&lt;-</span> <span class="built_in">is.na</span><span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">  NA_num <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>NA_pos<span class="punctuation">)</span></span><br><span class="line">  </span><br><span class="line">  x <span class="operator">&lt;-</span> <span class="built_in">as.character</span><span class="punctuation">(</span>x<span class="punctuation">[</span><span class="operator">!</span>NA_pos<span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">  res <span class="operator">&lt;-</span> tableC<span class="punctuation">(</span>x<span class="punctuation">)</span></span><br><span class="line">  res <span class="operator">&lt;-</span> res<span class="punctuation">[</span><span class="operator">!</span><span class="built_in">names</span><span class="punctuation">(</span>res<span class="punctuation">)</span> <span class="operator">==</span> <span class="string">&quot;NA&quot;</span><span class="punctuation">]</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> <span class="punctuation">(</span>NA_num <span class="operator">&gt;</span> <span class="number">0</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    res <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span>res<span class="punctuation">,</span> <span class="string">&quot;NA&quot;</span><span class="operator">=</span>NA_num<span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="built_in">return</span><span class="punctuation">(</span>res<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>于是这一次在C++的加持下，我写的table函数速度超过了果子老师的代码。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bench<span class="operator">::</span>system_time<span class="punctuation">(</span><span class="keyword">for</span> <span class="punctuation">(</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span><span class="number">1000</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  tableZG<span class="punctuation">(</span>d<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">process    real </span><br><span class="line"> <span class="number">30.1</span>ms  <span class="number">29.3</span>ms </span><br></pre></td></tr></table></figure>

<p>最后总结一下：如果一个操作只需要做一次，那么速度可能并不是最重要的。因为即便是一个原本要花24小时的代码，提速10倍，只要2小时，你可能也会愿意等一等。但是如果这个操作需要重复很多次，上百次，上千次，甚至上万次，那么你就可能等不下去了。你就需要对代码中的一些限速步骤进行优化，比如说table这种多功能函数，你就可以自己用R写一个简化版的函数，替换掉原先的代码。</p>
<p>如果对速度有更高的要求，那么就需要用到<code>C++</code>进行代码重写了。学习<code>C++</code>其实并不会特别难，因为有一个<code>Rcpp</code>简化了许多操作，你只需要掌握几个最基本的语言特性，比如说<code>C++</code>需要先定义变量才能使用变量。</p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li><a href="/archives/C++_For_R_User">给R使用者的C++最少必要知识</a></li>
<li><a href="/archives/Write_first_function_Using_Rcpp">Rcpp学习笔记之Hello World!</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/10/14/Rcpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%AE%80%E5%8C%96%E7%89%88table-Rcpp_learn_note_simplified_table/" data-id="clm1xknbo00khdpni2r7h8lbv" data-title="Rcpp学习笔记之简化版table" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/" rel="tag">C&#x2F;C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Rcpp学习笔记之Hello World!-Write_first_function_Using_Rcpp" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/13/Rcpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BHello%20World!-Write_first_function_Using_Rcpp/" class="article-date">
  <time class="dt-published" datetime="2019-10-13T15:52:36.990Z" itemprop="datePublished">2019-10-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/R/">R</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/13/Rcpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BHello%20World!-Write_first_function_Using_Rcpp/">Rcpp学习笔记之Hello World!</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在使用R语言多年以后，我终于开始去学习Rcpp，利用<code>C++</code>来提高运行速度。其实当你能熟练的使用一门语言后，再去学一门新的语言，并没有想象中的那么难，更何况Rcpp把很多脏活累活都给包办了，在里面调用<code>C++</code>还是挺方便。</p>
</blockquote>
<p>学习Rcpp的最重要一步是，运行一个”hello world!” 。如果能够运行”hello world!”就表明搞定了环境配置，后面就可以愉快的写代码了。</p>
<p>安装Rcpp的方式为，<code>install.packages(&quot;Rcpp&quot;)</code>， 安装过程中可能会出现一些问题，对于不同的操作系统需要做不同的准备工作，</p>
<ul>
<li>Windows: 安装Rtools</li>
<li>Mac: 安装Xcode，需要在App store下载</li>
<li>Linux: 需要有GCC的编译环境</li>
</ul>
<p>之后就让我们写人生中第一个<code>C++</code>函数， <code>hello</code>,</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么问题来了，这个函数应该如何才能让R语言调用呢？最简单的方式就是Rcpp的<code>cppFunction</code></p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&quot;Rcpp&quot;</span><span class="punctuation">)</span></span><br><span class="line">cppFunction<span class="punctuation">(</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">int hello()&#123;</span></span><br><span class="line"><span class="string">    std::cout &lt;&lt; &quot;Hello, World!&quot;;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#x27;</span><span class="punctuation">)</span></span><br><span class="line">hello<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>上面语句中，cppFunction中的<code>&#39;&#39;</code>中的内容是C++语句。在这条语句中，我们以<code>int hello()&#123;&#125;</code>定义了一个hello函数，这个函数不接受参数，返回一个整型。在函数里面一共有两条语句，每条语句都以<code>;</code>结尾。</p>
<p>第一条是调用了<code>C++</code>的标准库的cout, <code>std::cout</code>, 和R中以<code>包名::函数名</code>调用函数的方法类似。第二条则是<code>return 0</code>，返回结果。</p>
<p>除了利用<code>cppFunction</code>外，另外一种更常用的方法就是将代码放在其他文件中，然后用<code>sourceCpp</code>的方式读取。我们新建一个<code>hello.cpp</code>的文件，里面的内容如下(如果用Rstudio新建C++ 文件，它会提供一个模版用于修改)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Rcpp.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Rcpp;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[[Rcpp::export]]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** R</span></span><br><span class="line"><span class="comment">hello()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>之后在R里面加载并调用，和之前的结果一样。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>Rcpp<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">sourceCpp<span class="punctuation">(</span><span class="string">&quot;hello.cpp&quot;</span><span class="punctuation">)</span></span><br><span class="line">hello<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>解释下<code>C++</code>的代码。第一行是用<code>#include &lt;Rcpp.h&gt;</code>语句导入了Rcpp的头文件，类似于R里面的<code>install.package()</code>用于安装R包，然后用<code>using namespace xxx;</code> 的方式加载了两个库，Rcpp和std, 这就类似于R里面的<code>library()</code>函数。</p>
<p><code>C++</code>里面用<code>//</code>和<code>/*** 注释语句 */</code>进行代码注释。前者是注释单行，类似于R里面的<code>#</code>注释，后者是注释多行。只不过<code>//[Rcpp::export]]</code>这条注释有特殊的含义，在<code>sourceCpp</code>读取代码解析的过程中，被这条语句注释的函数能够在R里面调用。换句话说，如果你删了这句话，那么这个<code>hello</code>函数在R里面就是无法直接调用的。而<code>/*** R */</code>里面可以放R代码，会<code>c++</code>代码编译结束后运行，常用于代码测试。</p>
<p>假如我们能够成功运行上面的代码，那么接下来要做的事情就是学习<code>C++</code>的基本语法(参考<a href="/archives/C++_For_R_User">给R使用者的C++最少必要知识</a>)，学习Rcpp的数据结构。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/10/13/Rcpp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BHello%20World!-Write_first_function_Using_Rcpp/" data-id="clm1xknbn00kbdpni1hme6tck" data-title="Rcpp学习笔记之Hello World!" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/" rel="tag">C&#x2F;C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-给R使用者的C++最少必要知识-C++_For_R_User" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/13/%E7%BB%99R%E4%BD%BF%E7%94%A8%E8%80%85%E7%9A%84C++%E6%9C%80%E5%B0%91%E5%BF%85%E8%A6%81%E7%9F%A5%E8%AF%86-C++_For_R_User/" class="article-date">
  <time class="dt-published" datetime="2019-10-13T14:49:10.474Z" itemprop="datePublished">2019-10-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/R/">R</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/13/%E7%BB%99R%E4%BD%BF%E7%94%A8%E8%80%85%E7%9A%84C++%E6%9C%80%E5%B0%91%E5%BF%85%E8%A6%81%E7%9F%A5%E8%AF%86-C++_For_R_User/">给R使用者的C++最少必要知识</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><code>C++</code>是一门非常复杂的编程语言，但是如果你已经有一定的R语言基础，希望通过<code>C++</code>来提高代码效率，那么掌握下面几点就能够开始写代码了，然后通过Rcpp调用。</p>
<h2 id="C-是静态编程语言"><a href="#C-是静态编程语言" class="headerlink" title="C++是静态编程语言"></a><code>C++</code>是静态编程语言</h2><p><code>C++</code>是一门静态编程语言，这意味着对于一个变量而言，你需要<strong>先声明</strong>它，才能调用它。而且这个变量名的数据类型在使用过程中是无法更改的，这是因为它在内存中的大小已经固定了。 </p>
<p>举个例子，在R语言中，下面这个代码运行时不会报错（但是会被吐槽）</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a <span class="operator">&lt;-</span> 1</span><br><span class="line">a <span class="operator">&lt;-</span> <span class="string">&#x27;a&#x27;</span></span><br></pre></td></tr></table></figure>

<p>但是在<code>C++</code>中，下面的代码会被提示<code>error: redefinition of &#39;x&#39; with a different type: &#39;char&#39; vs &#39;int&#39;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>：每个<code>C++</code>语句后需要有<code>;</code>, 而R没有。</p>
<p>关于数据结构，标准<code>C++</code>的数据结构有如下几种</p>
<ul>
<li>整型: int, long</li>
<li>浮点型: float, double</li>
<li>逻辑: bool</li>
<li>字符: char</li>
</ul>
<p><code>C++</code>的字符串在STL(Standard Template Library)中。STL里有很多高级数据结构，例如向量(vector)和列表(List)限于篇幅请自行检索。</p>
<h2 id="C-的控制结构"><a href="#C-的控制结构" class="headerlink" title="C++的控制结构"></a><code>C++</code>的控制结构</h2><p><code>C++</code>的控制结构包括，for循环，while循环，if条件语句，switch条件语句，代码形式如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for loop</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">    ...;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while loop</span></span><br><span class="line"><span class="keyword">while</span> ( i &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">  ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if</span></span><br><span class="line"><span class="keyword">if</span> ()&#123;</span><br><span class="line">  ...;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>()&#123;</span><br><span class="line">  ...;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">  ...;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="type">char</span> grade = <span class="string">&#x27;D&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (grade )&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;great&#x27;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">break</span> ;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span> :</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;not bad&#x27;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">break</span> ;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span> :</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;Not good&#x27;</span> &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;wrong&#x27;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在代码形式上，if和while都是和R语言类似，for和switch则是有些不同。</p>
<p><code>C++</code>的循环效率远远高于R语言，而且将对应的R代码修改成<code>C++</code>并不复杂。因此会用<code>C++</code>的循环，就能优化很多R代码。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><code>C++</code>的函数和R不同，它的写法如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据结构 函数名(数据结构 参数, ...)&#123;</span><br><span class="line">  代码;</span><br><span class="line">  <span class="keyword">return</span> 变量名;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumTwo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> z = x + y;</span><br><span class="line">  <span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是在R中则是</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sumTwo <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">,</span> y<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">   z <span class="operator">&lt;-</span> x <span class="operator">+</span> y</span><br><span class="line">   <span class="built_in">return</span><span class="punctuation">(</span>z<span class="punctuation">)</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>因此在改成原有的R函数时要注意两者的区别，</p>
<ul>
<li>代码形式不同</li>
<li>参数名要声明数据类型</li>
<li>return后直接跟变量名</li>
</ul>
<p>在函数的使用上，<code>C++</code>和R就没有区别了，都是<code>函数名(变量)</code>，举个例子<code>sumTwo(1,2)</code></p>
<h2 id="额外库加载"><a href="#额外库加载" class="headerlink" title="额外库加载"></a>额外库加载</h2><p>在使用R语言的大部分时间里，我们都是面向R包编程，也就是搜索一个R包，然后安装R包，加载R包，调用函数。对于<code>C++</code>而言，也有许多现成的库，能够让我们避免造轮子。</p>
<p>举个例子，加载Rcpp库，调用R函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Rcpp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Rcpp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//[[Rcpp::export]]</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;N(0,1) 95th percential %9.8f\n&quot;</span>,</span><br><span class="line">         R::<span class="built_in">qnorm</span>(<span class="number">0.95</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里<code>#include</code>类似于安装R包，而<code>using namespace Rcpp;</code>则是<code>library</code>加载R包。</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><code>C++</code>和R语言都是一门面向对象编程语言。R里面有S3，S4，RC等形式，<code>C++</code>则是<code>struct</code>和<code>class</code>两种形式，举个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Date</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> year;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> month;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> date;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> year;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> month;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> date;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setDate</span><span class="params">(<span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> d)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getDay</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getMonth</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getYear</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>强行联系的话，R的S3和<code>C++</code>的struct比较像，R的S4和<code>C++</code>的Date比较像，因为R的S3比较宽松，是基于list的堆叠，内部数据直接暴露到外部，而S4则是比较安全。<code>C++</code>的class用private保证private无法直接被外部访问，只能功过public暴露的函数进行操作。</p>
<h2 id="指针和内存管理"><a href="#指针和内存管理" class="headerlink" title="指针和内存管理"></a>指针和内存管理</h2><p>指针和内存管理是两个比较高级的话题，如果你学习C语言不懂指针那你就和没学过C一样。不过我们学的是<code>C++</code>，只要不涉及到很高级的操作，那么我们完全可以避免接触它们。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于一个R语言使用者而言，如果想学习<code>C++</code>，那么至少需要知道如下几个概念</p>
<ul>
<li>变量声明</li>
<li>控制结构，for, while, if-else</li>
<li>函数编写和调用</li>
<li>额外库</li>
<li>面向对象</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/10/13/%E7%BB%99R%E4%BD%BF%E7%94%A8%E8%80%85%E7%9A%84C++%E6%9C%80%E5%B0%91%E5%BF%85%E8%A6%81%E7%9F%A5%E8%AF%86-C++_For_R_User/" data-id="clm1xkn8n00bodpni4lezfms1" data-title="给R使用者的C++最少必要知识" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-C/" rel="tag">C&#x2F;C++</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-如何对基因组序列进行注释-How-to-annotate-your-genome" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/11/%E5%A6%82%E4%BD%95%E5%AF%B9%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%BA%8F%E5%88%97%E8%BF%9B%E8%A1%8C%E6%B3%A8%E9%87%8A-How-to-annotate-your-genome/" class="article-date">
  <time class="dt-published" datetime="2019-10-11T14:56:46.108Z" itemprop="datePublished">2019-10-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/11/%E5%A6%82%E4%BD%95%E5%AF%B9%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%BA%8F%E5%88%97%E8%BF%9B%E8%A1%8C%E6%B3%A8%E9%87%8A-How-to-annotate-your-genome/">如何对基因组序列进行注释</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>基因组组装完成后，或者是完成了草图，就不可避免遇到一个问题，需要对基因组序列进行注释。注释之前首先得构建基因模型，有三种策略：</p>
<ul>
<li>从头注释(<em>de novo</em> prediction)：通过已有的概率模型来预测基因结构，在预测剪切位点和UTR区准确性较低</li>
<li>同源预测(homology-based prediction)：有一些基因蛋白在相近物种间的保守型搞，所以可以使用已有的高质量近缘物种注释信息通过序列联配的方式确定外显子边界和剪切位点</li>
<li>基于转录组预测(transcriptome-based prediction)：通过物种的RNA-seq数据辅助注释，能够较为准确的确定剪切位点和外显子区域。</li>
</ul>
<p>每一种方法都有自己的优缺点，所以最后需要用EvidenceModeler(EVM)和GLEAN工具进行整合，合并成完整的基因结构。基于可靠的基因结构，后续可才是功能注释，蛋白功能域注释，基因本体论注释，通路注释等。</p>
<p>那么基因注释重要吗？可以说是非常重要了，尤其是高通量测序非常便宜的现在。你可以花不到一万的价格对600M的物种进行100X的普通文库测序，然后拼接出草图。但是这个草图的价值还需要你进行注释后才能显现出来。有可能你和诺贝尔奖就差一个注释的基因组。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-8c9601ef6651e157-2c2a2743d4d64b31a902dbaf23b62ac5.png" alt="基因注释的重要性"></p>
<h2 id="从案例中学习套路"><a href="#从案例中学习套路" class="headerlink" title="从案例中学习套路"></a>从案例中学习套路</h2><h3 id="陆地棉基因组注释"><a href="#陆地棉基因组注释" class="headerlink" title="陆地棉基因组注释"></a>陆地棉基因组注释</h3><p>文章标题为“Sequencing of allotetraploid cotton (Gossypium hirsutum L. acc. TM-1) provides a resource for fiber improvement”.</p>
<p><strong>同源注释</strong>：从Phytozome上下载了7个植物的基因组蛋白序列(Arabidopsis thaliana, Carica papaya, Glycine max, G. raimondii, Populus trichocarpa, Theobroma cacao and Vitis vinifera), 使用 <em>TblastN</em> 将蛋白序列比对到组装序列上，E-value的阈值为1e-5. 将不同蛋白的BLAST的hits用 <em>Solar</em> 软件进行合并。<em>GeneWise</em> 根据每个BLAST hit的对应基因区域预测完整的基因结构。</p>
<p><strong>从头预测</strong>：先得构建repeat-mask genome， 在这个基础上就用 <em>August</em>, <em>Genescan</em>, <em>GlimmerHMM</em>, <em>Geneid</em> 和 <em>SNAP</em> 预测编码区</p>
<p><strong>转录组预测</strong>：用Tophat将RNA-seq数据比对到组装序列上，然后用cufflinks组装转录本形成基因模型。</p>
<p>综上，使用 <em>EvidenceModeler(EVM)</em> 将上面的结果组装成非冗余的基因结构。进一步根据Cscore &gt; 0.5，peptide coverage &gt; 0.5 和CDS overlaping with TE进行筛选。还有过滤掉超过30%编码区被Pfam或Interprot TE domain的注释的基因模型。</p>
<p>这些基因模型使用BLASTP进行功能注释，所用数据库为SWiss-Prot和TrEMBL.蛋白功能使用InterProScan和HMMER注释，数据库为InterPro和Pfam。GO注释则是直接雇佣InterPro和Pfam注释得到的对应entry。通路注释使用KEGG数据库。</p>
<h3 id="Cardamine-hirsuta基因组注释"><a href="#Cardamine-hirsuta基因组注释" class="headerlink" title="Cardamine hirsuta基因组注释"></a>Cardamine hirsuta基因组注释</h3><p>文章标题为“The Cardamine hirsuta genome offers insight into the evolution of morphological diversity”。</p>
<p><strong>同源注释</strong>：使用 <em>GenomeThreader</em> 以拟南芥为剪切模型，以及PlantsGDB resourc上 <em>Brassica rapa</em> (v1.1), <em>A. thaliana</em>(TAIR10), <em>A. lyrata</em> (v6), <em>tomato</em> (v3.6), <em>poplar</em> (v2) 和 <em>A. thaliana</em> (version PUT-169), <em>B. napus</em> (version PUT-172) EST assemblies 的完整的代表性蛋白集。</p>
<p><strong>转录本预测</strong>： 将 <em>C. hirsuta</em> RNA-seq数据比对到基因序列，然后用cufflinks拼接</p>
<p><strong>从头预测</strong>：转录本预测得到的潜在蛋白编码转录本使用网页工具 <em>ORFpredictor</em> 进行预测， 同时用 <em>blastx</em> 和 <em>A. thalina</em> 进行比较，选择90%序列相似度和最高5%长度差异的部分从而保证保留完整的编码框(有启动子和终止子)。 这些基因模型根据相互之间的相似度和重叠度进行聚类，高度相似(&gt;95)从聚类中剔除，保证非冗余训练集。为了训练gene finder, 它们选随机选取了2000个位点，20%是单个外显子基因。从头预测工具为 <em>August</em> , <em>GlimmerHMM</em>, <em>Geneid</em> 和 <em>SNAP</em> . 此外还用了Fgenesh+, 以双子叶特异矩阵为参数进行预测。</p>
<p>最后使用JIGSAW算法根据以上结果进行训练，随后再次用JIGSAW对每个基因模型计算统计学权重。</p>
<p>可变剪切模型则是基于苗、叶、花和果实的RNA-seq比对组装结果。</p>
<p>GO注释使用<a target="_blank" rel="noopener" href="https://github.com/groupschoof/AHRD/">AHRD流程</a></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>举的2个例子都是植物，主要是植物基因组不仅是组装，注释都是一大难题。因为植物基因组有大量的重复区，假基因，还有很多新的蛋白编码基因和非编码基因，比如说玉米基因组80%以上都是重复区域。然后当我检索这两篇文章所用工具的时候，我不经意或者说不可避免就遇到了这个网站 <a target="_blank" rel="noopener" href="http://www.plantgdb.org/">http://www.plantgdb.org/</a> , 一个整合植物基因组学工具和资源的网站，但是这个网站似乎2年没有更新了。当然这个网站也挺不错,<a target="_blank" rel="noopener" href="http://bioservices.usd.edu/gsap.html">http://bioservices.usd.edu/gsap.html</a>, 他给出了一套完整的注释流程以及每一步的输入和输出情况。</p>
<p>此外，2017年在《Briefings in Bioinformatics》发表的”Plant genome and transcriptome annotations: from misconceptions to simple solution” 则是从五个角度对植物基因组注释做了很完整的总结</p>
<ul>
<li>植物科学的常见本体</li>
<li>功能注释的常用数据库和资源</li>
<li>已注释的植物基因组意味着什么</li>
<li>一个自动化注释流程</li>
<li>一个参考流程图，用来说明使用公用数据库注释植物基因组&#x2F;转录组的常规步骤</li>
</ul>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-f5472a3dada24b75-4acf9e3d46e44f58a96f8843d10f5458.png" alt="注释流程图"></p>
<p>以上，通过套路我们对整个基因组注释有一个大概的了解，后续就需要通过实际操作来理解细节。</p>
<h2 id="基因组注释"><a href="#基因组注释" class="headerlink" title="基因组注释"></a>基因组注释</h2><p>当我们谈到基因注释的时候，我们通常认为注释是指“对基因功能的描述”，比如说A基因在细胞的那个部分，通过招募B来调控C，从而引起病变。但是基因结构也是注释的一种形式，而且是先决条件，也就是在看似随机的ATCG的碱基排列中找到特殊的部分，而这些特殊的区域有着不一样的功能。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-b5a07df1dedaa354-e340ae1c7a7040049ac93c04d89b2a49.png" alt="gene structure"></p>
<p>在正式启动基因组注释项目之前，需要先检查组装是否合格，比如contig N50的长度是否大于基因的平均长度，使用BUSCO&#x2F;CEGMA检查基因的完整性，如果不满足要求，可能输出结果中大部分的contig中都不存在一个完整的基因结构。当组装得到的contig符合要求时，就可以开始基因组注释环节，这一步分为三步：基因结构预测，基因功能注释，可视化和质控。</p>
<h3 id="基因组结构注释"><a href="#基因组结构注释" class="headerlink" title="基因组结构注释"></a>基因组结构注释</h3><p>基因结构注释应是功能注释的先决条件，完整的真核生物基因组注释流程需要如下步骤：</p>
<ol>
<li>必要的基因组重复序列屏蔽</li>
<li>从头寻找基因, 可用工具为: GeneMarkHMM, FGENESH, Augustus, SNAP, GlimmerHMM, Genscan</li>
<li>同源蛋白预测, 内含子分析: GeneWIse, Exonerate, GenomeThreader</li>
<li>将EST序列，全长cDNA序列和Trinity&#x2F;Cufflinks&#x2F;Stringtie组装的转录组和基因组联配</li>
<li>如果第4步用到了多个数据来源，使用PASA基于重叠情况进行联配</li>
<li>使用EvidenceModler根据上述结果进行整合</li>
<li>使用PASA更新EVM的一致性预测，增加UTR注释和可变剪切注释</li>
<li>必要的人工检查</li>
</ol>
<p>基本上是套路化的分析流程，也就有一些工具通过整合几步开发了流程管理工具，比如说BRAKER结合了GeneMark和Augustus，MAKER2整合了SNAP,Exonerate，虽然BRAKER说自己的效果比MAKER2好，但是用的人似乎不多，根据web of knowledge统计，两者的引用率分别是44,283, 当然BRAKER是2016，MAKER2是2011，后者在时间上有优势。</p>
<p>这里准备先按部就班的按照流程进行注释，所用的数据是 <em>Cardamine hirsuta</em> , 数据下载方式如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cardamine hirsutat基因组数据</span></span><br><span class="line"><span class="built_in">mkdir</span> chi_annotation &amp;&amp; <span class="built_in">cd</span> chi_annotation</span><br><span class="line">wget http://chi.mpipz.mpg.de/download/sequences/chi_v1.fa</span><br><span class="line"><span class="built_in">cat</span> chi_v1.fa | <span class="built_in">tr</span> <span class="string">&#x27;atcg&#x27;</span> <span class="string">&#x27;ATCG&#x27;</span> &gt; chi_unmasked.fa</span><br><span class="line"><span class="comment"># 注释结果</span></span><br><span class="line">wget http://chi.mpipz.mpg.de/download/annotations/carhr38.gff</span><br><span class="line"><span class="comment"># Cardamine hirsutat转录组数据</span></span><br><span class="line"><span class="built_in">mkdir</span> rna-seq &amp;&amp; <span class="built_in">cd</span> rna-seq</span><br><span class="line">wget -4 -q -A <span class="string">&#x27;*.fastq.gz&#x27;</span> -np -nd -r 2 http://chi.mpipz.mpg.de/download/fruit_rnaseq/cardamine_hirsuta/ &amp;</span><br><span class="line">wget -4 -q -A <span class="string">&#x27;*.fastq.gz&#x27;</span> -np -nd -r 2 http://chi.mpipz.mpg.de/download/leaf_rnaseq/cardamine_hirsuta/ &amp;</span><br></pre></td></tr></table></figure>

<p>软件安装不在正文中出现，会放在附录中，除了某些特别复杂的软件。</p>
<h4 id="01-重复序列屏蔽"><a href="#01-重复序列屏蔽" class="headerlink" title="01-重复序列屏蔽"></a>01-重复序列屏蔽</h4><p><strong>重复屏蔽</strong>：真核生物的基因组存在大量的重复序列，植物基因组的重复序列甚至可以高达80%。尽管重复序列对维持染色体的空间结构、基因的表达调控、遗传重组等都具有重要作用，但是却会导致BLAST的结果出现大量假阳性，增加基因结构的预测的计算压力甚至影响注释正确性。基因组中的重复按照序列特征可以分为两类：串联重复(tandem repeats)和散在重复(interspersed repeats).</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-82b4f41b84eba54b-2a776bfefb084c85a2b9c2d75905c4a3.png" alt="人类中的重复序列划分"></p>
<p>鉴定基因组重复区域的方法有两种：一种基于文库(library)的同源(homology)方法，该文库收集了其他物种的某一种重复的一致性序列，通过相似性来鉴定重复；另一种是从头预测(<em>de novo</em>)，将序列和自己比较或者是高频K-mer来鉴定重复。</p>
<p>目前重复序列注释主要软件就是RepeatMasker和RepeatModel。这里要注意分析的fasta的ID不能过长，不然会报错。如果序列ID过长可以使用bioawk进行转换，后续用到RepatModel不支持多行存放序列的fasta格式。</p>
<p>直接使用同源注释工具RepeatMasker寻找重复序列：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 00-RepeatMask</span><br><span class="line">~/opt/biosoft/RepeatMasker/RepeatMasker -e ncbi -species arabidopsis -pa 40 -gff -<span class="built_in">dir</span> 00-RepeatMask/ chi_unmasked.fa</span><br><span class="line"><span class="comment"># -e ncbi</span></span><br><span class="line"><span class="comment"># -species 选择物种 用~/opt/biosoft/RepeatMasker/util/queryRepeatDatabase.pl -tree 了解</span></span><br><span class="line"><span class="comment"># -lib 增加额外数据库,</span></span><br><span class="line"><span class="comment"># -pa 并行计算</span></span><br><span class="line"><span class="comment"># -gff 输出gff注释</span></span><br><span class="line"><span class="comment"># -dir 输出路径</span></span><br><span class="line"><span class="comment"># annotation with the library produced by RepeatModel</span></span><br></pre></td></tr></table></figure>

<p>输出结果中主要关注如下三个(其中xxx表示一类文件名)</p>
<ul>
<li>xxx.fa.masked, 将重复序列用N代替</li>
<li>xxx.fa.out.gff, 以gff2形式存放重复序列出现的位置</li>
<li>xxx.fa.tbl, 该文件记录着分类信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> 00-RepeatMask/chi_unmasked.fa.tbl</span><br><span class="line">==================================================</span><br><span class="line">file name: chi_unmasked.fa</span><br><span class="line">sequences:           624</span><br><span class="line">total length:  198654690 bp  (191241357 bp excl N/X-runs)</span><br><span class="line">GC level:         35.24 %</span><br><span class="line">bases masked:   35410625 bp ( 17.83 %)</span><br><span class="line">==================================================</span><br></pre></td></tr></table></figure>

<p>也就是说该物种198M中有将近18%的重复序列，作为参考，拟南芥125Mb 14%重复序列, 水稻389M，36%重复，人类基因组是3G，50%左右的重复序列。</p>
<p>使用最后的<code>chi_unmasked.fa.masked</code>用于下一步的基因结构预测。</p>
<p>注：当然也可以用RepeatModel进行从头预测，得到的预测结果后续可以整合到RepeatMasker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># de novo predict</span></span><br><span class="line">~/opt/biosoft/RepeatModeler-open-1.0.11/BuildDatabase -name <span class="built_in">test</span> -engine ncbi output.fa</span><br><span class="line">~/opt/biosoft/RepeatModeler-open-1.0.11/RepeatModeler -database <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>这一步速度极其慢，由于我们的目的只是获取屏蔽后序列降低后续从头预测的压力，所以可以先不做这一步。在后续分析重复序列在基因组进化上的作用时可以做这一步。下</p>
<blockquote>
<p>如果从头预测的结果与同源预测的结果有30%以上的overlap，并且分类不一致，会把从头预测的结果过滤掉。从头预测与同源预测结果有overlap，但是分类一致的，都会保留。但是统计的时候不会重复统计。</p>
</blockquote>
<h4 id="02-从头-ab-initio-预测基因"><a href="#02-从头-ab-initio-预测基因" class="headerlink" title="02-从头(ab initio)预测基因"></a>02-从头(ab initio)预测基因</h4><h5 id="基于已有模型或无监督训练"><a href="#基于已有模型或无监督训练" class="headerlink" title="基于已有模型或无监督训练"></a>基于已有模型或无监督训练</h5><p>目前的从头预测软件大多是基于HMM(隐马尔科夫链)和贝叶斯理论，通过已有物种的注释信息对软件进行训练，从训练结果中去推断一段基因序列中可能的结构，在这方面做的最好的工具是<strong>AUGUSTUS</strong> 它可以仅使用序列信息进行预测，也可以整合EST, cDNA, RNA-seq数据作为先验模型进行预测。</p>
<p>AUGUSTUS的无root安装比较麻烦，我折腾了好几天最后卒，不过辛亏有bioconda，<code>conda create -n annotation augustus=3.3</code>.</p>
<p>它的使用看起来很简单，我们可以尝试使用一段拟南芥已知的基因序列让其预测，比如前8k序列</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seqkit faidx TAIR10.fa Chr1:1-8000 &gt; test.fa</span><br><span class="line">augustus --speices=arabidopsis test.fa &gt; test.gff</span><br></pre></td></tr></table></figure>

<p>如果仅仅看两者的CDS区，结果完全一致，相当于看过一遍参考答案去做题目，题目都做对了。</p>
<blockquote>
<p>注:已经被训练的物种信息可以用<code>augustus --species=help</code>查看。</p>
</blockquote>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-d7184dedba04ef7b-8f36de4ffea447dea61de1765882f4e8.png" alt="结果比较"></p>
<p>在<strong>不使用RNA-seq数据</strong>的情况下，可以基于拟南芥的训练模型进行预测，采用下面的方式多条染色体并行augustus</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 01-augustsus &amp;&amp; <span class="built_in">cd</span> 01-augustsus</span><br><span class="line"><span class="built_in">ln</span> ../00-RepeatMask/chi_unmasked.fa.masked genome.fa</span><br><span class="line">seqkit <span class="built_in">split</span> genome.fa <span class="comment">#结果文件在genome.fa.split</span></span><br><span class="line">find genome.fa.split/ -<span class="built_in">type</span> f -name <span class="string">&quot;*.fa&quot;</span> | parallel -j 30 augustus --species=arabidopsis --gff3=on &gt;&gt; temp.gff <span class="comment">#并行处理</span></span><br><span class="line">join_aug_pred.pl &lt; temp.gff  | grep -v <span class="string">&#x27;^#&#x27;</span> &gt; temp.joined.gff</span><br><span class="line">bedtools <span class="built_in">sort</span> -i temp.joined.gff &gt; augustsus.gff</span><br></pre></td></tr></table></figure>

<p>AUGUSTUS依赖于已有的模型，而<strong>GeneMark-ES&#x2F;ET</strong>则是唯一一款支持无监督训练模型，之后再识别真核基因组蛋白编码区的工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gmes_petap.pl --ES --sequence genome.fa --cores 50</span><br></pre></td></tr></table></figure>

<p>最后得到的是genemark.gtf，是标准的GTF格式，可以使用Sequence Ontology Project提供的gtf2gff3.pl进行转换</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://genes.mit.edu/burgelab/miso/scripts/gtf2gff3.pl</span><br><span class="line"><span class="built_in">chmod</span> 755 gtf2gff3.pl</span><br><span class="line">gtf2gff3.pl genemark.gtf | bedtools <span class="built_in">sort</span> -i - &gt; genemark.gff</span><br></pre></td></tr></table></figure>

<p>不同从头预测软件的实际效果可以通过在IGV中加载文章提供的gff文件和预测后的gff文件进行比较，一般会存在如下几个问题：</p>
<ul>
<li>基因多了，或者少了，也就是假阳性和假阴性现象</li>
<li>UTR区域难以预测，这个比较正常</li>
<li>未正确识别可变剪切位点，导致前后几个基因识别成一个基因</li>
</ul>
<p>考虑到转录组测序已经非常便宜，可以通过该物种的RNA-seq提供覆盖度信息进行预测。</p>
<h5 id="基于转录组数据预测"><a href="#基于转录组数据预测" class="headerlink" title="基于转录组数据预测"></a>基于转录组数据预测</h5><p>根据已有的模型或者自训练可以正确预测很大一部分的基因，但如果需要提高预测的正确性，还需要额外的信息。在过去就需要提供物种本身的cDNA, EST，而现在更多的是基于转录组序列进行训练。尽管RNA-seq数据在基因组上的比对情况能够推测出内含子位置，根据覆盖度可以推测出外显子和非编码区的边界，但是仅仅依赖于RNA-seq的覆盖不能可信地推测出蛋白编码区(Hoff K.J. Stanke M. 2015).</p>
<p>AUGUSTUS可以利用转录组比对数据中的位置信息来训练模型，GeneMark-ET可以利用RNA-seq得到的内含子位点信息自我训练HMM参数，进行基因预测。BRAKER2将两者进行整合，使用GeneMark-ET根据RNA-seq无监督训练模型寻找基因，然后用AUGUSTUS进行模型训练，最后完成基因预测</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-693396ba4693efa0-9a4534b6b3924f3284a117698b926893.png" alt="BRAKER流程"></p>
<p>首先使用hisat2根据屏蔽后的参考序列建立索引，进行比对。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目根目录</span></span><br><span class="line"><span class="built_in">mkdir</span> index</span><br><span class="line">hisat2-build 01-augustus/genome.fa index/chi_masked</span><br><span class="line">hisat2 -p 20 -x index/chi_masked -1 rna-seq/leaf_ox_r1_1.fastq.gz -2 rna-seq/leaf_ox_r1_2.fastq.gz | samtools <span class="built_in">sort</span> -@ 10 &gt; 02-barker/leaf_ox_r1.bam &amp;</span><br><span class="line">isat2 -p 20 -x index/chi_masked -1 rna-seq/ox_flower9_rep1_1.fastq.gz -2 rna-seq/ox_flower9_rep1_2.fastq.gz | samtools <span class="built_in">sort</span> -@ 10 &gt; 02-barker/ox_flower9.bam &amp;</span><br><span class="line">hisat2 -p 20 -x index/chi_masked -1 rna-seq/ox_flower16_rep1_1.fastq.gz -2 rna-seq/ox_flower16_rep1_2.fastq.gz | samtools <span class="built_in">sort</span> -@ 10 &gt; 02-barker/ox_flower16.bam &amp;</span><br></pre></td></tr></table></figure>

<p>然后，以未屏蔽重复序列的参考序列和BAM文件作为输入，让BRAKER2（安装会稍显麻烦，因为依赖许多软件）进行预测。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">braker.pl --gff3 --cores 50 --species=carhr --genome=chi_unmasked.fa --bam=02-barker/leaf_ox_r1.bam,02-barker/ox_flower16.bam,02-barker/ox_flower9.bam</span><br><span class="line"><span class="comment"># --gff3: 输出GFF3格式</span></span><br><span class="line"><span class="comment"># --genome: 基因组序列</span></span><br><span class="line"><span class="comment"># --bam: 比对后的BAM文件，允许多个</span></span><br><span class="line"><span class="comment"># --cores: 处理核心数</span></span><br></pre></td></tr></table></figure>

<p>最后会得到如下输出文件</p>
<ul>
<li>hintsfile.gff: 从RNA-seq比对结果的BAM文件中提取，其中内含子用于训练GeneMark-EX, 使用所有特征训练AUGUSTUS</li>
<li>GeneMark-ET&#x2F;genemark.gtf: GeneMark-EX根据RNA-seq数据训练后预测的基因</li>
<li>augustus.hints.gff: AUGUSTUS输出文件</li>
</ul>
<p>将augustus.hints.gff3和文章的注释文件(carhr38.gtf)比较，见下图：</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-0200855851b844ce-bb010eed70444f82ab494eb706e92087.png" alt="结果比较"></p>
<p>其实不难发现，在不考虑UTR区域情况下，两者的差别其实更多表现是基因数目上，其实也就是利用转录组数据推测结构的问题所在，没有覆盖的区域到底是真的没有基因，还是有基因结构只不过所用组织没有表达，或者说那个区域其实是假基因？此外，如果基因间隔区域很短，有时候还会错误地把两个不同的基因预测为一个基因。因此，应该注重RNA-seq数据在<strong>剪切位点识别</strong>和<strong>外显子边界确定</strong>的优势。</p>
<h4 id="03-同源预测基因结构"><a href="#03-同源预测基因结构" class="headerlink" title="03-同源预测基因结构"></a>03-同源预测基因结构</h4><p>同源预测(homology prediction)利用近缘物种已知基因进行序列比对，找到同源序列。然后在同源序列的基础上，根据基因信号如剪切信号、基因起始和终止密码子对基因结构进行预测，如下示意图：</p>
<p><img src="/assets/2013053-b5a07df1dedaa354.png" alt="同源注释"></p>
<p>相对于从头预测的“大海捞针”，同源预测相当于先用一块磁铁在基因组大海中缩小了可能区域，然后从可能区域中鉴定基因结构。在10年之前，当时RNA-seq还没有普及, 只有少部分物种才有EST序列和cDNA序列的情况下，这的确是一个比较好的策略，那么问题来了，现在还需要进行这一步吗，如果需要是出于那种角度考虑呢?</p>
<p>在同源预测上，目前看到的大部分基因组文章都是基于TBLASTN + GeneWise，这可能是因为大部分基因组文章都是国内做的，这些注释自然而言用的就是公司的流程，然后目前国内的公司大多数又和某一家公司有一些关系。不过最近的3010水稻泛基因组用的是MAKER, 感谢部分提到这部分工作是由M. Roa(Philippine Genome Center Core Facilities for Bioinformatics, Department of Science)做的，算是一股清流吧。当然我在看Cardamine hirsuta基因组注释文章，发现它们同源注释部分用的是GenomeThreader, 该工具在本篇文章成文时的3月之前又更新了。</p>
<p>GeneWise的网站说它目前由Ewan Birney维护，只不过不继续开发了，因为Guy Slater开发Exonerate解决了GeneWise存在的很多问题，并且速度快了1000倍。考虑到目前只有GeneWise能利用HMM根据蛋白找DNA，而且ENSEMBL的注释流程也有一些核心模块用到了它，所以作者依旧在缓慢的开发这个工具(自2.4.1已经10多年没有更新了)，当然这个工具也是非常的慢。尽管这一步不会用到GeneWise作为我们的同源注释选项，但是我们可以尝试用GeneWise手工注释一个基因，主要步骤如下</p>
<ul>
<li>第一步： 使用BLASTX，根据dna序列搜索到蛋白序列，只需要第一个最佳比对结果</li>
<li>第二步： 选择最佳比对的氨基酸序列</li>
<li>第三步： 将dna序列前后延长2kb，与氨基酸序列一并传入给genewise进行同源预测</li>
</ul>
<p>提取前5K序列，然后选择在TAIR上用BLASTX进行比对</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seqkit faidx chi_unmasked.fa Chr1:1-5000 &gt; chr1_5k.fa</span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-562fefad5dec9b07-6a137a307f494a6385192c6d270ef644.png" alt="BLASTX"></p>
<p>选择第一个比对结果中的氨基酸序列，和前5k的DNA序列一并作为GeneWise的输入</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-da3cb7a46b5327a5-38978a3654cd461e96b6208b54c8fef6.png" alt="GeneWise2"></p>
<p>最后的结果出乎了我的意料</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-65f7c80123c3f586-b52d6c6326d14440886443690aabbdef.png" alt="预测结果"></p>
<p>让我们跳过这个尴尬的环节，毕竟很可能是我不太熟练使用工作所致。这里说点我的看法，除非你真的没有转录组数据，必须要用到同源物种的蛋白进行预测，或者你手动处理几个基因，否则不建议使用这个工具，因为你可能连安装都搞不定。</p>
<p>让我们用GenomeThreader基于上面的DNA序列和氨基酸序列进行同源基因结构预测吧</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gth -genomic chr1_5k.fa -protein cer.fa -intermediate -gff3out</span><br><span class="line"><span class="comment"># 其中cer.fa就是AT1G02205.2的氨基酸序列</span></span><br></pre></td></tr></table></figure>

<p>结果一致，并且从RNA-seq的覆盖情况也符合预期</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Chr1	gth	exon	1027	1197	Parent=gene1	Chr1    MIPS_CARH_v3.8  exon    1027    1197</span><br><span class="line">Chr1	gth	exon	1275	1448	Parent=gene1	Chr1    MIPS_CARH_v3.8  exon    1275    1448</span><br><span class="line">Chr1	gth	exon	1541	1662	Parent=gene1	Chr1    MIPS_CARH_v3.8  exon    1555    1662</span><br><span class="line">Chr1	gth	exon	1807	2007	Parent=gene1	Chr1    MIPS_CARH_v3.8  exon    1807    2007</span><br><span class="line">Chr1	gth	exon	2085	2192	Parent=gene1	Chr1    MIPS_CARH_v3.8  exon    2085    2192</span><br><span class="line">Chr1	gth	exon	2294	2669	Parent=gene1	Chr1    MIPS_CARH_v3.8  exon    2294    2669</span><br><span class="line">Chr1	gth	exon	3636	3855	Parent=gene1	Chr1    MIPS_CARH_v3.8  exon    3636    3855</span><br><span class="line">Chr1	gth	exon	3971	4203	Parent=gene1	Chr1    MIPS_CARH_v3.8  exon    3971    4203</span><br><span class="line">Chr1	gth	exon	4325	4548	Parent=gene1	Chr1    MIPS_CARH_v3.8  exon    4325    4548</span><br><span class="line">Chr1	gth	exon	4676	4735	Parent=gene1	Chr1    MIPS_CARH_v3.8  exon    4676    4735</span><br></pre></td></tr></table></figure>

<p>全基因组范围预测流程如下：</p>
<p>准备cDNA和或protein序列：在<a target="_blank" rel="noopener" href="https://phytozome.jgi.doe.gov/p">https://phytozome.jgi.doe.gov/p</a>下载靠谱的物种的蛋白质序列，如 <em>Arabidopsis thaliana</em>, <em>Oryza sativa</em>, <em>Brassica rapa</em>, 查找文献寻找目前该物种的已有EST&#x2F;cDNA序列，或者RNA-seq从头组装转录组。这里仅考虑用同源物种的蛋白序列进行比对分析，转录组从头组装数据用于PASA整体比对到参考基因组和更新已有的基因解雇。</p>
<p>分别测试下不同物种的同源注释结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#run seperately</span></span><br><span class="line">gth -species arabidopsis -translationtable 1 -gff3 -intermediate -protein ~/db/protein_db/Athaliana_167_TAIR10.protein.fa.gz -genomic chi_unmasked.fa -o 03-genomethreader/Athaliana.gff3 &amp;</span><br><span class="line">gth -species arabidopsis -translationtable 1 -gff3 -intermediate -protein ~/db/protein_db/BrapaFPsc_277_v1.3.protein.fa.gz -genomic chi_unmasked.fa -o 03-genomethreader/Brapa.gff3 &amp;</span><br><span class="line">gth -species arabidopsis -translationtable 1 -gff3 -intermediate -protein ~/db/protein_db/Osativa_323_v7.0.protein.fa.gz -genomic chi_unmasked.fa -o 03-genomethreader/Osativa.gff3 &amp;</span><br></pre></td></tr></table></figure>

<p>在定性角度上来看，同源注释的结果和从头预测的没啥差别, 其中B. rapa和A. thaliana和C. hirsuta都属于十字花科，而O. sativa是禾本科, 所以前两者预测的效果好。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-2bb888cdb1983838-84e79099d9a14a70a7e3c37ed3508c13.png" alt="IGV展示"></p>
<p>当然实际的同源注释流程中不能是单个物种分别预测，应该是将所有的蛋白序列进行合并，然后用BLASTX找到最优的联配，之后用GenomeThreader进行预测。PASA流程提到的<strong>UniRef90</strong>作为同源注释的搜索数据库可能是更好的选择，由于UniRef优先选择哪些人工审查、注释质量高、来源于模式动植物的蛋白，所以可靠性相对于直接使用同源物中可能更高。</p>
<blockquote>
<p>BLASTX + GenomeThreader的代码探索中</p>
</blockquote>
<h4 id="04-RNA-seq的两种使用策略"><a href="#04-RNA-seq的两种使用策略" class="headerlink" title="04-RNA-seq的两种使用策略"></a>04-RNA-seq的两种使用策略</h4><p>对于RNA-seq数据，有两种使用策略，一种是使用HISAT2 + StringTie先比对再组装, 一种是从头组装，然后使用PASA将转录本比对到基因组上。</p>
<h5 id="基于HISAT2-StringTie"><a href="#基于HISAT2-StringTie" class="headerlink" title="基于HISAT2 + StringTie"></a>基于HISAT2 + StringTie</h5><p>首先，使用HISAT2将RNA-seq数据比对到参考基因组, 这一步和之前相似，但是要增加一个参数<code>--dta</code>，使得StingTie能更好的利用双端信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hisat2-build 01-augustus/genome.fa index/chi_masked</span><br><span class="line">hisat2 --dta -p 20 -x index/chi_masked -1 rna-seq/leaf_ox_r1_1.fastq.gz -2 rna-seq/leaf_ox_r1_2.fastq.gz | samtools <span class="built_in">sort</span> -@ 10 &gt; rna-seq/leaf_ox_r1.bam &amp;</span><br><span class="line">hisat2 --dta -p 20 -x index/chi_masked -1 rna-seq/ox_flower9_rep1_1.fastq.gz -2 rna-seq/ox_flower9_rep1_2.fastq.gz | samtools <span class="built_in">sort</span> -@ 10 &gt; rna-seq/ox_flower9.bam &amp;</span><br><span class="line">hisat2 --dta -p 20 -x index/chi_masked -1 rna-seq/ox_flower16_rep1_1.fastq.gz -2 rna-seq/ox_flower16_rep1_2.fastq.gz | samtools <span class="built_in">sort</span> -@ 10 &gt; rna-seq/ox_flower16.bam &amp;</span><br><span class="line">samtools merge -@ 10 rna-seq/merged.bam rna-seq/leaf_ox_r1.bam rna-seq/ox_flower9.bam rna-seq/ox_flower16.bam</span><br></pre></td></tr></table></figure>

<p>然后用StringTie进行转录本预测</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stringtie -p 10 -o rna-seq/merged.gtf rna-seq/merged.bam</span><br></pre></td></tr></table></figure>

<p>对于后续的EvidenceModeler而言，它不需要UTR信息，只需要编码区CDS，需要用TransDecoder进行编码区预测</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">util/cufflinks_gtf_genome_to_cdna_fasta.pl merged.gtf input/chi_masked.fa &gt; transcripts.fasta</span><br><span class="line">util/cufflinks_gtf_to_alignment_gff3.pl merged.gtf &gt; transcripts.gff3</span><br><span class="line">TransDecoder.LongOrfs -t transcripts.fasta</span><br><span class="line">TransDecoder.Predict -t transcripts.fasta</span><br><span class="line">util/cdna_alignment_orf_to_genome_orf.pl \</span><br><span class="line">     transcripts.fasta.transdecoder.gff3 \</span><br><span class="line">     transcripts.gff3 \</span><br><span class="line">     transcripts.fasta &gt; transcripts.fasta.transdecoder.genome.gff3</span><br></pre></td></tr></table></figure>

<p>最后结果<code>transcripts.fasta.transdecoder.gff3</code>用于提供给EvidenceModeler</p>
<h5 id="基于PASA"><a href="#基于PASA" class="headerlink" title="基于PASA"></a>基于PASA</h5><p>在多年以前，那个基因组组装还没有白菜价，只有几个模式物种基因组的时代，对于一个未测序的基因组，研究者如果要研究某一个基因的功能，大多会通过同源物种相似基因设计PCR引物，然后去扩增cDNA. 如果是一个已知基因组的物种，如果要大规模识别基因, 研究者通常会使用EST(expressed sequence tags)序列。</p>
<p>相对于基于算法的从头预测，cDNA和EST序列更能够真实的反应出一个基因的真实结构，如可变剪切、UTR和Poly-A位点。PASA(Progam to Assemble Spliced Alignments)流程最早用于拟南芥基因组注释，最初的设计是通过将全长(full-length)cDNA和EST比对到参考基因组上，去发现和更新基因组注释。其中FL-cDNA和EST序列对最后结果的权重不同。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-d30be93f484be77d-28a3dcd689154b4caf797a2dcf0ea2fe.png" alt="PASA流程示意"></p>
<p>这是以前的故事，现在的故事是二代转录组以及一些三代转录组数据，那么如何处理这些数据呢？我认为三代转录组相对于过去的FL-cDNA，而二代转录组数据经过拼接后可以看作是更长的EST序列。由于目前最普及的还是普通的mRNA-seq, 也就只介绍这部分流程。</p>
<blockquote>
<p>考虑到我还没有研究过三代的全长转录组，分析过数据，这里的思考极有可能出错，后续可能会修改这一部分思考。</p>
</blockquote>
<p>转录组组装使用Trinity(conda安装)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> rna-seq</span><br><span class="line">Trinity --seqType fq --CPU 50 --max_memory 64G --left leaf_ox_r1_1.fastq.gz,ox_flower16_rep1_1.fastq.gz,ox_flower9_rep1_1.fastq.gz --right leaf_ox_r1_2.fastq.gz,ox_flower16_rep1_2.fastq.gz,ox_flower9_rep1_2.fastq.gz &amp;</span><br></pre></td></tr></table></figure>

<p>PASA是由30多个命令组成的流程，相关命令位于<code>PASApipeline/scripts</code>，为了适应不同的分析，有些参数需要通过修改配置文件更改,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> ~/opt/biosoft/PASApipeline/pasa_conf/pasa.alignAssembly.Template.txt alignAssembly.config</span><br><span class="line"><span class="comment"># 修改如下内容</span></span><br><span class="line">DATABASE=database.sqlite</span><br><span class="line">validate_alignments_in_db.dbi:--MIN_PERCENT_ALIGNED=80</span><br><span class="line">validate_alignments_in_db.dbi:--MIN_AVG_PER_ID=80</span><br></pre></td></tr></table></figure>

<p>上述几行配置文件表明SQLite3数据库的名字，设置了<code>scripts/validate_alignments_in_db.dbi</code>的几个参数, 表示联配程度和相似程度。后续以Trinity组装结果和参考基因组作为输入，运行程序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/PASApipeline/scripts/Launch_PASA_pipeline.pl -c alignAssembly.config -C -R -g ../chi_unmasked.fa -t ../rna-seq/trinity_out_dir/Trinity.fasta --ALIGNERS blat,gmap</span><br></pre></td></tr></table></figure>

<p>最后结果如下：</p>
<ul>
<li>database.sqlite.pasa_assemblies_described.txt</li>
<li>database.sqlite.pasa_assemblies.gff3</li>
<li>database.sqlite.pasa_assemblies.gtf</li>
<li>database.sqlite.pasa_assemblies.bed</li>
</ul>
<p>其中gff3格式用于后续的分析。</p>
<blockquote>
<p>目前的一些想法， 将从头组装的转录本比对到参考基因组上很大依赖组装结果，所以和EST序列和cDNA相比，质量上还有一点差距。</p>
</blockquote>
<h4 id="05-整合预测结果"><a href="#05-整合预测结果" class="headerlink" title="05-整合预测结果"></a>05-整合预测结果</h4><p>从头预测，同源注释和转录组整合都会得到一个预测结果，相当于收集了大量证据，下一步就是通过这些证据定义出更加可靠的基因结构，这一步可以通过人工排查，也可以使用EVidenceModeler(EVM). EVM只接受三类输入文件：</p>
<ul>
<li><code>gene_prediction.gff3</code>: 标准的GFF3格式，必须要有gene, mRNA, exon, CDS这些特征，用<code>EVidenceModeler-1.1.1/EvmUtils/gff3_gene_prediction_file_validator.pl</code>验证</li>
<li><code>protein_alignments.gff3</code>: 标准的GFF3格式，第9列要有ID信和和target信息, 标明是比对结果</li>
<li><code>transcript_alignments.gff3</code>:标准的GFF3格式，第9列要有ID信和和target信息，标明是比对结果</li>
</ul>
<p>EVM对<code>gene_prediction.gff3</code>有特殊的要求，就是GFF文件需要反映出一个基因的结构，gene-&gt;(mRNA -&gt; (exon-&gt;cds(?))(+))(+), 表示一个基因可以有多个mRNA，即基因的可变剪接, 一个mRNA都可以由一个或者多个exon(外显子), 外显子可以是非翻译区(UTR),也可以是编码区(CDS). 而GlimmerHMM, SNAP等</p>
<p>这三类根据人为经验来确定其可信度，从直觉上就是用PASA根据mRNA得到的结果高于从头预测。</p>
<p>第一步：创建权重文件,第一列是来源类型(ABINITIO_PREDICTION, PROTEIN, TRANSCRIPT), 第二列对应着GFF3文件的第二列，第三列则是权重.我这里用了<strong>三</strong>个来源的数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> 05-EVM &amp;&amp; <span class="built_in">cd</span> 05-EVM</span><br><span class="line"><span class="comment">#vim weights.txt</span></span><br><span class="line">ABINITIO_PREDICTION      augustus       4</span><br><span class="line">TRANSCRIPT      assembler-database.sqlite      7</span><br><span class="line">OTHER_PREDICTION  transdecoder  8</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我觉得根据基因组引导组装的ORF的可信度高于组装后比对，所以得分和PASA差不多一样高。从头预测权重一般都是1，但是BRAKER可信度稍微高一点，可以在2~5之间。</p>
</blockquote>
<p>第二步：分割原始数据, 用于后续并行. 为了降低内存消耗，–segmentsSize设置的大小需要少于1Mb(这里是100k)， –overlapSize的不能太小，如果数学好，可用设置成基因平均长度加上2个标准差，数学不好，就设置成10K吧</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> transcripts.fasta.transdecoder.genome.gff3 ../braker/carhr/augustus.hints.gff3 &gt; gene_predictions.gff3</span><br><span class="line"><span class="built_in">ln</span> ../04-align-transcript/database.sqlite.pasa_assemblies.gff3 transcript_alignments.gff3</span><br><span class="line">~/opt/biosoft/EVidenceModeler-1.1.1/EvmUtils/partition_EVM_inputs.pl --genome ../chi_unmasked.fa --gene_predictions gene_predictions.gff3 --transcript_alignments transcript_alignments.gff3 --segmentSize 100000 --overlapSize 10000 --partition_listing partitions_list.out</span><br></pre></td></tr></table></figure>

<p>第三步：创建并行运算命令并且执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/EVidenceModeler-1.1.1/EvmUtils/write_EVM_commands.pl --genome ../chi_unmasked.fa --weights `<span class="built_in">pwd</span>`/weights.txt \</span><br><span class="line">      --gene_predictions gene_predictions.gff3 \</span><br><span class="line">      --transcript_alignments transcript_alignments.gff3 \</span><br><span class="line">      --output_file_name evm.out  --partitions partitions_list.out &gt;  commands.list</span><br><span class="line">parallel --<span class="built_in">jobs</span> 10 &lt; commands.list</span><br></pre></td></tr></table></figure>

<p>第四步：合并并行结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/EVidenceModeler-1.1.1/EvmUtils/recombine_EVM_partial_outputs.pl --partitions partitions_list.out --output_file_name evm.out</span><br></pre></td></tr></table></figure>

<p>第五步：结果转换成GFF3</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/EVidenceModeler-1.1.1/EvmUtils/convert_EVM_outputs_to_GFF3.pl  --partitions partitions_list.out --output evm.out  --genome ../chi_unmasked.fa</span><br><span class="line">find . -regex <span class="string">&quot;.*evm.out.gff3&quot;</span> -<span class="built_in">exec</span> <span class="built_in">cat</span> &#123;&#125; \; | bedtools <span class="built_in">sort</span> -i - &gt; EVM.all.gff</span><br></pre></td></tr></table></figure>

<p>当前权重设置下，EVM的结果更加严格，需要按照实际情况调整，增加其他证据。</p>
<h4 id="06-可选步骤"><a href="#06-可选步骤" class="headerlink" title="06-可选步骤"></a>06-可选步骤</h4><p><strong>注释过滤</strong>：对于初步预测得到的基因，还可以稍微优化一下，例如剔除编码少于50个AA的预测结果，将转座子单独放到一个文件中(软件有TransposonPSI)。</p>
<p>这里基于<code>gffread</code>先根据注释信息提取所有的CDS序列，过滤出长度不足50AA的序列，基于这些序列过滤原来的的注释</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gffread EVM.all.gff -g input/genome.fa -y tr_cds.fa</span><br><span class="line">bioawk -c fastx <span class="string">&#x27;$seq &lt; 50 &#123;print $comment&#125;&#x27;</span> tr_cds.fa | <span class="built_in">cut</span> -d <span class="string">&#x27;=&#x27;</span> -f 2 &gt; short_aa_gene_list.txt</span><br><span class="line">grep -v -w -f short_aa_gene_list.txt EvM.all.gff &gt; filter.gff</span><br></pre></td></tr></table></figure>

<p><strong>使用PASA更新EVM结果</strong>：EVM结果不包括UTR区域和可变剪切的注释信息，可以使用PASA进行更新。然而这部分已经无法逃避MySQL, 服务器上并没有MySQL的权限，我需要学习Perl脚本进行修改。因此基因结构注释到此先放一放。</p>
<h4 id="07-基因编号"><a href="#07-基因编号" class="headerlink" title="07-基因编号"></a>07-基因编号</h4><p>对每个基因实现编号，形如ABCD000010的效果，方便后续分析。如下代码是基于EVM.all.gff，使用方法为<code>python gffrename.py EVM_output.gff prefix &gt; renamed.gff</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env python3</span></span><br><span class="line">import re</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &lt; 3:</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line">gff = open(sys.argv[1])</span><br><span class="line">prf = sys.argv[2]</span><br><span class="line"></span><br><span class="line">count = 0</span><br><span class="line">mRNA  = 0</span><br><span class="line">cds   = 0</span><br><span class="line">exon  = 0</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;##gff-version 3.2.1&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> gff:</span><br><span class="line">    <span class="keyword">if</span> not line.startswith(<span class="string">&quot;\n&quot;</span>):</span><br><span class="line">        records = line.split(<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">        records[1] = <span class="string">&quot;.&quot;</span></span><br><span class="line">    <span class="keyword">if</span> re.search(r<span class="string">&quot;\tgene\t&quot;</span>, line):</span><br><span class="line">        count = count + 10</span><br><span class="line">        mRNA  = 0</span><br><span class="line">        gene_id = prf + str(count).zfill(6)</span><br><span class="line">        records[8] = <span class="string">&quot;ID=&#123;&#125;&quot;</span>.format(gene_id)</span><br><span class="line">    <span class="keyword">elif</span> re.search(r<span class="string">&quot;\tmRNA\t&quot;</span>, line):</span><br><span class="line">        cds   = 0</span><br><span class="line">        exon  = 0</span><br><span class="line">        mRNA  = mRNA + 1</span><br><span class="line">        mRNA_id    = gene_id + <span class="string">&quot;.&quot;</span> + str(mRNA)</span><br><span class="line">        records[8] = <span class="string">&quot;ID=&#123;&#125;;Parent=&#123;&#125;&quot;</span>.format(mRNA_id, gene_id)</span><br><span class="line">    <span class="keyword">elif</span> re.search(r<span class="string">&quot;\texon\t&quot;</span>, line):</span><br><span class="line">        exon     = exon + 1</span><br><span class="line">        exon_id  = mRNA_id + <span class="string">&quot;_exon_&quot;</span> + str(exon)</span><br><span class="line">        records[8] = <span class="string">&quot;ID=&#123;&#125;;Parent=&#123;&#125;&quot;</span>.format(exon_id, mRNA_id)</span><br><span class="line">    <span class="keyword">elif</span> re.search(r<span class="string">&quot;\tCDS\t&quot;</span>, line):</span><br><span class="line">        cds     = cds + 1</span><br><span class="line">        cds_id  = mRNA_id + <span class="string">&quot;_cds_&quot;</span> + str(cds)</span><br><span class="line">        records[8] = <span class="string">&quot;ID=&#123;&#125;;Parent=&#123;&#125;&quot;</span>.format(cds_id, mRNA_id)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\t&quot;</span>.<span class="built_in">join</span>(records))</span><br><span class="line"></span><br><span class="line">gff.close()</span><br></pre></td></tr></table></figure>

<h4 id="一些经验"><a href="#一些经验" class="headerlink" title="一些经验"></a>一些经验</h4><p>如果有转录组数据，没必须要使用太多的从头预测工具，braker2 加 GlimmerHMM可能就够用了, 更多是使用PASA和StringTie利用好转录组数据进行注释。</p>
<h3 id="基因功能注释"><a href="#基因功能注释" class="headerlink" title="基因功能注释"></a>基因功能注释</h3><p>基因功能的注释依赖于上一步的基因结构预测，根据预测结果从基因组上提取翻译后的 <strong>蛋白序列</strong> 和主流的数据库进行比对，完成功能注释。常用数据库一共有以几种：</p>
<ul>
<li>Nr：NCBI官方非冗余蛋白数据库，包括PDB, Swiss-Prot, PIR, PRF; 如果要用DNA序列，就是nt库</li>
<li>Pfam: 蛋白结构域注释的分类系统</li>
<li>Swiss-Prot: 高质量的蛋白数据库，蛋白序列得到实验的验证</li>
<li>KEGG: 代谢通路注释数据库.</li>
<li>GO: 基因本体论注释数据库</li>
</ul>
<p>除了以上几个比较通用的数据库外，其实还有很多小众数据库，应该根据课题研究和背景进行选择。<strong>注意</strong>，数据库本身并不能进行注释，你只是通过序列相似性进行搜索，而返回的结果你称之为注释。因此数据库和搜索工具要进行区分，所以你需要单独下载数据库和搜索工具，或者是同时下载包含数据库和搜索工具的安装包。</p>
<blockquote>
<p>注意，后续分析中一定要保证你的蛋白序列中不能有代表氨基酸字符以外的字符，比如说有些软件会把最后一个终止密码子翻译成”.”或者”*“</p>
</blockquote>
<h4 id="BLASTP"><a href="#BLASTP" class="headerlink" title="BLASTP"></a>BLASTP</h4><p>这一部分用到的数据库都是用BLASTP进行检索，基本都是四步发：下载数据库，构建BLASTP索引，数据库检索，结果整理。其中结果整理需要根据BLASTP的输出格式调整。</p>
<p><a href="ftp://ftp.ncbi.nlm.nih.gov/blast/db/">Nr</a>的NCBI收集的最全的蛋白序列数据库，但是无论是用NCBI的BLAST还是用速度比较快DIAMOND对nr进行搜索，其实都没有利用好物种本身的信息。因此在RefSeq上下载对应物种的蛋白序列, 用BLASTP进行注释即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># download</span></span><br><span class="line">wget -4  -nd -np -r 1 -A *.faa.gz ftp://ftp.ncbi.nlm.nih.gov/refseq/release/plant/</span><br><span class="line"><span class="built_in">mkdir</span> -p ~/db/RefSeq</span><br><span class="line">zcat *.gz &gt; ~/db/RefSeq/plant.protein.faa</span><br><span class="line"><span class="comment"># build index</span></span><br><span class="line">~/opt/biosoft/ncbi-blast-2.7.1+/bin/makeblastdb -<span class="keyword">in</span> plant.protein.faa -dbtype prot -parse_seqids -title RefSeq_plant -out plant</span><br><span class="line"><span class="comment"># search</span></span><br><span class="line">~/opt/biosoft/ncbi-blast-2.7.1+/bin/blastp -query protein.fa -out RefSeq_plant_blastp.xml -db ~/db/RefSeq/uniprot_sprot.fasta -evalue 1e-5 -outfmt 5 -num_threads 50 &amp;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://www.uniprot.org/downloads">Swiss-Prot</a>里收集了目前可信度最高的蛋白序列，一共有55w条记录，数据量比较小，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># download</span></span><br><span class="line">wget -4 -q ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/uniprot_sprot.fasta.gz</span><br><span class="line">gzip -d uniprot_sprot.fasta.gz</span><br><span class="line"><span class="comment"># builid index</span></span><br><span class="line">~/opt/biosoft/ncbi-blast-2.7.1+/bin/makeblastdb -<span class="keyword">in</span> uniprot_sprot.fasta -dbtype prot -title swiss_prot -parse_seqids</span><br><span class="line"><span class="comment"># search</span></span><br><span class="line">~/opt/biosoft/ncbi-blast-2.7.1+/bin/blastp -query protein.fa -out swiss_prot.xml -db ~/db/swiss_prot/uniprot_sprot.fasta -evalue 1e-5 -outfmt 5 -num_threads 50 &amp;</span><br></pre></td></tr></table></figure>

<p>关于结果整理，已经有很多人写了脚本，比如说我搜索BLAST XML CSV，就找到了<a target="_blank" rel="noopener" href="https://github.com/Sunhh/NGS_data_processing/blob/master/annot_tools/blast_xml_parse.py">https://github.com/Sunhh/NGS_data_processing/blob/master/annot_tools/blast_xml_parse.py</a>, 所以就不过多介绍。</p>
<h4 id="InterProScan"><a href="#InterProScan" class="headerlink" title="InterProScan"></a>InterProScan</h4><p>下面介绍的工具是<a target="_blank" rel="noopener" href="https://www.ebi.ac.uk/interpro/interproscan.html">InterProScan</a>, 从它的9G的体量就可以感受它的强大之处，一次运行同时实现多个信息注释。</p>
<ul>
<li>InterPro注释</li>
<li>Pfam数据库注释(可以通过hmmscan搜索pfam数据库完成)</li>
<li>GO注释(可以基于NR和Pfam等数据库，然后BLAST2GO完成,)</li>
<li>Reactome通路注释，不同于KEGG</li>
</ul>
<p>命令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./interproscan-5.29-68.0/interproscan.sh -appl Pfam  -f TSV -i sample.fa -cpu 50 -b sample -goterms -iprlookup -pa</span><br></pre></td></tr></table></figure>

<p><code>-appl</code>告诉软件要执行哪些数据分析，勾选的越多，分析速度越慢，Pfam就行。</p>
<h4 id="KEGG"><a href="#KEGG" class="headerlink" title="KEGG"></a>KEGG</h4><p><strong>KEGG数据库</strong>目前本地版收费，在线版收费，所以只能将蛋白序列在KEGG服务器上运行。因此你需要在<a target="_blank" rel="noopener" href="http://www.genome.jp/tools/kaas/">http://www.genome.jp/tools/kaas/</a>选择合适的工具进行后续的分析。我上传的50M大小蛋白序列，在KEGG服务器上只需要运行8个小时，也就是晚上提交任务，白天回来干活。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-e86990227c77f511-03651bbbee1b4847a35bb983407dedfc.png" alt="运行时间"></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>基因组注释的常用软件：</p>
<ul>
<li>重复区域<ul>
<li>RepeatMasker：识别基因组中的可能重复</li>
<li>RepeatModeler: 识别新的重复序列</li>
<li>LTR-FINDER: <a target="_blank" rel="noopener" href="http://tlife.fudan.edu.cn/ltr_finder/">http://tlife.fudan.edu.cn/ltr_finder/</a></li>
</ul>
</li>
<li>从头预测<ul>
<li>Augustus</li>
<li>Fgenesh</li>
</ul>
</li>
<li>同源预测<ul>
<li>GeneWise</li>
<li>Exonerate</li>
<li>Trinity</li>
<li>GenomeThreader</li>
</ul>
</li>
<li>注释合并<ul>
<li>GLEAN：已经落伍于时代了</li>
<li>EvidenceModeler： 与时俱进</li>
</ul>
</li>
<li>流程<ul>
<li>PASA：真核生物基因的转录本可变剪切自动化注释项目，需要提供物种的EST或RNA-seq数据</li>
<li>MAKER</li>
<li>BRAKER1: 使用GeneMark-ET和AUGUSTUS基于RNA-Seq注释基因结构</li>
<li>EuGene</li>
</ul>
</li>
<li>可视化<ul>
<li>IGV</li>
<li>JBrowse&#x2F;GBrowse</li>
</ul>
</li>
</ul>
<p>参考文献和推荐阅读：</p>
<ul>
<li>NCBI真核生物基因组注释流程<a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/genome/annotation_euk/process/">https://www.ncbi.nlm.nih.gov/genome/annotation_euk/process/</a></li>
<li>真核基因组注释入门: “A beginner’s guide to eukaryotic genome annotation”</li>
<li>二代测序注释流程:Comparative Gene Finding: “Annotation Pipelines for Next-Generation Sequencing Projects”</li>
<li>基因组转录组注释策略: “Plant genome and transcriptome annotations: from misconceptions to simple solution”</li>
<li>重复序列综述: “Repetitive DNA and next-generation sequencing: computational challenges and solutions”</li>
<li>MAKER2教程: <a target="_blank" rel="noopener" href="http://weatherby.genetics.utah.edu/MAKER/wiki/index.php/MAKER_Tutorial_for_WGS_Assembly_and_Annotation_Winter_School_2018">http://weatherby.genetics.utah.edu/MAKER/wiki/index.php/MAKER_Tutorial_for_WGS_Assembly_and_Annotation_Winter_School_2018</a></li>
<li>《生物信息学》 樊龙江: 第1-5章: 基因预测与功能注释</li>
<li>《NGS生物信息分析》 陈连福： 真核生物基因组基因注释</li>
<li>JGS流程: <a target="_blank" rel="noopener" href="https://genome.jgi.doe.gov/programs/fungi/FungalGenomeAnnotationSOP.pdf">https://genome.jgi.doe.gov/programs/fungi/FungalGenomeAnnotationSOP.pdf</a></li>
</ul>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cardamine hirsutat基因组数据</span></span><br><span class="line"><span class="built_in">mkdir</span> chi_annotation &amp;&amp; <span class="built_in">cd</span> chi_annotation</span><br><span class="line">wget http://chi.mpipz.mpg.de/download/sequences/chi_v1.fa</span><br><span class="line"><span class="built_in">cat</span> chi_v1.fa | <span class="built_in">tr</span> <span class="string">&#x27;atcg&#x27;</span> <span class="string">&#x27;ATCG&#x27;</span> &gt; chi_unmasked.fa</span><br><span class="line"><span class="comment"># Cardamine hirsutat转录组数据</span></span><br><span class="line">wget -4 -q -A <span class="string">&#x27;*.fastq.gz&#x27;</span> -np -nd -r 2 http://chi.mpipz.mpg.de/download/fruit_rnaseq/cardamine_hirsuta/ &amp;</span><br><span class="line">wget -4 -q -A <span class="string">&#x27;*.fastq.gz&#x27;</span> -np -nd -r 2 http://chi.mpipz.mpg.de/download/leaf_rnaseq/cardamine_hirsuta/ &amp;</span><br></pre></td></tr></table></figure>

<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p><strong>RepeatMasker</strong>: 用于注释基因组的重复区，需要安装RMBlast, TRF，以及在<a target="_blank" rel="noopener" href="http://www.girinst.org/">http://www.girinst.org</a>注册以下载Repbase</p>
<p>安装RepeatMasker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/src</span><br><span class="line">wget http://tandem.bu.edu/trf/downloadstrf409.linux64</span><br><span class="line"><span class="built_in">mv</span> trf409.linux64 ~/opt/bin/trf</span><br><span class="line"><span class="built_in">chmod</span> a+x ~/opt/bin/trf</span><br><span class="line"><span class="comment"># RMBlast</span></span><br><span class="line"><span class="built_in">cd</span> ~/src</span><br><span class="line">wget ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/2.6.0/ncbi-blast-2.6.0+-src.tar.gz</span><br><span class="line">wget http://www.repeatmasker.org/isb-2.6.0+-changes-vers2.patch.gz</span><br><span class="line">tar xf ncbi-blast-2.6.0+-src</span><br><span class="line">gunzip isb-2.6.0+-changes-vers2.patch.gz</span><br><span class="line"><span class="built_in">cd</span> ncbi-blast-2.6.0+-src</span><br><span class="line">patch -p1 &lt; ../isb-2.6.0+-changes-vers2.patch</span><br><span class="line"><span class="built_in">cd</span> c++</span><br><span class="line">./configure --with-mt --prefix=~/opt/biosoft/rmblast --without-debug &amp;&amp; make &amp;&amp; make install</span><br><span class="line"><span class="comment"># RepeatMasker</span></span><br><span class="line"><span class="built_in">cd</span> ~/src</span><br><span class="line">wget http://repeatmasker.org/RepeatMasker-open-4-0-7.tar.gz</span><br><span class="line">tar xf RepeatMasker-open-4-0-7.tar.gz</span><br><span class="line"><span class="built_in">mv</span> RepeatMasker ~/opt/biosoft/</span><br><span class="line"><span class="built_in">cd</span> ~/opt/biosoft/RepeatMasker</span><br><span class="line"><span class="comment">## 解压repbase数据到Libraries下</span></span><br><span class="line"><span class="comment">## 配置RepatMasker</span></span><br><span class="line">perl ./configure</span><br></pre></td></tr></table></figure>

<p>在上面的基础上安装<strong>RepeatModel</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RECON</span></span><br><span class="line"><span class="built_in">cd</span> ~/src</span><br><span class="line">wget -4 http://repeatmasker.org/RepeatModeler/RECON-1.08.tar.gz</span><br><span class="line">tar xf RECON-1.08.tar.gz</span><br><span class="line"><span class="built_in">cd</span> RECON-1.08/src</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="built_in">cd</span> ~/src</span><br><span class="line"><span class="built_in">mv</span> RECON-1.08 ~/opt/biosoft</span><br><span class="line"><span class="comment"># nesg</span></span><br><span class="line"><span class="built_in">cd</span> ~/src</span><br><span class="line"><span class="built_in">mkdir</span> nesg &amp;&amp; <span class="built_in">cd</span> nesg</span><br><span class="line">wget -4 ftp://ftp.ncbi.nih.gov/pub/seg/nseg/*</span><br><span class="line">make</span><br><span class="line"><span class="built_in">mv</span> nmerge nseg ~/opt/bin/</span><br><span class="line"><span class="comment"># RepeatScout</span></span><br><span class="line">http://www.repeatmasker.org/RepeatScout-1.0.5.tar.gz</span><br><span class="line"><span class="comment"># RepeatModel</span></span><br><span class="line">wget -4 http://repeatmasker.org/RepeatModeler/RepeatModeler-open-1.0.11.tar.gz</span><br><span class="line">tar xf RepeatModeler-open-1.0.11.tar.gz</span><br><span class="line"><span class="built_in">mv</span> RepeatModeler-open-1.0.11 ~/opt/biosoft/</span><br><span class="line"><span class="built_in">cd</span> ~/opt/biosoft/RepeatModeler-open-1.0.11</span><br><span class="line"><span class="comment"># 配置</span></span><br><span class="line">perl ./configure</span><br><span class="line"><span class="built_in">export</span> PATH=~/opt/biosoft/maker:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p><strong>BLAST</strong>，BLAST有两个版本可供选择, WuBLAST或者NCBI-BLAST，我个人倾向于NCBI-BLAST，并且推荐使用编译后二进制版本，因为编译实在是太花时间了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/src</span><br><span class="line">wget ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/ncbi-blast-2.7.1+-x64-linux.tar.gz</span><br><span class="line">tar xf ncbi-blast-2.7.1+-x64-linux.tar.gz -C ~/opt/biosoft</span><br><span class="line"><span class="comment"># 环境变量</span></span><br><span class="line"><span class="built_in">export</span> PATH=~/opt/biosoft/ncbi-blast-2.7.1+/bin:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 用于后续的BRAKER2</span></span><br><span class="line">conda create -n annotation blast=2.2.31</span><br></pre></td></tr></table></figure>

<p><strong>AUGUSTUS</strong>: 可以说是最好的预测软件，使用conda安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> activate annotation</span><br><span class="line">conda install augustus=3.3</span><br></pre></td></tr></table></figure>

<p><strong>GeneMark-ES&#x2F;ET</strong>则是唯一一款支持无监督训练模型, 软件下载需要登记</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/src</span><br><span class="line">wget http://topaz.gatech.edu/GeneMark/tmp/GMtool_Qg87n/gm_et_linux_64.tar.gz</span><br><span class="line">tar xf gm_et_linux_64.tar.gz</span><br><span class="line"><span class="built_in">mv</span> gm_et_linux_64/gmes_petap/ ~/opt/biosoft</span><br><span class="line">wget http://topaz.gatech.edu/GeneMark/tmp/GMtool_Qg87n/gm_key_64.gz</span><br><span class="line">gzip -dc gm_key_64.gz &gt; ~/.gm_key</span><br><span class="line">cpan YAML Hash::Merge Logger::Simple Parallel::ForkManager</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=<span class="variable">$PATH</span>:~/opt/biosoft/gmes_petap/&quot;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>

<p><strong>GlimmerHMM</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/src</span><br><span class="line">wget -4 ftp://ccb.jhu.edu/pub/software/glimmerhmm/GlimmerHMM-3.0.4.tar.gz</span><br><span class="line">tar xf GlimmerHMM-3.0.4.tar.gz -C ~/opt/biosoft</span><br></pre></td></tr></table></figure>

<p><strong>SNAP</strong>: 基因从头预测工具，在处理含有长内含子上的基因组上表现欠佳</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line"><span class="built_in">cd</span> ~/src</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/KorfLab/SNAP.git</span><br><span class="line"><span class="built_in">cd</span> SNP</span><br><span class="line">make</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">mv</span> SNAP ~/opt/biosoft</span><br><span class="line"><span class="comment"># 环境变量</span></span><br><span class="line"><span class="built_in">export</span> Zoe=~/opt/biosoft/SNAP/Zoe</span><br><span class="line"><span class="built_in">export</span> PATH=~/opt/biosoft/SNAP:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<p><strong>Exnerate 2.2</strong>: 配对序列比对工具，提供二进制版本, 功能类似于GeneWise，能够将cDNA或蛋白以gao align的方式和基因组序列联配。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/src</span><br><span class="line">wget http://ftp.ebi.ac.uk/pub/software/vertebrategenomics/exonerate/exonerate-2.2.0-x86_64.tar.gz</span><br><span class="line">tar xf exonerate-2.2.0-x86_64.tar.gz</span><br><span class="line"><span class="built_in">mv</span> exonerate-2.2.0-x86_64 ~/opt/biosoft/exonerate-2.2.0</span><br><span class="line"><span class="comment"># .bashrc添加环境变量</span></span><br><span class="line"><span class="built_in">export</span> PATH=~/opt/biosoft/exonerate-2.2.0:<span class="variable">$PATH</span></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">conda install -c bioconda exonerate</span><br></pre></td></tr></table></figure>

<p><strong>GenomeThreader 1.70</strong>: 同源预测软件，1.7.0版本更新于2018年2月</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget -4 http://genomethreader.org/distributions/gth-1.7.0-Linux_x86_64-64bit.tar.gz</span><br><span class="line">tar xf gth-1.7.0-Linux_x86_64-64bit.tar.gz -C ~/opt/biosoft</span><br><span class="line"><span class="comment"># 修改.bashrc增加如下行</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/opt/biosoft/gth-1.7.0-Linux_x86_64-64bit/bin</span><br><span class="line"><span class="built_in">export</span> BSSMDIR=<span class="string">&quot;<span class="variable">$HOME</span>/opt/biosoft/gth-1.7.0-Linux_x86_64-64bit/bin/bssm&quot;</span></span><br><span class="line"><span class="built_in">export</span> GTHATADIR=<span class="string">&quot;<span class="variable">$HOME</span>/opt/biosoft/gth-1.7.0-Linux_x86_64-64bit/bin/gthdata&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>BRAKER2</strong>: 依赖AUGUSTUS 3.3, GeneMark-EX 4.33, BAMTOOLS 2.5.1, NCBI BLAST+ 2.2.31+(可选 SAMTOOLS 1.74+, GenomeThreader 1.70)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cpan File::Spec::Functions Module::Load::Conditional POSIX Scalar::Util::Numeric YAML File::Which Logger::Simple Parallel::ForkManager</span><br><span class="line"><span class="built_in">cd</span> ~/src</span><br><span class="line">wget -4 http://exon.biology.gatech.edu/GeneMark/Braker/BRAKER2.tar.gz</span><br><span class="line">tar xf BRAKER2.tar.gz -C ~/opt/biosoft</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=<span class="variable">$PATH</span>:<span class="variable">$HOME</span>/opt/biosoft/BRAKER_v2.1.0/&quot;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="comment"># 在~/.bashrc设置如下软件所在环境变量</span></span><br><span class="line"><span class="built_in">export</span> AUGUSTUS_CONFIG_PATH=<span class="variable">$HOME</span>/miniconda3/envs/annotation/config/</span><br><span class="line"><span class="built_in">export</span> AUGUSTUS_SCRIPTS_PATH=<span class="variable">$HOME</span>/miniconda3/envs/annotation/bin/</span><br><span class="line"><span class="built_in">export</span> BAMTOOLS_PATH=<span class="variable">$HOME</span>/miniconda3/envs/annotation/bin/</span><br><span class="line"><span class="built_in">export</span> GENEMARK_PATH=<span class="variable">$HOME</span>/opt/biosoft/gmes_petap/</span><br><span class="line"><span class="built_in">export</span> SAMTOOLS_PATH=<span class="variable">$HOME</span>/miniconda3/envs/annotation/bin/</span><br><span class="line"><span class="built_in">export</span> ALIGNMENT_TOOL_PATH=<span class="variable">$HOME</span>/opt/biosoft/gth-1.7.0-Linux_x86_64-64bit/bin/</span><br></pre></td></tr></table></figure>

<p><strong>TransDecoder</strong> 编码区域预测工具，需要预先安装NCBI-BLAST</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cpan URI::Escape</span><br><span class="line"><span class="built_in">cd</span> ~/src</span><br><span class="line">wget -4 https://github.com/TransDecoder/TransDecoder/archive/TransDecoder-v5.3.0.zip</span><br><span class="line">unzip TransDecoder-v5.3.0.zip</span><br><span class="line"><span class="built_in">cd</span> TransDecoder-v5.3.0</span><br><span class="line">make <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p><strong>MARKER</strong>: 使用conda安装会特别的方便，最好新建环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n marker marker</span><br></pre></td></tr></table></figure>

<p><strong>PASA</strong>: 依赖于一个数据库(MySQL或SQLite), Perl模块(DBD::mysql或DBD::SQLite), GMAP, BLAT, Fasta3。由于MySQL在HPC集群中的表现不如SQLite，以及安装MySQL还需要各种管理员权限，于是就有人进行了修改，增加了feature&#x2F;sqlite分支, 见<a target="_blank" rel="noopener" href="https://github.com/PASApipeline/PASApipeline/pull/43">Add support for SQLite</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cpan DB_File URI::Escape DBI DBD::SQLite</span><br><span class="line"><span class="comment"># GMAP</span></span><br><span class="line">wget http://research-pub.gene.com/gmap/src/gmap-gsnap-2017-11-15.tar.gz</span><br><span class="line">tar xf gmap-gsnap-2017-11-15.tar.gz</span><br><span class="line"><span class="built_in">cd</span> gmap-2017-11-15</span><br><span class="line">./configure --prefix=<span class="variable">$HOME</span>/opt/gmap</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="comment"># BLAT</span></span><br><span class="line"><span class="built_in">cd</span> ~/opt/bin</span><br><span class="line">wget http://hgdownload.soe.ucsc.edu/admin/exe/linux.x86_64/blat/blat &amp;&amp; <span class="built_in">chmod</span> 755 ./blat</span><br><span class="line"><span class="comment"># Fasta3</span></span><br><span class="line">wget -4 http://faculty.virginia.edu/wrpearson/fasta/fasta36/fasta-36.3.8g.tar.gz &amp;&amp; \</span><br><span class="line">        tar zxvf fasta-36.3.8g.tar.gz &amp;&amp; \</span><br><span class="line">        <span class="built_in">cd</span> ./fasta-36.3.8g/src &amp;&amp; \</span><br><span class="line">        make -f ../make/Makefile.linux_sse2 all &amp;&amp; \</span><br><span class="line">        <span class="built_in">cp</span> ../bin/fasta36 ~/opt/bin</span><br><span class="line"><span class="comment"># 以上程序需添加到环境变量中</span></span><br><span class="line"><span class="comment"># PASApipeline</span></span><br><span class="line"><span class="built_in">cd</span> ~/opt/biosoft</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/PASApipeline/PASApipeline.git</span><br><span class="line"><span class="built_in">cd</span> PASApipeline &amp;&amp; \</span><br><span class="line">git checkout feature/sqlite &amp;&amp; \</span><br><span class="line">git submodule init &amp;&amp; git submodule update &amp;&amp; \</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p><strong>EVidenceModeler</strong>: 整合不同来源的注释结果，找到可靠的基因结构</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/src</span><br><span class="line">wget -4 https://github.com/EVidenceModeler/EVidenceModeler/archive/v1.1.1.tar.gz</span><br><span class="line">tar xf v1.1.1.tar.gz</span><br><span class="line"><span class="built_in">mv</span> EVidenceModeler-1.1.1 ~/opt/biosoft/</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/10/11/%E5%A6%82%E4%BD%95%E5%AF%B9%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%BA%8F%E5%88%97%E8%BF%9B%E8%A1%8C%E6%B3%A8%E9%87%8A-How-to-annotate-your-genome/" data-id="clm1xkn6v0072dpni0eweemf6" data-title="如何对基因组序列进行注释" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" rel="tag">注释 | 重复序列</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-如何展示MUMMER的结果-Visualization-of-MUMMER-Result" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/10/%E5%A6%82%E4%BD%95%E5%B1%95%E7%A4%BAMUMMER%E7%9A%84%E7%BB%93%E6%9E%9C-Visualization-of-MUMMER-Result/" class="article-date">
  <time class="dt-published" datetime="2019-10-10T23:06:10.385Z" itemprop="datePublished">2019-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/R/">R</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/10/%E5%A6%82%E4%BD%95%E5%B1%95%E7%A4%BAMUMMER%E7%9A%84%E7%BB%93%E6%9E%9C-Visualization-of-MUMMER-Result/">如何展示MUMMER的结果</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在2年之前我写过一篇教程介绍MUMmer软件的使用方法，可以通过<a href="/archives/Using-MUMmer-to-align-genome">如何使用MUMmer比对大片段序列</a>阅读。</p>
<p>MUMmer作为一个比对工具，它的主要功能就是寻找两个序列的相似之处，至于如何展示结果，并不是它的主要目标。这篇文章将会介绍如何基于MUMMER的输出结果进行可视化。</p>
<p>首先是下载数据，我们用细菌的基因组作为案例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://mummer.sourceforge.net/examples/data/H_pylori26695_Eslice.fasta</span><br><span class="line">wget http://mummer.sourceforge.net/examples/data/H_pyloriJ99_Eslice.fasta</span><br></pre></td></tr></table></figure>

<p>然后使用<code>nucmer</code>进行比对</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nucmer H_pylori26695_Eslice.fasta H_pyloriJ99_Eslice.fasta</span><br></pre></td></tr></table></figure>

<p>只保留1对1的最佳联配</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delta-filter -1 out.delta &gt; filter.delta</span><br></pre></td></tr></table></figure>

<p>输出容易展示的信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show-coords -T -q -H filter.delta &gt; coord.txt</span><br></pre></td></tr></table></figure>

<p>上面这几个程序的参数需要根据具体需求进行修改，并不是固定用法</p>
<p>后续就是在R语言里面继续绘图。 先加载数据并根据数据格式命名列</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df <span class="operator">&lt;-</span> read.table<span class="punctuation">(</span><span class="string">&quot;~/coord.txt&quot;</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;\t&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">colnames<span class="punctuation">(</span>df<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;ref_start&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ref_end&quot;</span><span class="punctuation">,</span> <span class="string">&quot;qry_start&quot;</span><span class="punctuation">,</span> <span class="string">&quot;qry_end&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ref_len&quot;</span><span class="punctuation">,</span> <span class="string">&quot;qry_len&quot;</span><span class="punctuation">,</span> </span><br><span class="line">                  <span class="string">&quot;identiy&quot;</span><span class="punctuation">,</span> <span class="string">&quot;ref_tag&quot;</span><span class="punctuation">,</span><span class="string">&quot;qry_tag&quot;</span> <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>获取x和y轴的范围</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_range <span class="operator">&lt;-</span> <span class="built_in">range</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>df<span class="operator">$</span>ref_start<span class="punctuation">,</span> df<span class="operator">$</span>ref_end<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">y_range <span class="operator">&lt;-</span> <span class="built_in">range</span><span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span>df<span class="operator">$</span>qry_start<span class="punctuation">,</span> df<span class="operator">$</span>qry_end<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>新建一个画图设备，并设置好画图区域</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">plot.new<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">plot.window<span class="punctuation">(</span>xlim <span class="operator">=</span> x_range<span class="punctuation">,</span></span><br><span class="line">            ylim <span class="operator">=</span> y_range<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>之后逐行绘制每个联配结果，用不同的颜色来展示倒置的情况</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span><span class="punctuation">(</span> i <span class="keyword">in</span> <span class="number">1</span><span class="operator">:</span>nrow<span class="punctuation">(</span>df<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> <span class="punctuation">(</span>df<span class="punctuation">[</span>i<span class="punctuation">,</span><span class="number">3</span><span class="punctuation">]</span> <span class="operator">&lt;</span> df<span class="punctuation">[</span>i<span class="punctuation">,</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">    lines<span class="punctuation">(</span>x <span class="operator">=</span> df<span class="punctuation">[</span>i<span class="punctuation">,</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> y <span class="operator">=</span> df<span class="punctuation">[</span>i<span class="punctuation">,</span><span class="number">3</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;red&quot;</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">&#125;</span> <span class="keyword">else</span><span class="punctuation">&#123;</span></span><br><span class="line">    lines<span class="punctuation">(</span>x <span class="operator">=</span> df<span class="punctuation">[</span>i<span class="punctuation">,</span><span class="number">1</span><span class="operator">:</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> y <span class="operator">=</span> df<span class="punctuation">[</span>i<span class="punctuation">,</span><span class="number">3</span><span class="operator">:</span><span class="number">4</span><span class="punctuation">]</span><span class="punctuation">,</span> col <span class="operator">=</span> <span class="string">&quot;blue&quot;</span><span class="punctuation">)</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>最后加上x轴和y轴的标签</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">box<span class="punctuation">(</span><span class="punctuation">)</span></span><br><span class="line">axis<span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> at <span class="operator">=</span> seq<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> x_range<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="number">10000</span><span class="punctuation">)</span><span class="punctuation">,</span> labels <span class="operator">=</span> seq<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> x_range<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="number">10000</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">10000</span><span class="punctuation">)</span></span><br><span class="line">axis<span class="punctuation">(</span><span class="number">2</span><span class="punctuation">,</span> at <span class="operator">=</span> seq<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> y_range<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="number">10000</span><span class="punctuation">)</span><span class="punctuation">,</span> labels <span class="operator">=</span> seq<span class="punctuation">(</span><span class="number">0</span><span class="punctuation">,</span> y_range<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="number">10000</span><span class="punctuation">)</span> <span class="operator">/</span> <span class="number">10000</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/image-eb79ee30ae09459cbe519524a1d63c46.png" alt="最终结果"></p>
<p>上面这种作图方式就是R语言的基础作图模式，从绘图思想上叫做画笔模式，这区别于ggplot2所代表的图形语法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/10/10/%E5%A6%82%E4%BD%95%E5%B1%95%E7%A4%BAMUMMER%E7%9A%84%E7%BB%93%E6%9E%9C-Visualization-of-MUMMER-Result/" data-id="clm1xkn6w0074dpni7f2kh76w" data-title="如何展示MUMMER的结果" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="tag">可视化</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-使用BRAKER2进行基因组注释-genome-annotation-with-braker2" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/10/%E4%BD%BF%E7%94%A8BRAKER2%E8%BF%9B%E8%A1%8C%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%B3%A8%E9%87%8A-genome-annotation-with-braker2/" class="article-date">
  <time class="dt-published" datetime="2019-10-10T18:57:19.681Z" itemprop="datePublished">2019-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/10/%E4%BD%BF%E7%94%A8BRAKER2%E8%BF%9B%E8%A1%8C%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%B3%A8%E9%87%8A-genome-annotation-with-braker2/">使用BRAKER2进行基因组注释</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="使用BRAKER2进行基因组注释"><a href="#使用BRAKER2进行基因组注释" class="headerlink" title="使用BRAKER2进行基因组注释"></a>使用BRAKER2进行基因组注释</h1><p>BRAKER2是一个基因组注释流程，能够组合GeneMark，AUGUSTUS和转录组数据。</p>
<p>在使用软件之前，有几点需要注意下</p>
<ul>
<li>尽量提供高质量的基因组。目前随着三代测序价格下降，这一点问题不大。</li>
<li>基因组命名应该简单，最好就是”&gt;contig1”或”&gt;tig000001”</li>
<li>基因组需要屏蔽重复序列</li>
<li>默认参数通常表现效果就很好，但是也要根据物种来</li>
<li>一定要对注释结果进行检查，别直接使用</li>
</ul>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>BRAKER的依赖软件不少，且Perl需要安装的模块也很多，但是我们可以直接用bioconda进行安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n braker2 braker2</span><br></pre></td></tr></table></figure>

<p>使用conda安装结束后会有一些提示语，总结如下</p>
<ul>
<li>保证AUGUSTUS的config目录能够有可写权限（自己用conda安装不需要考虑这个问题）</li>
<li>GeneMark&#x2F;GenomeThreader&#x2F;ProtHint需要额外下载安装</li>
</ul>
<blockquote>
<p>尽管可以使用容器化技术，但是由于软件运行时需要对AUGUSTUS里的配置文件进行读写，需要额外设置，因此不在此介绍</p>
</blockquote>
<p>由于部分软件的版权限制，也就是GeneMakr, GenomeThreader, ProHint，我们还需要手动安装这些软件。但其中只有GeneMark是必须的，因为我们更多是利用RNA-seq数据进行模型训练，而GenomeThreader, ProHint是利用同源蛋白进行注释才用到，其中GenomeTrheads是处理近源蛋白，而ProHint是处理未知距离的蛋白。</p>
<p>从 <a target="_blank" rel="noopener" href="http://exon.gatech.edu/GeneMark/license_download.cgi">http://exon.gatech.edu/GeneMark/license_download.cgi</a> 下载GeneMark，并按照文档进行安装，最后添加环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GENEMARK_PATH=/your_path_to_GeneMark-ET/gmes_petap/</span><br><span class="line"><span class="comment">#例如,我的安装路径为/opt/biosoft/gm_et_linux_64</span></span><br><span class="line"><span class="built_in">export</span> GENEMARK_PATH=/opt/biosoft/gm_et_linux_64</span><br></pre></td></tr></table></figure>

<p>安装完成之后，建议运行下面这一步检查软件依赖</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">braker.pl --checkSoftware</span><br></pre></td></tr></table></figure>

<h2 id="软件运行"><a href="#软件运行" class="headerlink" title="软件运行"></a>软件运行</h2><p>BRAKER根据数据类型，有<a target="_blank" rel="noopener" href="https://github.com/Gaius-Augustus/BRAKER#overview-of-modes-for-running-braker">不同的运行模式</a>，但根据现状其实最常见的情况是测了一个基因组，并且还测了二代的转录组。因此假设你手头有下面这些数据</p>
<ul>
<li>基因组序列: genome.fasta</li>
<li>转录组数据: XX_R1.fq.gz, XX_R2.fq.gz, YY_R1.fq.gz, YY_R2.fq.gz, ZZ_R1.fq.gz, ZZ_R2.fq.gz</li>
</ul>
<p>第一步: 屏蔽基因组中的重复序列，这一步参考<a href="/archives/Annotate-repeat-in-genome-with-RepeatModeler-and-RepeatMasker">使用RepeatModeler和RepeatMasker注释基因组重复序列</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RepeatMasker -xsmall -species arabidopsis -pa 40 -e ncbi  -<span class="built_in">dir</span> . genome.fasta</span><br><span class="line"><span class="comment">#-xsmall: soft-mask</span></span><br></pre></td></tr></table></figure>

<p>这一步输出的genome.fasta.masked将是后续注释的输入</p>
<p>第二步: 使用STAR将FastQ比对到参考基因组，STAR使用说明参考<a href="/archives/RNA-seq-aligner-STAR">「RNA-seq分析软件」RNA-seq比对工具STAR学习笔记</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p STAR</span><br><span class="line"><span class="comment"># 建立索引</span></span><br><span class="line">STAR \</span><br><span class="line">    --runThreadN 20 \</span><br><span class="line">    --runMode genomeGenerate \</span><br><span class="line">    --genomeDir STAR \</span><br><span class="line">    --genomeFastaFiles genome.fasta</span><br><span class="line"><span class="comment"># 比对</span></span><br><span class="line">STAR \</span><br><span class="line">	--genomeDir STAR \</span><br><span class="line">	--runThreadN 20 \</span><br><span class="line">	--readFilesIn XX_R1.fq.gz, XX_R2.fq.gz \</span><br><span class="line">	--readFilesCommand zcat \</span><br><span class="line">	--outFileNamePrefix xx_ \</span><br><span class="line">	--outSAMtype BAM SortedByCoordinate \</span><br><span class="line">	--outBAMsortingThreadN 10 \</span><br><span class="line">	--outSAMstrandField intronMotif \</span><br><span class="line">	--outFilterIntronMotifs RemoveNoncanonical</span><br><span class="line"><span class="built_in">mv</span> xx_Aligned.sortedByCoord.out.bam xx.bam</span><br></pre></td></tr></table></figure>

<p>输入结果为 xx.bam 如果测了多个组装的转录组，为每个样本运行一次比对生成多个BAM文件。</p>
<p>第三步: 运行BRAKER2。<code>--cores 40</code>表示使用40个线程, <code>--softmaksing</code>表示输入序列是软屏蔽。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">braker.pl --cores 40 --species=yourSpecies --genome=genome.fasta.masked \</span><br><span class="line">     --softmasking --bam=xx.bam,yy.bam,zz.bam \</span><br><span class="line">     --gff3</span><br></pre></td></tr></table></figure>

<p>这里xx.bam, yy.bam,zz.bam指的是不同组织的BAM文件，需要根据实际情况进行修改。</p>
<p>对于链特异性转录组测序结果，需要将BAM文件拆分成正链和负链两个bam，然后设置<code>--stranded</code>参数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">braker.pl --species=yourSpecies --genome=genome.fasta.masked \</span><br><span class="line">   --softmasking --bam=plus.bam,minus.bam,unstranded.bam \</span><br><span class="line">   --stranded=+,-,. --UTR=on</span><br></pre></td></tr></table></figure>

<p>如果需要使用近源序列作为输入(protein.fa)，需要加上<code>--prot_seq</code>和<code>--prg</code>参数，速度会慢一些</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">braker.pl --cores 40 --species=yourSpecies --genome=genome.fasta.masked \</span><br><span class="line">     --softmasking --bam=xx.bam,yy.bam,zz.bam \</span><br><span class="line">     --gff3 \</span><br><span class="line">     --prot_seq=proteins.fa --prg=exonerate \</span><br></pre></td></tr></table></figure>

<blockquote>
<p>个人感觉，只要转录组测得够，不需要考虑同源蛋白数据。</p>
</blockquote>
<p>最终会输出蛋白序列和CDS序列以及GFF文件</p>
<ul>
<li>augustus.hints.gtf: 在<code>--esmode</code>时不会出现</li>
<li>augustus.hints_utr.gtf: 在设置<code>--UTR=on </code>时生成</li>
<li>augustus.ab_initio.gtf: 在设置<code>--AUGUSTUS_ab_initio</code>生成</li>
<li>augustus.ab_initio_utr.gtf: 在从头预测的基础上设置<code>--UTR=pn</code>时生成</li>
<li>GeneMark-E*&#x2F;genemark.gtf: GeneMark的注释结果</li>
<li>braker.gtf: AUGUSTUS或GeneMark预测的所有结果</li>
<li>hintsfile.gff: 来自于RNA-seq&#x2F;蛋白数据的外部证据信息</li>
</ul>
<p>此外，如果没有设置<code>--skipGetAnnoFromFasta</code>, 还会有<code>augustus.hints.aa</code>和<code>augustus.hints.codingseq</code></p>
<p><strong>注意</strong>: BRAKER没有断点重跑功能，因此如果中途运行中断，重新运行之前的命令并不会断点重跑，反而会因为同样的参数和之前运行在AUGUSTUS的config&#x2F;species生成的目录冲突而中断。另外设置<code>--useexisting</code>只是覆盖之前<code>config/species</code>对应的目录，而不是利用已有的文件重新开始</p>
<p>尽管如此，我们还是能够在BRAKER中通过跳过一些步骤来避免一些重复运算</p>
<ul>
<li><code>--skipGeneMark-ES/--skipGeneMark-ET/--skipGeneMark-EP/--skipGeneMark-ETP</code>: 跳过GeneMark训练这一步，使用之前的结果<code>braker/GeneMark-ET/genemark.gtf</code>，或者使用<code>--geneMarkGtf</code>设置GTF文件</li>
<li><code>--skipAllTraining</code>: 跳过GeneMark和AUGUSTUS的模型训练，使用之前的参数和文件(<code>--useexisting</code>)运行AUGUSTUS</li>
</ul>
<p>官方教程也提供了一些案例，见<a target="_blank" rel="noopener" href="https://github.com/Gaius-Augustus/BRAKER#starting-braker-on-the-basis-of-previously-existing-braker-runs">https://github.com/Gaius-Augustus/BRAKER#starting-braker-on-the-basis-of-previously-existing-braker-runs</a></p>
<p>除此之外，如果想要提高速度，还可以设置如下参数</p>
<ul>
<li><code>--skipOptimize</code>:  跳过参数优化步骤（不推荐）</li>
<li><code>--rounds</code>: 参数优化迭代数，默认是5，追求速度可以设置的低一些</li>
</ul>
<h2 id="可能问题"><a href="#可能问题" class="headerlink" title="可能问题"></a>可能问题</h2><p>运行时出现和OpenBLAS相关的警告和报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OpenBLAS blas_thread_init: RLIMIT_NPROC 4096</span><br><span class="line">OpenBLAS blas_thread_init: pthread_create failed <span class="keyword">for</span> thread 26 of 128: Resource temporarily unavailable</span><br></pre></td></tr></table></figure>

<p>需要在运行前设置如下两个环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> OMP_NUM_THREADS=1 <span class="comment">#限制CPU数</span></span><br><span class="line"><span class="built_in">export</span> USE_SIMPLE_THREADED_LEVEL3=1</span><br></pre></td></tr></table></figure>

<p>使用conda安装时可能会出现的问题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error <span class="keyword">in</span> file bamToWig.py at line 172: Return code of subprocess was 127</span><br></pre></td></tr></table></figure>

<p>原因是因为<code>faToTwoBit</code>程序出错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">faToTwoBit</span><br><span class="line">faToTwoBit: error <span class="keyword">while</span> loading shared libraries: libssl.so.1.0.0: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>这是因为conda没能正确处理依赖关系，openssl版本过高，解决方法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立软链接</span></span><br><span class="line"><span class="built_in">cd</span> ~/miniconda3/envs/braker2/lib</span><br><span class="line"><span class="built_in">ln</span> -s libssl.so libssl.so.1.0.0</span><br><span class="line"><span class="built_in">ln</span> -s libcrypto.so libcrypto.so.1.0.0</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>BRAKER2官方教程: <a target="_blank" rel="noopener" href="https://github.com/Gaius-Augustus/BRAKER">https://github.com/Gaius-Augustus/BRAKER</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/10/10/%E4%BD%BF%E7%94%A8BRAKER2%E8%BF%9B%E8%A1%8C%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%B3%A8%E9%87%8A-genome-annotation-with-braker2/" data-id="clm1xkn5p001odpnic5p19hxx" data-title="使用BRAKER2进行基因组注释" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7/" rel="tag">注释 | 流程工具</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-「RNA-seq分析软件」RNA-seq比对工具STAR学习笔记-RNA-seq-aligner-STAR" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/10/%E3%80%8CRNA-seq%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6%E3%80%8DRNA-seq%E6%AF%94%E5%AF%B9%E5%B7%A5%E5%85%B7STAR%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RNA-seq-aligner-STAR/" class="article-date">
  <time class="dt-published" datetime="2019-10-10T17:03:44.340Z" itemprop="datePublished">2019-10-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/10/%E3%80%8CRNA-seq%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6%E3%80%8DRNA-seq%E6%AF%94%E5%AF%B9%E5%B7%A5%E5%85%B7STAR%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RNA-seq-aligner-STAR/">「RNA-seq分析软件」RNA-seq比对工具STAR学习笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>软件的GitHub地址为<a target="_blank" rel="noopener" href="https://github.com/alexdobin/STAR">https://github.com/alexdobin/STAR</a>, 下载页面为<a target="_blank" rel="noopener" href="https://github.com/alexdobin/STAR/releases">https://github.com/alexdobin/STAR/releases</a>, 挑最新的下载，避免bug。</p>
<h2 id="软件使用"><a href="#软件使用" class="headerlink" title="软件使用"></a>软件使用</h2><p><code>STAR</code>的主程序只有两个:<code>STAR</code>和<code>STARlong</code>。前者用于比对RNA-seq数据，后者是针对于长读长RNA数据。由于同一个程序，又需要做建索引，又需要做序列比对，并且这个程序还支持一系列的输出格式，因此直接用STAR，你会迷失在参数的海洋中。所以我们需要先阅读<a target="_blank" rel="noopener" href="https://github.com/alexdobin/STAR/blob/master/doc/STARmanual.pdf">文档</a> ，先对整体有一个了了解。</p>
<p>STAR的基本使用流程分为两步：</p>
<ol>
<li>生成基因组索引文件。你需要提供基因组序列(FASTA)和注释文件(GTF)</li>
<li>将读段回帖到基因组。这一步需要提供的是RNA-seq数据，格式目前都是FASTQ&#x2F;FASTA, 最后会得到很多很多的文件，常规的SAM&#x2F;BAM文件，可变剪切点文件，未回帖上的读段和常用于展示信号的WIG文件。</li>
</ol>
<p>STAR的使用格式为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STAR --option1-name option1-value --option2-name option2-value ...</span><br></pre></td></tr></table></figure>

<h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><p>举例说明:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STAR  --runMode genomeGenerate \</span><br><span class="line">    --genomeDir ref \</span><br><span class="line">    --runThreadN 20 \</span><br><span class="line">    --genomeFastaFiles reference.fa\</span><br><span class="line">    --sjdbGTFfile reference.gtf</span><br></pre></td></tr></table></figure>

<p>常用参数说明</p>
<ul>
<li>–runThreadN 线程数 :设置线程数</li>
<li>–runMode genomeGenerate : 设置模式为构建索引</li>
<li>–genomedDir 索引文件存放路径 : 必须先创建文件夹</li>
<li>–genomeFastaFiles 基因组fasta文件路径 : 支持多文件路径</li>
<li>–sjdbGTFfile gtf文件路径 : 可选项，高度推荐,用于提高比对精确性</li>
<li>–sjdbOverhang 读段长度: 后续回帖读段的长度, 如果读长是PE 100， 则该值设为100-1&#x3D;99</li>
</ul>
<p>几个额外要说明的点：</p>
<ul>
<li>由于物种的组装的复杂性，存在一些为组装上的片段，这些片段不需要放在参考序列中，尤其是可变单倍型(alternative haplotypes)</li>
<li>如果基因组的contig过多，超过5000，你需要用 <code>--genomeChrBinNbits=min(18,log2[max(GenomeLength/NumberOfReferences,ReadLength)])</code> 降低RAM消耗</li>
<li>选择最新的注释文件，人类和小鼠常在<a target="_blank" rel="noopener" href="http://www.gencodegenes.org/">http://www.gencodegenes.org</a>下载，植物的可信基因组见<a target="_blank" rel="noopener" href="http://plants.ensembl.org/">http://plants.ensembl.org</a></li>
<li>如果没有设置<code>--sjdbGTFfile</code>或<code>--sjdbFileChrStartEnd</code>，就不需要设置<code>--sjdbOverhang</code></li>
</ul>
<h3 id="读段回帖"><a href="#读段回帖" class="headerlink" title="读段回帖"></a>读段回帖</h3><p>用法举例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">STAR \</span><br><span class="line">    --genomeDir ref \</span><br><span class="line">     --runThreadN 20 \</span><br><span class="line">    --readFilesIn sample_r1.fq.gz sample_r2.fq.gz \</span><br><span class="line">    --readFilesCommand zcat \</span><br><span class="line">    --outFileNamePrefix sample \</span><br><span class="line">    --outSAMtype BAM SortedByCoordinate \</span><br><span class="line">    --outBAMsortingThreadN 10</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<ul>
<li>–runThreadN 设置线程数</li>
<li>–runMode alignReads : 默认就是比对模式，可以不填写</li>
<li>–genomeDir: 索引文件夹 </li>
<li>–readFilesIn FASTA&#x2F;Q文件路径</li>
<li>–readFilesCommand zcat: 如果输入格式是gz结尾，那么需要加上zcat, 否则会报错</li>
<li>–outSAMtype: 输出SAM文件的格式，是否排序</li>
<li>–outBAMsortingThreadN: SAM排序成BAM时调用线程数</li>
</ul>
<p>默认参数下，会输出文件在当前文件夹，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Aligned.out.sam  Log.final.out  Log.out  Log.progress.out   SJ.out.tab</span><br></pre></td></tr></table></figure>

<p>可以用<code>--outFileNamePrefix</code>指定文件夹和前缀，其中”Aligned.out.sam”是默认回帖后输出。一般而言，SAM文件过大，不方便后续使用，我们更需要的是BAM文件。最好是类似于<code>samtools sort</code>的输出文件，那么设置参数为<code>--outSAMtype BAM SortedByCoordinate</code>。 如果你设置的线程数非常大，那么你很有可能会遇到如下这种报错，我的解决方案就是降低线程数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FATAL ERROR: number of bytes expected from the BAM bin does not agree with the actual size on disk</span><br></pre></td></tr></table></figure>

<p>xxx.out文件是一些日志信息. </p>
<p>“SJ.out.tab”存放的高可信的剪切位点，每一列的含义如下</p>
<ul>
<li>第一列: 染色体</li>
<li>第二列: 内含子起始（以1为基）</li>
<li>第三列: 内含子结束（以1为基）</li>
<li>第四列：所在链，1(+)，2(-)</li>
<li>第五列: 内含子类型，0表示不是下面的任何一种功能，1表示GT&#x2F;AG, 2表示:GT&#x2F;AC,3表示GC&#x2F;AG,4表示GT&#x2F;GC,5表示AT&#x2F;GC,6表示GT&#x2F;AT</li>
<li>第六列: 是否是已知的注释</li>
<li>第七列: 有多少唯一联配支持</li>
<li>第八列: 有多少多重联配支持</li>
<li>第九列: maximum spliced alignment overhang, 这个比较难以翻译，指的是当短读比对到剪切位点时，中间会被分开，另一边能和基因组匹配的数目，例如ACGTACGT———-ACGT，就是4或者8，取决于方向。</li>
</ul>
<p>控制过滤的参数为<code>--outSJfilter*</code>系列，其中<code>--outSJfilterCountUniqueMin 3 1 1 1</code>表示4类内含子唯一匹配的read支持数至少为3,1,1,1, 而<code>--outSJfilterCountTotalMin 3 1 1 1</code>则表示4类内含子唯一匹配和多重匹配read的支持数和，至少为3,1,1,1。如果你设置的<code>--outSJfilterReads Unique</code>，那么上面两者是等价的，当然默认情况下是<code>All</code></p>
<p><strong>注意</strong>：双端测序中一定要注意不能把文件输入错了，不然比对率几乎为0。下面我一次脚本翻车记录，两个都是R1和R1，应该是R1和R2</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/image-51a1fd743b874764a6d4e9b421a27cd6.png" alt="翻车记录"></p>
<h3 id="更多参数"><a href="#更多参数" class="headerlink" title="更多参数"></a>更多参数</h3><p>除了上面常用的一些参数外，STAR的可选参数其实非常多.</p>
<p>输出BAM文件时，STAR还可以对BAM进行一些预处理，”–bamRemoveDuplicatesType”用于去重(“UniqueIdentical”,”UniqueIdenticalNotMulti”)</p>
<p>如果你希望输出信号文件(Wig格式),那么需要额外增加<code>--outWigType</code>参数，如<code>--outWigType wiggle read2</code>, 还可以用<code>--outWigStrand</code>指定是否将两条链合并(Stranded, Unstranded), 默认<code>--outWigNorm RPM</code>，也就是用RPM进行标准化，可以选择None.</p>
<p>如果你在建立索引或者比对的时候增加了注释信息，那么STAR还能帮你进行基因计数。参数为<code>--quantMode</code>, 分为转录本水平(TranscriptomeSAM)和基因水平(GeneCounts)，在计数的时候还允许指定哪些哪些read不参与计数，”IndelSoftclipSingleend”和”Singleend”</p>
<p>对于非链特异性RNA-seq，同时为了保证能和<strong>Cufflinks</strong>兼容，需要添加<code>--outSAMstrandField intronMotif</code>在SAM中增加XS属性，并且建议加上<code>--outFilterIntronMotifs RemoveNoncanonical</code>。如果是链特异性数据，那么就不需要特别的参数，Cufflinks用<code>--library-type</code>声明类型即可&#x3D;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/10/10/%E3%80%8CRNA-seq%E5%88%86%E6%9E%90%E8%BD%AF%E4%BB%B6%E3%80%8DRNA-seq%E6%AF%94%E5%AF%B9%E5%B7%A5%E5%85%B7STAR%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-RNA-seq-aligner-STAR/" data-id="clm1xkn9i00eldpni6l4y3zxk" data-title="「RNA-seq分析软件」RNA-seq比对工具STAR学习笔记" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" rel="tag">转录组 | 序列比对</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-「文献」多倍体植物基因组测序组装当前策略-Current-Strategies-of-Polyploid-Plant-Genome-Sequence-Assembly" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/09/%E3%80%8C%E6%96%87%E7%8C%AE%E3%80%8D%E5%A4%9A%E5%80%8D%E4%BD%93%E6%A4%8D%E7%89%A9%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%B5%8B%E5%BA%8F%E7%BB%84%E8%A3%85%E5%BD%93%E5%89%8D%E7%AD%96%E7%95%A5-Current-Strategies-of-Polyploid-Plant-Genome-Sequence-Assembly/" class="article-date">
  <time class="dt-published" datetime="2019-10-09T20:46:39.461Z" itemprop="datePublished">2019-10-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/">文献阅读</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/09/%E3%80%8C%E6%96%87%E7%8C%AE%E3%80%8D%E5%A4%9A%E5%80%8D%E4%BD%93%E6%A4%8D%E7%89%A9%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%B5%8B%E5%BA%8F%E7%BB%84%E8%A3%85%E5%BD%93%E5%89%8D%E7%AD%96%E7%95%A5-Current-Strategies-of-Polyploid-Plant-Genome-Sequence-Assembly/">「文献」多倍体植物基因组测序组装当前策略</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="「文献」多倍体植物基因组测序组装当前策略"><a href="#「文献」多倍体植物基因组测序组装当前策略" class="headerlink" title="「文献」多倍体植物基因组测序组装当前策略"></a>「文献」多倍体植物基因组测序组装当前策略</h1><p>文献地址: <a target="_blank" rel="noopener" href="https://www.frontiersin.org/articles/10.3389/fpls.2018.01660/full">Current Strategies of Polyploid Plant Genome Sequence Assembly</a></p>
<p>基因组多倍化主要发生在被子植物中。很多多倍体植物都在农业生产上有重大的价值，例如小麦(<em>Triticum aestivum</em>)，花生(<em>Arachis hypogaea</em>)，十字花科，马铃薯(<em>Solanum tuberosum</em>)，燕麦(<em>Avena sativa</em>)，香蕉(<em>Musa sp.</em>)，草莓(<em>Fragaria ananassa</em>)，咖啡( <em>Coffea arabica</em>)等。</p>
<p>多倍体分为两种类型，来自于全基因组加倍的同源多倍体(Autopolyploidy)和物种间&#x2F;物种内杂交后染色体加倍的异源多倍体(allopolyploidy). 同源多倍体通常会有育性上的问题，而异源多倍体则可能出现杂交优势(heterosis or hybrid vigor).多倍体在表型和基因型上的关系更加复杂，例如它们需要比较复杂的调控才能保证同源基因相互间的表达一致。</p>
<p>在基因组组装上，同源多倍体相对异源多倍体更加困难。这是因为全基因组加倍事件之后通常还会跟着基因组重拍(genome rearrangement), 非典型重组(atypical recombination), 可移动因子启动(transposable element activation)，减数分裂&#x2F;有丝分裂缺陷(meiotic&#x2F;mitotic defects)，以及内含子扩张(intron expansions)与DNA缺失。因此组装基因组一大挑战就是不能错误组装了两个亚基因组中的相似片段。 </p>
<p>作者在<a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/genome/browse/#!/overview/">NCBI</a>查询并总结了到2018年为止已发表的多倍体物种，我更新了草莓(Fragaria × ananassa)，香蕉(<em>Musa balbisiana</em>)和甘蔗(<em>Saccharum spontaneum</em> L.)</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Organism name</th>
<th>Genome size (Mb)</th>
<th>Current status</th>
<th>1st Release date in NCBI</th>
<th>Ploidy level</th>
<th>References&#x2F;center</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Arabidopsis lyrata subsp lyrata</td>
<td>206.823</td>
<td>Scaffold</td>
<td>2009&#x2F;11&#x2F;30</td>
<td>Tetraploid</td>
<td>Hu et al., 2011</td>
</tr>
<tr>
<td>2</td>
<td>Glycine max</td>
<td>978.972</td>
<td>Chromosome</td>
<td>2010&#x2F;1&#x2F;5</td>
<td>Allotetraploid</td>
<td>Schmutz et al., 2010</td>
</tr>
<tr>
<td>3</td>
<td>Triticum aestivum</td>
<td>15344.7</td>
<td>Chromosome 3B</td>
<td>2010&#x2F;7&#x2F;15</td>
<td>Allohexaploid</td>
<td>Choulet et al., 2010</td>
</tr>
<tr>
<td>4</td>
<td>Solanum tuberosum</td>
<td>705.934</td>
<td>Scaffold</td>
<td>2011&#x2F;5&#x2F;24</td>
<td>Autotetraploid</td>
<td>Potato Genome Sequencing Consortium, 2011</td>
</tr>
<tr>
<td>5</td>
<td>Actinidia chinensis</td>
<td>604.217</td>
<td>Contig</td>
<td>2013&#x2F;9&#x2F;16</td>
<td>Tetraploid</td>
<td>Huang et al., 2013</td>
</tr>
<tr>
<td>6</td>
<td>Fragaria orientalis</td>
<td>214.356</td>
<td>Scaffold</td>
<td>2013&#x2F;11&#x2F;27</td>
<td>Tetraploid</td>
<td>Hirakawa et al., 2014</td>
</tr>
<tr>
<td>7</td>
<td>Fragaria x ananassa</td>
<td>805.488</td>
<td>Chromosome</td>
<td>2019&#x2F;2&#x2F;25</td>
<td>Allooctaploid</td>
<td>Edger et al., 2019</td>
</tr>
<tr>
<td>8</td>
<td>Beta vulgaris</td>
<td>566.55</td>
<td>Chromosome</td>
<td>2013&#x2F;12&#x2F;18</td>
<td>2n, 4n (Beyaz et al., 2013)</td>
<td>Dohm et al., 2014</td>
</tr>
<tr>
<td>9</td>
<td>Oryza minuta</td>
<td>45.1659</td>
<td>Chromosome</td>
<td>2014&#x2F;4&#x2F;16</td>
<td>Tetraploid</td>
<td>Oryza Chr3 Short Arm Comparative Sequencing Project</td>
</tr>
<tr>
<td>10</td>
<td>Camelina sativa</td>
<td>641.356</td>
<td>Chromosome</td>
<td>2014&#x2F;4&#x2F;17</td>
<td>Hexaploid</td>
<td>Kagale et al., 2014</td>
</tr>
<tr>
<td>11</td>
<td>Brassica napus</td>
<td>976.191</td>
<td>Chromosome</td>
<td>2014&#x2F;5&#x2F;5</td>
<td>Allotetraploid</td>
<td>Chalhoub et al., 2014</td>
</tr>
<tr>
<td>12</td>
<td>Brassica oleracea var. oleracea</td>
<td>488.954</td>
<td>Chromosome</td>
<td>2014&#x2F;5&#x2F;22</td>
<td>Hexaploid</td>
<td>NCBI</td>
</tr>
<tr>
<td>13</td>
<td>Nicotiana tabacum</td>
<td>3643.47</td>
<td>Scaffold</td>
<td>2014&#x2F;5&#x2F;29</td>
<td>Allotetraploid</td>
<td>Sierro et al., 2014</td>
</tr>
<tr>
<td>14</td>
<td>Eragrostis tef</td>
<td>607.318</td>
<td>Scaffold</td>
<td>2015&#x2F;4&#x2F;8</td>
<td>Allotetraploid</td>
<td>Cannarozzi et al., 2014</td>
</tr>
<tr>
<td>15</td>
<td>Gossypium hirsutum</td>
<td>2189.14</td>
<td>Chromosome</td>
<td>2015&#x2F;4&#x2F;29</td>
<td>Allotetraploid</td>
<td>Li et al., 2015</td>
</tr>
<tr>
<td>16</td>
<td>Zoysia japonica</td>
<td>334.384</td>
<td>Scaffold</td>
<td>2016&#x2F;3&#x2F;15</td>
<td>Tetraploid</td>
<td>Tanaka et al., 2016</td>
</tr>
<tr>
<td>17</td>
<td>Zoysia matrella</td>
<td>563.439</td>
<td>Scaffold</td>
<td>2016&#x2F;3&#x2F;15</td>
<td>Allotetraploid</td>
<td>Tanaka et al., 2016</td>
</tr>
<tr>
<td>18</td>
<td>Zoysia pacifica</td>
<td>397.01</td>
<td>Scaffold</td>
<td>2016&#x2F;3&#x2F;15</td>
<td>Allotetraploid</td>
<td>Tanaka et al., 2016</td>
</tr>
<tr>
<td>19</td>
<td>Musa itinerans</td>
<td>455.349</td>
<td>Scaffold</td>
<td>2016&#x2F;5&#x2F;21</td>
<td>2n, 3n hybrids (Wu et al.,2016)</td>
<td>South China Botanic Garden, CAS</td>
</tr>
<tr>
<td>20</td>
<td>Rosa x damascena</td>
<td>711.72</td>
<td>Scaffold</td>
<td>2016&#x2F;6&#x2F;13</td>
<td>Tetraploid</td>
<td>BIO-FD &amp; C CO., LTD</td>
</tr>
<tr>
<td>21</td>
<td>Chenopodium quinoa</td>
<td>1333.55</td>
<td>Scaffold</td>
<td>2016&#x2F;7&#x2F;11</td>
<td>Tetraploid</td>
<td>Jarvis et al., 2017</td>
</tr>
<tr>
<td>22</td>
<td>Brassica juncea var. tumida</td>
<td>954.861</td>
<td>Chromosome</td>
<td>2016&#x2F;7&#x2F;19</td>
<td>Allotetraploid</td>
<td>Zhejiang University</td>
</tr>
<tr>
<td>23</td>
<td>Hibiscus syriacus</td>
<td>1748.25</td>
<td>Scaffold</td>
<td>2016&#x2F;7&#x2F;29</td>
<td>2n, 3n, 4n (Van   Huylenbroeck et al., 2000)</td>
<td>Korea Research Institute of Science and Biotechnology (Kim et   al., 2017)</td>
</tr>
<tr>
<td>24</td>
<td>Gossypium barbadense</td>
<td>2566.74</td>
<td>Scaffold</td>
<td>2016&#x2F;10&#x2F;28</td>
<td>Tetraploid</td>
<td>Huazhong Agricultural University</td>
</tr>
<tr>
<td>25</td>
<td>Momordica charantia</td>
<td>285.614</td>
<td>Scaffold</td>
<td>2016&#x2F;12&#x2F;27</td>
<td>2n to 6n (Kausar et al., 2015)</td>
<td>Urasaki et al., 2016</td>
</tr>
<tr>
<td>26</td>
<td>Drosera capensis</td>
<td>263.788</td>
<td>Scaffold</td>
<td>2016&#x2F;12&#x2F;30</td>
<td>Tetraploid (Rothfels and Heimburger, 1968)</td>
<td>Butts et al., 2016</td>
</tr>
<tr>
<td>27</td>
<td>Capsella bursa-pastoris</td>
<td>268.431</td>
<td>Scaffold</td>
<td>2017&#x2F;1&#x2F;29</td>
<td>Tetraploid</td>
<td>Lomonosov Moscow State University</td>
</tr>
<tr>
<td>28</td>
<td>Saccharum hybrid cultivar</td>
<td>1169.95</td>
<td>Contig</td>
<td>2017&#x2F;3&#x2F;3</td>
<td>It varies (D’Hont, 2005)</td>
<td>Riaño-Pachón and Mattiello, 2017</td>
</tr>
<tr>
<td>29</td>
<td>Xerophyta viscosa</td>
<td>295.462</td>
<td>Scaffold</td>
<td>2017&#x2F;3&#x2F;31</td>
<td>Hexaploid</td>
<td>Costa et al., 2017</td>
</tr>
<tr>
<td>30</td>
<td>Triticum dicoccoides</td>
<td>10495</td>
<td>Chromosome</td>
<td>2017&#x2F;5&#x2F;18</td>
<td>Tetraploid</td>
<td>WEWseq consortium</td>
</tr>
<tr>
<td>31</td>
<td>Utricularia gibba</td>
<td>100.689</td>
<td>Chromosome</td>
<td>2017&#x2F;5&#x2F;31</td>
<td>16-ploid</td>
<td>Lan et al., 2017</td>
</tr>
<tr>
<td>32</td>
<td>Eleusine coracana</td>
<td>1195.99</td>
<td>Scaffold</td>
<td>2017&#x2F;6&#x2F;8</td>
<td>Allotetraploid</td>
<td>Hittalmani et al., 2017</td>
</tr>
<tr>
<td>33</td>
<td>Dioscorea rotundata</td>
<td>456.675</td>
<td>Chromosome</td>
<td>2017&#x2F;7&#x2F;28</td>
<td>Tetraploid</td>
<td>Iwate Biotechnology Research Center</td>
</tr>
<tr>
<td>34</td>
<td>Ipomoea batatas</td>
<td>837.013</td>
<td>Contig</td>
<td>2017&#x2F;8&#x2F;26</td>
<td>Autohexaploid</td>
<td>Yang et al., 2017</td>
</tr>
<tr>
<td>35</td>
<td>Echinochloa crus-galli</td>
<td>1486.61</td>
<td>Scaffold</td>
<td>2017&#x2F;10&#x2F;23</td>
<td>Hexaploid</td>
<td>Zhejiang University</td>
</tr>
<tr>
<td>36</td>
<td>Pachycereus pringlei</td>
<td>629.656</td>
<td>Scaffold</td>
<td>2017&#x2F;10&#x2F;31</td>
<td>Autotetraploid</td>
<td>Zhou et al., 2017</td>
</tr>
<tr>
<td>37</td>
<td>Olea europaea</td>
<td>1141.15</td>
<td>Chromosome</td>
<td>2017&#x2F;11&#x2F;1</td>
<td>2n, 4n, 6n (Besnard et al.,      2007)</td>
<td>Unver et al., 2017</td>
</tr>
<tr>
<td>38</td>
<td>Monotropa hypopitys</td>
<td>2197.49</td>
<td>Contig</td>
<td>2018&#x2F;1&#x2F;3</td>
<td>Hexaploid</td>
<td>Institute of Bioengineering, RAS</td>
</tr>
<tr>
<td>39</td>
<td>Dactylis glomerata</td>
<td>839.915</td>
<td>Scaffold</td>
<td>2018&#x2F;1&#x2F;19</td>
<td>Autotetraploid</td>
<td>Sichuan Agricultural University</td>
</tr>
<tr>
<td>40</td>
<td>Panicum miliaceum</td>
<td>848.309</td>
<td>Scaffold</td>
<td>2018&#x2F;1&#x2F;23</td>
<td>Allotetraploid</td>
<td>China Agricultural University</td>
</tr>
<tr>
<td>41</td>
<td>Euphorbia esula</td>
<td>1124.89</td>
<td>Scaffold</td>
<td>2018&#x2F;2&#x2F;6</td>
<td>Hexaploid</td>
<td>USDA-ARS</td>
</tr>
<tr>
<td>42</td>
<td>Santalum album</td>
<td>220.961</td>
<td>Scaffold</td>
<td>2018&#x2F;2&#x2F;12</td>
<td>2n, 4n etc (Xin-Hua et al.,      2010)</td>
<td>Center for Cellular and Molecular Platforms</td>
</tr>
<tr>
<td>43</td>
<td>Avena sativa</td>
<td>67.3266</td>
<td>Contig</td>
<td>2018&#x2F;2&#x2F;26</td>
<td>Hexaploid</td>
<td>The Sainsbury Laboratory</td>
</tr>
<tr>
<td>44</td>
<td>Panicum miliaceum</td>
<td>850.677</td>
<td>Chromosome</td>
<td>2018&#x2F;4&#x2F;9</td>
<td>Tetraploid</td>
<td>Shanghai Center for Plant Stress Biology</td>
</tr>
<tr>
<td>45</td>
<td>Arachis monticola</td>
<td>2618.65</td>
<td>Chromosome</td>
<td>2018&#x2F;4&#x2F;23</td>
<td>Tetraploid</td>
<td>Henan Agricultural University</td>
</tr>
<tr>
<td>46</td>
<td>Arachis hypogaea</td>
<td>2538.28</td>
<td>Chromosome</td>
<td>2018&#x2F;5&#x2F;2</td>
<td>Allotetraploid</td>
<td>International Peanut Genome Initiative</td>
</tr>
<tr>
<td>47</td>
<td>Artemisia annua</td>
<td>1792.86</td>
<td>Scaffold</td>
<td>2018&#x2F;5&#x2F;8</td>
<td>Tetraploid</td>
<td>Shen et al., 2018</td>
</tr>
<tr>
<td>48</td>
<td>Saccharum spontaneum L.</td>
<td>2.9 G</td>
<td>Chromosome</td>
<td>2018&#x2F;09&#x2F;10</td>
<td>octoploid</td>
<td>Zhang et al., 2018</td>
</tr>
<tr>
<td>49</td>
<td>Musa balbisiana</td>
<td>430</td>
<td>Chromosome</td>
<td>2019&#x2F;7&#x2F;15</td>
<td>Tetraploid</td>
<td>Wang et al., 2019</td>
</tr>
</tbody></table>
<p>在倍性预测上，有两种方法可以使用</p>
<ul>
<li>使用流式细胞仪测量C-值, 参考网站<a target="_blank" rel="noopener" href="https://cvalues.science.kew.org/">Plant DNA C-values Database</a></li>
<li>基于NGS的生信策略: ploidyNG ConPADE</li>
</ul>
<p>而在单倍型组装上，作者列了如下工具，当然最靠谱的肯定是最新的，也就是HapCUT2</p>
<ul>
<li>HapCompass (Aguiar and Istrail, 2012) </li>
<li>HaploSim (Bastiaansen et al., 2012) </li>
<li>HapCut (Bansal and Bafna, 2008) </li>
<li>HapCUT2 (Edge et al., 2017)</li>
</ul>
<p>在解决多倍体问题上，作者给出了两种策略</p>
<ul>
<li>基因组上: 尽量挑选单倍型，或者先测二倍体祖先</li>
<li>分析流程上:  三代测序, BioNano, HiC</li>
</ul>
<p>最终，作者总结了目前植物可用的资源网站</p>
<table>
<thead>
<tr>
<th>DB name</th>
<th>Resources</th>
<th>Plants</th>
<th>URL</th>
</tr>
</thead>
<tbody><tr>
<td>Genbank</td>
<td>Genomic</td>
<td>Various plant species</td>
<td><a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/genbank/">https://www.ncbi.nlm.nih.gov/genbank/</a></td>
</tr>
<tr>
<td>EMBL</td>
<td>Genomic</td>
<td>Various plant species</td>
<td><a target="_blank" rel="noopener" href="https://www.ebi.ac.uk/">https://www.ebi.ac.uk/</a></td>
</tr>
<tr>
<td>DDBJ</td>
<td>Genomic</td>
<td>Various plant species</td>
<td><a target="_blank" rel="noopener" href="http://www.ddbj.nig.ac.jp/">http://www.ddbj.nig.ac.jp/</a></td>
</tr>
<tr>
<td>UniProt</td>
<td>Protein and functional</td>
<td>Various plant species</td>
<td><a target="_blank" rel="noopener" href="http://www.uniprot.org/">http://www.uniprot.org/</a></td>
</tr>
<tr>
<td>NCBI</td>
<td>Genomic</td>
<td>Various plant species</td>
<td><a target="_blank" rel="noopener" href="https://www.ncbi.nlm.nih.gov/">https://www.ncbi.nlm.nih.gov/</a></td>
</tr>
<tr>
<td>GOLD</td>
<td>Genomic, metagenomics, transcriptomic</td>
<td>Various plant species</td>
<td><a target="_blank" rel="noopener" href="https://gold.jgi.doe.gov/cgi-bin/GOLD/bin/gold.cgi">https://gold.jgi.doe.gov/cgi-bin/GOLD/bin/gold.cgi</a></td>
</tr>
<tr>
<td>Phytozom</td>
<td>Genomic</td>
<td>92 assembled and annotated plant species</td>
<td><a target="_blank" rel="noopener" href="https://phytozome.jgi.doe.gov/pz/portal.html">https://phytozome.jgi.doe.gov/pz/portal.html</a></td>
</tr>
<tr>
<td>Plantgdb</td>
<td>Genomic, transcriptomic</td>
<td>27 assembled and annotated plant species</td>
<td><a target="_blank" rel="noopener" href="http://www.plantgdb.org/">http://www.plantgdb.org/</a></td>
</tr>
<tr>
<td>Sol</td>
<td>Genomic</td>
<td>11 Solanaceae species</td>
<td><a target="_blank" rel="noopener" href="https://solgenomics.net/">https://solgenomics.net/</a></td>
</tr>
<tr>
<td>Gramene</td>
<td>Genomic, genetic markers, QTLs</td>
<td>53 plant species</td>
<td><a target="_blank" rel="noopener" href="http://www.gramene.org/">http://www.gramene.org/</a></td>
</tr>
<tr>
<td>MaizeGCB</td>
<td>Genomic, annotations, tool host</td>
<td>Zea mays</td>
<td><a target="_blank" rel="noopener" href="https://www.maizegdb.org/">https://www.maizegdb.org/</a></td>
</tr>
<tr>
<td>Tair</td>
<td>Genetic and molecular biology data</td>
<td>Arabidopsis thaliana</td>
<td><a target="_blank" rel="noopener" href="https://www.arabidopsis.org/">https://www.arabidopsis.org/</a></td>
</tr>
<tr>
<td>CottonGE</td>
<td>Genomic, Genetic and breeding resources</td>
<td>49 Gossypium species</td>
<td><a target="_blank" rel="noopener" href="https://www.arabidopsis.org/">https://www.arabidopsis.org/</a></td>
</tr>
<tr>
<td>PLEXdb</td>
<td>Gene expression</td>
<td>14 plant species</td>
<td><a target="_blank" rel="noopener" href="http://www.plexdb.org/">http://www.plexdb.org/</a></td>
</tr>
<tr>
<td>RicePro</td>
<td>Gene expression</td>
<td>Oryza sativa</td>
<td><a target="_blank" rel="noopener" href="http://ricexpro.dna.affrc.go.jp/">http://ricexpro.dna.affrc.go.jp/</a></td>
</tr>
<tr>
<td>CerealsDB</td>
<td>Genetic markers</td>
<td>Triticum aestivum</td>
<td><a target="_blank" rel="noopener" href="http://www.cerealsdb.uk.net/cerealgenomics/CerealsDB/indexNEW.php">http://www.cerealsdb.uk.net/cerealgenomics/CerealsDB/indexNEW.php</a></td>
</tr>
<tr>
<td>PeanutBa</td>
<td>Genome, MAS, QTLs, Germplasm</td>
<td>Arachis hypogaea</td>
<td><a target="_blank" rel="noopener" href="https://peanutbase.org/">https://peanutbase.org/</a></td>
</tr>
<tr>
<td>SoyKb</td>
<td>Genetic markers, genomic resources</td>
<td>Glycine max</td>
<td><a target="_blank" rel="noopener" href="http://soykb.org/">http://soykb.org/</a></td>
</tr>
<tr>
<td>SoyBase</td>
<td>Genetic markers, QTLs, genomic resources</td>
<td>G. max</td>
<td><a target="_blank" rel="noopener" href="https://soybase.org/">https://soybase.org/</a></td>
</tr>
<tr>
<td>PGDBj</td>
<td>Genetic markers, QTLs, genomic resources</td>
<td>80 plant species</td>
<td><a target="_blank" rel="noopener" href="http://pgdbj.jp/">http://pgdbj.jp/</a></td>
</tr>
<tr>
<td>SNP-Seek</td>
<td>Genotype, Phenotype and Variety information</td>
<td>O. sativa</td>
<td><a target="_blank" rel="noopener" href="http://snp-seek.irri.org/">http://snp-seek.irri.org/</a></td>
</tr>
<tr>
<td>GrainGene</td>
<td>Genome, Genetic markers, QTLs, genomic resources</td>
<td>T. aestivum, Hordeum vulgare, Secale cereale, Avena sativa etc</td>
<td><a target="_blank" rel="noopener" href="https://wheat.pw.usda.gov/GG3/">https://wheat.pw.usda.gov/GG3/</a></td>
</tr>
<tr>
<td>ASRP</td>
<td>small RNA</td>
<td>A. thaliana</td>
<td><a target="_blank" rel="noopener" href="http://asrp.danforthcenter.org/">http://asrp.danforthcenter.org/</a></td>
</tr>
<tr>
<td>CSRDB</td>
<td>small RNA</td>
<td>Z. mays</td>
<td><a target="_blank" rel="noopener" href="http://sundarlab.ucdavis.edu/smrnas/">http://sundarlab.ucdavis.edu/smrnas/</a></td>
</tr>
<tr>
<td>BrassicaIn</td>
<td>Genomic</td>
<td>7 Brassica species</td>
<td><a target="_blank" rel="noopener" href="http://brassica.info/">http://brassica.info/</a></td>
</tr>
<tr>
<td>BRAD</td>
<td>Genomics, Genetic Markers and Maps</td>
<td>Brassica</td>
<td><a target="_blank" rel="noopener" href="http://brassicadb.org/brad/">http://brassicadb.org/brad/</a></td>
</tr>
<tr>
<td>Ensembl Plants</td>
<td>Genomic</td>
<td>45 plant species</td>
<td><a target="_blank" rel="noopener" href="http://plants.ensembl.org/index.html">http://plants.ensembl.org/index.html</a></td>
</tr>
<tr>
<td>Ipomoea Genome Hub</td>
<td>Genomic, EST</td>
<td>Ipomoea batatas</td>
<td><a target="_blank" rel="noopener" href="https://ipomoea-genome.org/">https://ipomoea-genome.org/</a></td>
</tr>
<tr>
<td>PGSC</td>
<td>Genomic, annotation</td>
<td>S. tuberosum, S.chacoense</td>
<td><a target="_blank" rel="noopener" href="http://solanaceae.plantbiology.msu.edu/pgsc_download.shtml">http://solanaceae.plantbiology.msu.edu/pgsc_download.shtml</a></td>
</tr>
<tr>
<td>GDR</td>
<td>Genomics, Genetics, breeding</td>
<td>Rosaceae</td>
<td><a target="_blank" rel="noopener" href="https://www.rosaceae.org/analysis/266">https://www.rosaceae.org/analysis/266</a></td>
</tr>
<tr>
<td>HWG</td>
<td>Genomics, Transcriptomics, Genetic Markers</td>
<td>Forest trees and woody plants</td>
<td><a target="_blank" rel="noopener" href="https://www.hardwoodgenomics.org/">https://www.hardwoodgenomics.org/</a></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/10/09/%E3%80%8C%E6%96%87%E7%8C%AE%E3%80%8D%E5%A4%9A%E5%80%8D%E4%BD%93%E6%A4%8D%E7%89%A9%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%B5%8B%E5%BA%8F%E7%BB%84%E8%A3%85%E5%BD%93%E5%89%8D%E7%AD%96%E7%95%A5-Current-Strategies-of-Polyploid-Plant-Genome-Sequence-Assembly/" data-id="clm1xkn9n00f5dpni2kza2ws0" data-title="「文献」多倍体植物基因组测序组装当前策略" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-使用ASMap构建高密度遗传图谱-Build-high-density-genetic-map-with-ASMap" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/06/%E4%BD%BF%E7%94%A8ASMap%E6%9E%84%E5%BB%BA%E9%AB%98%E5%AF%86%E5%BA%A6%E9%81%97%E4%BC%A0%E5%9B%BE%E8%B0%B1-Build-high-density-genetic-map-with-ASMap/" class="article-date">
  <time class="dt-published" datetime="2019-10-06T17:03:13.955Z" itemprop="datePublished">2019-10-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/06/%E4%BD%BF%E7%94%A8ASMap%E6%9E%84%E5%BB%BA%E9%AB%98%E5%AF%86%E5%BA%A6%E9%81%97%E4%BC%A0%E5%9B%BE%E8%B0%B1-Build-high-density-genetic-map-with-ASMap/">使用ASMap构建高密度遗传图谱</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在我大学的时候，构建遗传图谱靠的是人工跑胶，然后看胶图统计基因型。当时我用的SSCP(单分子构象多态性)技术区分单个碱基存在差异的等位基因，要放在4度过夜12小时，然后第二天银染显色，放在一个医学看片的设备上读条带。</p>
<p>现在测序便宜了，简化基因组测序随随便便就能获得成千上万的分子标记。然而标记多有标记多的烦恼，就是以前的作图软件不好用了。以前的暴力穷举的方法在海量标记面前，几乎不可能在有限的时间里完成构图任务，而且更加麻烦的是高通量的SNP标记还容易出错。</p>
<p>R语言中有一些建图软件包，不过都有一些问题。<code>qtl</code>包的建图算法太老，<code>onemap</code>的算法是SERIATION, RECORD, RCD, UG, 但是代码不是C&#x2F;C++写的，所以运行速度太让人着急。</p>
<p>在2017年，出现了一个新的R包，ASMap，它其实就是将MSTmap移植到了R语言中。MSTmap是很久之前就提出的高通量作图方法，只不过需要编译，有点不太友好。</p>
<p>ASMap支持如下群体:</p>
<ul>
<li>BC: 回交群体</li>
<li>DH: 双单倍体群体</li>
<li>ARIL: 高世代重组近交系, 理论上是已经纯合的遗传群体(除了部分剩余杂合位点), 属于永久性群体</li>
<li>RILn: 低世代重组近交系，n&#x3D;2时，就是F2群体。</li>
</ul>
<p>算法说明简分为两个部分:</p>
<ul>
<li><p><strong>聚类算法</strong>: 如果分子标记 $m_j$ 和$m_k$ 来自于两个不同的连锁群，那么$P_{jk}&#x3D;0.5$, 并且标记间的加权距离(hamming distance)为 $E(d_{djk}) &#x3D; n&#x2F;2$。 根据定义，MSTmap使用<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hoeffding%27s_inequality">Hoeffding不等式</a>确定标记是否来自于同一个连锁群</p>
</li>
<li><p><strong>标记排序</strong>: 先根据遗传距离对标记进行分箱，也就是将共分离的标记当做一个对象。之后排序问题就视作 TSP(旅行商问题), 也就是寻找所有标记间最短的路径。</p>
</li>
</ul>
<h3 id="可用函数"><a href="#可用函数" class="headerlink" title="可用函数"></a>可用函数</h3><p>图谱构建函数: 一共有两个，注意p.value的调整</p>
<ul>
<li>mstmap.data.frame()</li>
<li>mstmap.cross(): 从qtl包的对象进行转换，对于高世代的RIL群体，要用<code>conver2riself</code>转换类型, 对于BCnFn群体要用<code>conver2bcsft</code>转换类型</li>
</ul>
<p>标记调整函数:</p>
<ul>
<li>pullCross(): 抽取异常分子标记</li>
<li>pushCross(): 检查完毕后，将符合要求的标记放回原处</li>
<li>pp.init(): 调整偏分离的阈值</li>
</ul>
<p>可视化诊断: </p>
<ul>
<li>profileGen():  统计基因型中交换数，双交换数，缺失情况。 适用于对遗传图谱质量进行评估</li>
<li>profileMark: 统计标记的偏分离，缺失比例，等位基因分布，双交换数</li>
<li>heatMap(): 以标记间RF(重组率)绘制热图</li>
</ul>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>内容翻译自: <em>R Package ASMap: Effcient Genetic Linkage Map Construction and Diagnosis</em></p>
<h4 id="第一步-环境准备"><a href="#第一步-环境准备" class="headerlink" title="第一步: 环境准备"></a>第一步: 环境准备</h4><p>加载环境和数据，其中数据集为300个群体，3023个标记的回交群体</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span><span class="string">&quot;qtl&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span><span class="string">&quot;ASMap&quot;</span><span class="punctuation">)</span></span><br><span class="line">data<span class="punctuation">(</span><span class="string">&quot;mapBCu&quot;</span><span class="punctuation">)</span></span><br><span class="line">summary<span class="punctuation">(</span>mapBCu<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>如果是自己的数据集，有两种方法可以构建，一种是用<code>mstmap.cross</code> 转换<code>qtl</code>包中<code>read.cross</code>得到的对象，如下</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mapthis <span class="operator">&lt;-</span> read.cross<span class="punctuation">(</span><span class="string">&quot;csv&quot;</span><span class="punctuation">,</span> <span class="string">&quot;http://www.rqtl.org/tutorials&quot;</span><span class="punctuation">,</span> <span class="string">&quot;mapthis.csv&quot;</span><span class="punctuation">,</span></span><br><span class="line">                      estimate.map<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">mapthis <span class="operator">&lt;-</span> convert2bcsft<span class="punctuation">(</span>mapthis<span class="punctuation">,</span> BC.gen <span class="operator">=</span> <span class="number">0</span><span class="punctuation">,</span> F.gen <span class="operator">=</span> <span class="number">2</span><span class="punctuation">,</span> estimate.map <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line">mapthis <span class="operator">&lt;-</span> mstmap.cross<span class="punctuation">(</span>mapthis<span class="punctuation">,</span> id <span class="operator">=</span> <span class="string">&quot;id&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>或者用<code>mstmap.data.frame</code>, 要调整如下的参数:</p>
<ul>
<li>object: 数据框, 行对应的标记名, 列是每个个体对应的基因型. <strong>注</strong>, 构建数据框时，一定要保证字符串不能被当做是因子(stringsAsFactors&#x3D;FALSE)。</li>
<li>pop.type: 群体类型，“BH”,”BC”, “RILn”(低世代的近交系,RIL2可以认为是F2), “ARIL”(高世代的近交系)</li>
<li>dist.fun: 计算遗传距离的函数, 默认是”kosambi”, 不需要更改。</li>
<li>p.value: 和群体大小有关，群体越大，p值要越小，也就是要更严格。</li>
</ul>
<blockquote>
<p>对于低世代的近交系，亲本基因型编码为”A”或”a”, “B”或”b”, 杂合基因型编码为”X”. 所谓的缺失值编码为”U”或”-“</p>
</blockquote>
<p><code>mstmap.data.frame</code>这一步运行会比较慢，这是由于它会预先对数据进行分箱，减少标记量，提高后续的运算效率。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-ad1e894f837bc6bf-d81b41040f9046dcb12319381ebf878a.png" alt="运行案例"></p>
<h4 id="第二步-预处理"><a href="#第二步-预处理" class="headerlink" title="第二步: 预处理"></a>第二步: 预处理</h4><p>在正式构建遗传图谱之间，我们需要谨慎的按照如下清单检查我们用于构图的基因型&#x2F;分子标记的质量，包括但不限于</p>
<ul>
<li>检查每个个体对应的标记缺失比例，以及每个标记在所有个体中的缺失失比例。缺失比例过高说明标记或个体存在问题</li>
<li>检查群体间是否存在标记高度相似的两个个体。</li>
<li>检查过度偏分离(segregation distortion)的标记。 高度偏分离的标记可能不会定位到唯一的座位上。</li>
<li>检查交换等位基因的标记。这些标记在构建图谱期间，难以聚类，或者和其他标记有关联，因此需要在分析前修复他们的匹配。</li>
<li>检查共分离的标记。 共分离的标记会严重影响构图时的计算效率，所以可以先暂时把它们忽略掉。</li>
</ul>
<p>检查每个个体的基因型缺失情况</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plot.missing<span class="punctuation">(</span>mapBcu<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-22c2c7322e096282-d319341714d84b26b8003d08c476da91.png" alt="缺失分布"></p>
<p>水平的黑线表示一些个体中，大部分的标记都没有对应的基因型，因此我们将这些个体移除。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sg <span class="operator">&lt;-</span> statGen<span class="punctuation">(</span>mapBCu<span class="punctuation">,</span> bychr<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">,</span> stat.type <span class="operator">=</span> <span class="string">&quot;miss&quot;</span><span class="punctuation">)</span></span><br><span class="line">mapBC1 <span class="operator">&lt;-</span> subset<span class="punctuation">(</span>mapBCu<span class="punctuation">,</span> ind<span class="operator">=</span>sg<span class="operator">$</span>miss <span class="operator">&lt;</span> <span class="number">1600</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>从图谱构建的角度来看，高度相关的个体会增强标记的偏分离. 因此对于基因型几乎一模一样的个体，最好在建立图谱前移除</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gc <span class="operator">&lt;-</span> genClones<span class="punctuation">(</span>mapBC1<span class="punctuation">,</span> tol<span class="operator">=</span><span class="number">0.95</span><span class="punctuation">)</span></span><br><span class="line">gc<span class="operator">$</span>cgd</span><br></pre></td></tr></table></figure>

<p>从R返回的结果中，可以发现有将近11组的基因型几乎一样。但是第一组的BC045和BC039由于存在大量的基因型缺失，不足以说明两者相同，同样情况的还有BC052和BC045,以及BC168和BC045, 可以排除这三项。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cgd <span class="operator">&lt;-</span> gc<span class="operator">$</span>cgd<span class="punctuation">[</span><span class="operator">-</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">,</span><span class="number">5</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">mapBC2 <span class="operator">&lt;-</span> fixClones<span class="punctuation">(</span>mapBC1<span class="punctuation">,</span> cgd<span class="punctuation">,</span> consensus <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>接下来，可以进一步检查特定位点的观测等位基因频率和期望频率的偏差。这有可能是<strong>基因型考察错误</strong>，也有可能意味着该区域受到<strong>潜在的生物学和遗传学机制</strong>影响。这一步，同时检查分子标记的偏分离情况，不同基因型的占比，和缺失率。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">profileMark<span class="punctuation">(</span>mapBC2<span class="punctuation">,</span> stat.type <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;seg.dist&quot;</span><span class="punctuation">,</span> <span class="string">&quot;prop&quot;</span><span class="punctuation">,</span><span class="string">&quot;miss&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">            crit.val <span class="operator">=</span> <span class="string">&quot;bonf&quot;</span><span class="punctuation">,</span> layout <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">4</span><span class="punctuation">)</span><span class="punctuation">,</span> type<span class="operator">=</span><span class="string">&quot;l&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-1efac32ed7ebb769-a00a8710ac764a4c974c690cb4b9d951.png" alt="基因型总体情况"></p>
<p>对于高度的偏分离的标记，我们应该直接忽略掉</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mm <span class="operator">&lt;-</span> statMark<span class="punctuation">(</span>mapBC2<span class="punctuation">,</span> stat.type <span class="operator">=</span> <span class="string">&quot;marker&quot;</span><span class="punctuation">)</span><span class="operator">$</span>marker<span class="operator">$</span>AB</span><br><span class="line">dm <span class="operator">&lt;-</span> markernames<span class="punctuation">(</span>mapBC2<span class="punctuation">)</span><span class="punctuation">[</span><span class="punctuation">(</span>mm <span class="operator">&gt;</span> <span class="number">0.98</span><span class="punctuation">)</span> <span class="operator">|</span> <span class="punctuation">(</span>mm <span class="operator">&lt;</span> <span class="number">0.2</span><span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line">mapBC3 <span class="operator">&lt;-</span> drop.markers<span class="punctuation">(</span>mapBC2<span class="punctuation">,</span> dm<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>而对于不偏分离不怎么严重的标记，最好的方法是先把他们放在一边，等图谱构建完成之后再把它们放回到遗传图谱中。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pp <span class="operator">&lt;-</span> pp.init<span class="punctuation">(</span>miss.thresh <span class="operator">=</span> <span class="number">0.1</span><span class="punctuation">,</span> seg.thresh <span class="operator">=</span> <span class="string">&quot;bonf&quot;</span><span class="punctuation">)</span></span><br><span class="line">mapBC3 <span class="operator">&lt;-</span> pullCross<span class="punctuation">(</span>mapBC3<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;missing&quot;</span><span class="punctuation">,</span> pars<span class="operator">=</span>pp<span class="punctuation">)</span></span><br><span class="line">mapBC3 <span class="operator">&lt;-</span> pullCross<span class="punctuation">(</span>mapBC3<span class="punctuation">,</span> type<span class="operator">=</span><span class="string">&quot;seg.distortion&quot;</span><span class="punctuation">,</span> pars<span class="operator">=</span>pp<span class="punctuation">)</span></span><br><span class="line">mapBC3 <span class="operator">&lt;-</span> pullCross<span class="punctuation">(</span>mapBC3<span class="punctuation">,</span> type<span class="operator">=</span><span class="string">&quot;co.located&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<h4 id="第三步-构图"><a href="#第三步-构图" class="headerlink" title="第三步: 构图"></a>第三步: 构图</h4><p>构图通常不是一次性完成的工作，需要多次迭代。先进行第一次尝试，运行时间取决于计算机性能和标记数目</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mapBC4 <span class="operator">&lt;-</span> mstmap<span class="punctuation">(</span>mapBC3<span class="punctuation">,</span> bychr <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> trace <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> p.value <span class="operator">=</span> <span class="number">1e-12</span><span class="punctuation">)</span></span><br><span class="line">chrlen<span class="punctuation">(</span>mapBC4<span class="punctuation">)</span> <span class="comment">#每个连锁群的长度</span></span><br></pre></td></tr></table></figure>

<p>对构建出图谱进行可视化检查</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">heatMap<span class="punctuation">(</span>mapBC4<span class="punctuation">,</span> lmax <span class="operator">=</span> <span class="number">70</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-69c90cc209e6bd42-6f3e0572c8a745e2ba51beaca2948b09.png" alt="热图"></p>
<p>热图分为两个部分看。上三角展示的是标记间的重组率，下三角则是标记间的LOD值，两者模式要是一样，那就说明图谱还是靠谱的。中间的正方形为连锁不平衡区(LD block), 一般在连锁不平衡区极少发生交换，而不同的连锁不平衡区交换频繁。</p>
<p>但是光看热图还是不够的，我们还得保证遗传图谱里个体的交换次数不应该太多。也就是，每个个体能发生的交换是有限的，比如说如果染色体长度为200cM，那么在回交后代中，每个个体的重组次数应该不多于14次。</p>
<blockquote>
<p>水稻每条染色体平均0.5~1次交换。人类每次减数分裂平均30次。</p>
</blockquote>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pg <span class="operator">&lt;-</span> profileGen<span class="punctuation">(</span>mapBC4<span class="punctuation">,</span> bychr <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> stat.type <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;xo&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dxo&quot;</span><span class="punctuation">,</span> <span class="string">&quot;miss&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                 id<span class="operator">=</span><span class="string">&quot;Genotype&quot;</span><span class="punctuation">,</span> xo.lambda <span class="operator">=</span> <span class="number">14</span><span class="punctuation">,</span> layout<span class="operator">=</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span>lty<span class="operator">=</span><span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-610dda9e54155b86-f8545e5d22724effa9f263d737bbd37e.png" alt="交换数分析"></p>
<p>从上图可以发现，一些个体的重组次数明显过高，而且这些个体的双交换次数明显多于其他个体，缺失率也是如此。</p>
<p>我们需要将这些个体剔除，对遗传图谱进行升级</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mapBC5 <span class="operator">&lt;-</span> subsetCross<span class="punctuation">(</span>mapBC4<span class="punctuation">,</span> ind <span class="operator">=</span> <span class="operator">!</span>pg<span class="operator">$</span>xo.lambda<span class="punctuation">)</span></span><br><span class="line">mapBC6 <span class="operator">&lt;-</span> mstmap<span class="punctuation">(</span>mapBC5<span class="punctuation">,</span> bychr <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> trace <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> p.value <span class="operator">=</span> <span class="number">1e-12</span><span class="punctuation">)</span></span><br><span class="line">chrlen<span class="punctuation">(</span>mapBC6<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>和上次相比，每个连锁群的长度明显减少，一般而言遗传图谱越小，图谱越可靠。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">profileMark<span class="punctuation">(</span>mapBC6<span class="punctuation">,</span> stat.type <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;seg.dist&quot;</span><span class="punctuation">,</span> <span class="string">&quot;prop&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dxo&quot;</span><span class="punctuation">,</span> <span class="string">&quot;recomb&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">            layout <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;l&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-d926007182146247-ebc143a4f0094c2195f53cb507c5d904.png" alt="交换数分析"></p>
<p>最后结果表明，每个个体的双交换次数都没有超过1 个。</p>
<h4 id="第四步-加入前提剔除的标记"><a href="#第四步-加入前提剔除的标记" class="headerlink" title="第四步: 加入前提剔除的标记"></a>第四步: 加入前提剔除的标记</h4><p>对于前期放在一边的标记，可以在图谱构建完成后放回到完成的图谱中，同时要仔细的检查。</p>
<p>先将515个缺失率在10%~20%的标记塞到图谱上。这一步是将当前的标记和图谱上的标记计算重组率，选择最近位置插入。然后展示长度明显小于其他连锁群的4个连锁群，判断是否能够将他们进行合并。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pp <span class="operator">&lt;-</span> pp.init<span class="punctuation">(</span>miss.thresh <span class="operator">=</span> <span class="number">0.22</span><span class="punctuation">,</span> max.rf <span class="operator">=</span> <span class="number">0.3</span><span class="punctuation">)</span></span><br><span class="line">mapBC6 <span class="operator">&lt;-</span> pushCross<span class="punctuation">(</span>mapBC6<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;missing&quot;</span><span class="punctuation">,</span> pars <span class="operator">=</span> pp<span class="punctuation">)</span></span><br><span class="line">heatMap<span class="punctuation">(</span>mapBC6<span class="punctuation">,</span> chr <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;L.3&quot;</span><span class="punctuation">,</span> <span class="string">&quot;L.5&quot;</span><span class="punctuation">,</span> <span class="string">&quot;L.8&quot;</span><span class="punctuation">,</span> <span class="string">&quot;L.9&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> lmax <span class="operator">=</span> <span class="number">70</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-ce51881d19790f5c-1635ca96e79c46fa87b01cb2c1877356.png" alt="热图诊断"></p>
<p>从图中，我们可以发现，L.3和L.5之间有明显的连锁，L8和L.9有明显的连锁。我们使用<code>mergeCross()</code>将这两个连锁群进行合并，这个时候的<code>mstmap</code>要保证<code>bychr=TRUE</code>, 对不同的连锁群分别计算标记距离，而不是从聚类开始。</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mlist <span class="operator">&lt;-</span> <span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;L.3&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;L.3&quot;</span><span class="punctuation">,</span> <span class="string">&quot;L.5&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;L.8&quot;</span> <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;L.8&quot;</span><span class="punctuation">,</span> <span class="string">&quot;L.9&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">mapBC6 <span class="operator">&lt;-</span> mergeCross<span class="punctuation">(</span>mapBC6<span class="punctuation">,</span> merge <span class="operator">=</span> mlist<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>mapBC6<span class="operator">$</span>geno<span class="punctuation">)</span> <span class="operator">&lt;-</span> paste<span class="punctuation">(</span><span class="string">&quot;L.&quot;</span><span class="punctuation">,</span> <span class="number">1</span><span class="operator">:</span><span class="number">7</span><span class="punctuation">,</span> sep <span class="operator">=</span> <span class="string">&quot;&quot;</span><span class="punctuation">)</span></span><br><span class="line">mapBC7 <span class="operator">&lt;-</span> mstmap<span class="punctuation">(</span>mapBC6<span class="punctuation">,</span> bychr <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> trace <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> p.value <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">chrlen<span class="punctuation">(</span>mapBC7<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>这样子就得到了更加优化的图谱。但是L1, L2, L.4的连锁群距离有一些轻微的提高，说明可能存在过多的交换现象</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pg1 <span class="operator">&lt;-</span> profileGen<span class="punctuation">(</span>mapBC7<span class="punctuation">,</span> bychr <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">,</span> stat.type <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;xo&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dxo&quot;</span><span class="punctuation">,</span><span class="string">&quot;miss&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                  id <span class="operator">=</span> <span class="string">&quot;Genotype&quot;</span><span class="punctuation">,</span> xo.lambda <span class="operator">=</span> <span class="number">14</span><span class="punctuation">,</span> layout <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> lty <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-d3416167e333d503-2784180654e141a1a7ed3e26d46862d5.png" alt="交换分析"></p>
<p>我们发现新引入的部分个体是导致该现象的元凶，这就需要我们将这些株系次移除掉，然后重建图谱</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mapBC8 <span class="operator">&lt;-</span> subsetCross<span class="punctuation">(</span>mapBC7<span class="punctuation">,</span> ind<span class="operator">=</span><span class="operator">!</span>pg1<span class="operator">$</span>xo.lambda<span class="punctuation">)</span></span><br><span class="line">mapBC9 <span class="operator">&lt;-</span> mstmap<span class="punctuation">(</span>mapBC8<span class="punctuation">,</span> bychr <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> trace <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> p.value <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">chrlen<span class="punctuation">(</span>mapBC9<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>移除的株系不会对连锁群的数目造成影响，连锁图谱只会在组内进行重建。大部分连锁群的长度都有了一定程度的下降。继续观察一下标记的遗传图谱的表现情况</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">profileMark<span class="punctuation">(</span>mapBC9<span class="punctuation">,</span> stat.type <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;seg.dist&quot;</span><span class="punctuation">,</span> <span class="string">&quot;prop&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> layout <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">            type <span class="operator">=</span> <span class="string">&quot;l&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-3e48bdf7c43a5dba-c5573d9940e94409b5ce3b28414f23f5.png" alt="频率变化"></p>
<p>从图中可以发现，在L.2里面有一个诡异的突起(偏分离), 需要被移除。当然我们也能看到在L.3, L.5, L.7中，新增的缺失率10%~20%的标记，有一定程度的偏分离。剩下的295个标记为”seg.distortion”的标记说不定能解释这个情况，所以下一步就是把它们塞回去</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sm <span class="operator">&lt;-</span> statMark<span class="punctuation">(</span>mapBC9<span class="punctuation">,</span> chr <span class="operator">=</span> <span class="string">&quot;L.2&quot;</span><span class="punctuation">,</span> stat.type <span class="operator">=</span> <span class="string">&quot;marker&quot;</span><span class="punctuation">)</span></span><br><span class="line">dm <span class="operator">&lt;-</span> markernames<span class="punctuation">(</span>mapBC9<span class="punctuation">,</span> <span class="string">&quot;L.2&quot;</span><span class="punctuation">)</span><span class="punctuation">[</span>sm<span class="operator">$</span>marker<span class="operator">$</span>neglog10P <span class="operator">&gt;</span> <span class="number">6</span><span class="punctuation">]</span></span><br><span class="line">mapBC10 <span class="operator">&lt;-</span> drop.markers<span class="punctuation">(</span>mapBC9<span class="punctuation">,</span> dm<span class="punctuation">)</span></span><br><span class="line">pp <span class="operator">&lt;-</span> pp.init<span class="punctuation">(</span>seg.ratio <span class="operator">=</span> <span class="string">&quot;70:30&quot;</span><span class="punctuation">)</span></span><br><span class="line">mapBC11 <span class="operator">&lt;-</span> pushCross<span class="punctuation">(</span>mapBC10<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;seg.distortion&quot;</span><span class="punctuation">,</span> pars <span class="operator">=</span> pp<span class="punctuation">)</span></span><br><span class="line">mapBC12 <span class="operator">&lt;-</span> mstmap<span class="punctuation">(</span>mapBC11<span class="punctuation">,</span> bychr <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> trace <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">,</span> p.value <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">round</span><span class="punctuation">(</span>chrlen<span class="punctuation">(</span>mapBC12<span class="punctuation">)</span> <span class="operator">-</span> chrlen<span class="punctuation">(</span>mapBC9<span class="punctuation">)</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line">nmar<span class="punctuation">(</span>mapBC12<span class="punctuation">)</span> <span class="operator">-</span> nmar<span class="punctuation">(</span>mapBC10<span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>最后一步就是加入共分离的标记</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapBC <span class="operator">&lt;-</span> pushCross<span class="punctuation">(</span>mapBC12<span class="punctuation">,</span> type <span class="operator">=</span> <span class="string">&quot;co.located&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>最后结果如下</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/10/2013053-a0b8dbb07f72bbb9-ad71118e0ff44791977a31cacc9bf118.png" alt="结果统计"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/10/06/%E4%BD%BF%E7%94%A8ASMap%E6%9E%84%E5%BB%BA%E9%AB%98%E5%AF%86%E5%BA%A6%E9%81%97%E4%BC%A0%E5%9B%BE%E8%B0%B1-Build-high-density-genetic-map-with-ASMap/" data-id="clm1xkn570005dpni4edt5sap" data-title="使用ASMap构建高密度遗传图谱" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/NGS/" rel="tag">NGS</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/17/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/19/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/R/">R</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/">基因组学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/">数据科学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/">文献阅读</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%87%E7%AB%A0%E9%87%8D%E7%8E%B0/">文章重现</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1-%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/">生信软件工具箱 | 基因组学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E5%AD%A6/">转录组学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ATAC-seq-%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">ATAC-seq | 单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ATAC-seq-%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90/" rel="tag">ATAC-seq | 差异分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ATAC-seq-%E8%A1%A8%E8%A7%82%E7%BB%84-ChIP-seq/" rel="tag">ATAC-seq | 表观组 | ChIP-seq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ATAC-seq-%E8%A1%A8%E8%A7%82%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">ATAC-seq | 表观组 | 单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BigWig/" rel="tag">BigWig</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BioNano/" rel="tag">BioNano</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/" rel="tag">C&#x2F;C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C-%E7%AE%97%E6%B3%95/" rel="tag">C&#x2F;C++ | 算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ChIP-seq/" rel="tag">ChIP-seq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub/" rel="tag">GitHub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hi-C/" rel="tag">Hi-C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JCVI/" rel="tag">JCVI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MacOS/" rel="tag">MacOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NGS/" rel="tag">NGS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NGS-%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" rel="tag">NGS | 遗传定位</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBMC/" rel="tag">PBMC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Perl-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" rel="tag">Perl | 软件安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT-MSVC/" rel="tag">QT | MSVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Seurat/" rel="tag">Seurat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Seurat-%E5%8D%95%E7%BB%86%E8%83%9E-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" rel="tag">Seurat | 单细胞 | 数据挖掘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Seurat-%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">Seurat | 转录组 | 单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%BC%80%E5%8F%91/" rel="tag">Web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zotero-%E6%96%87%E7%8C%AE-%E5%9D%9A%E6%9E%9C%E4%BA%91/" rel="tag">Zotero | 文献 | 坚果云</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/biocondutor/" rel="tag">biocondutor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/conda/" rel="tag">conda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/samtools/" rel="tag">samtools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typora/" rel="tag">typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" rel="tag">个人博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="tag">可视化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-CIRCOS/" rel="tag">可视化 | CIRCOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-JCVI/" rel="tag">可视化 | JCVI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">可视化 | 单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-%E6%AF%94%E8%BE%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/" rel="tag">可视化 | 比较基因组学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F/" rel="tag">基因家族</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E5%9B%A0%E7%BB%84/" rel="tag">基因组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7-SSH/" rel="tag">小技巧 | SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" rel="tag">序列比对</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" rel="tag">数据挖掘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-C/" rel="tag">数据结构 | C&#x2F;C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/" rel="tag">正则表达式 | 字符串处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AF%94%E8%BE%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/" rel="tag">比较基因组学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B0%B4%E7%A8%BB-%E8%BD%AC%E5%BD%95%E7%BB%84/" rel="tag">水稻 | 转录组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B0%B4%E7%A8%BB-%E8%BD%AC%E5%BD%95%E7%BB%84-%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" rel="tag">水稻 | 转录组 | 遗传定位</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A/" rel="tag">注释</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-MAKER/" rel="tag">注释 | MAKER</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" rel="tag">注释 | 序列比对</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7/" rel="tag">注释 | 流程工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-MAKER/" rel="tag">注释 | 流程工具 | MAKER</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" rel="tag">注释 | 重复序列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7/" rel="tag">流程工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F/" rel="tag">流程工具 | 基因家族</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">流程工具 | 服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" rel="tag">源码解读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-hash/" rel="tag">源码解读 | hash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" rel="tag">环境变量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-WSL/" rel="tag">环境配置 | WSL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E5%8F%91%E8%82%B2/" rel="tag">系统发育</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E8%A3%85/" rel="tag">组装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E8%A3%85-Hi-C/" rel="tag">组装 | Hi-C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E8%A3%85-%E8%BD%AC%E5%BD%95%E7%BB%84-%E6%B3%A8%E9%87%8A/" rel="tag">组装 | 转录组 | 注释</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">自然语言 | 深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A1%A8%E8%A7%82%E7%BB%84/" rel="tag">表观组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag">读书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84/" rel="tag">转录组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">转录组 | 单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90-TCGA/" rel="tag">转录组 | 差异分析 | TCGA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" rel="tag">转录组 | 序列比对</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" rel="tag">软件安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" rel="tag">遗传定位</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" rel="tag">重复序列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/ATAC-seq-%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 20px;">ATAC-seq | 单细胞</a> <a href="/tags/ATAC-seq-%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90/" style="font-size: 10px;">ATAC-seq | 差异分析</a> <a href="/tags/ATAC-seq-%E8%A1%A8%E8%A7%82%E7%BB%84-ChIP-seq/" style="font-size: 10px;">ATAC-seq | 表观组 | ChIP-seq</a> <a href="/tags/ATAC-seq-%E8%A1%A8%E8%A7%82%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 10px;">ATAC-seq | 表观组 | 单细胞</a> <a href="/tags/BigWig/" style="font-size: 10px;">BigWig</a> <a href="/tags/BioNano/" style="font-size: 10px;">BioNano</a> <a href="/tags/C-C/" style="font-size: 19px;">C/C++</a> <a href="/tags/C-C-%E7%AE%97%E6%B3%95/" style="font-size: 10px;">C/C++ | 算法</a> <a href="/tags/ChIP-seq/" style="font-size: 10px;">ChIP-seq</a> <a href="/tags/GitHub/" style="font-size: 11px;">GitHub</a> <a href="/tags/Hi-C/" style="font-size: 10px;">Hi-C</a> <a href="/tags/JCVI/" style="font-size: 10px;">JCVI</a> <a href="/tags/MacOS/" style="font-size: 16px;">MacOS</a> <a href="/tags/NGS/" style="font-size: 11px;">NGS</a> <a href="/tags/NGS-%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">NGS | 遗传定位</a> <a href="/tags/PBMC/" style="font-size: 10px;">PBMC</a> <a href="/tags/Perl-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" style="font-size: 10px;">Perl | 软件安装</a> <a href="/tags/QT-MSVC/" style="font-size: 10px;">QT | MSVC</a> <a href="/tags/Seurat/" style="font-size: 10px;">Seurat</a> <a href="/tags/Seurat-%E5%8D%95%E7%BB%86%E8%83%9E-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" style="font-size: 10px;">Seurat | 单细胞 | 数据挖掘</a> <a href="/tags/Seurat-%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 10px;">Seurat | 转录组 | 单细胞</a> <a href="/tags/Web%E5%BC%80%E5%8F%91/" style="font-size: 11px;">Web开发</a> <a href="/tags/Zotero-%E6%96%87%E7%8C%AE-%E5%9D%9A%E6%9E%9C%E4%BA%91/" style="font-size: 11px;">Zotero | 文献 | 坚果云</a> <a href="/tags/biocondutor/" style="font-size: 10px;">biocondutor</a> <a href="/tags/conda/" style="font-size: 11px;">conda</a> <a href="/tags/samtools/" style="font-size: 10px;">samtools</a> <a href="/tags/typora/" style="font-size: 10px;">typora</a> <a href="/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">个人博客</a> <a href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 13px;">单细胞</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/" style="font-size: 12px;">可视化</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-CIRCOS/" style="font-size: 14px;">可视化 | CIRCOS</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-JCVI/" style="font-size: 12px;">可视化 | JCVI</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 10px;">可视化 | 单细胞</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-%E6%AF%94%E8%BE%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/" style="font-size: 10px;">可视化 | 比较基因组学</a> <a href="/tags/%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F/" style="font-size: 11px;">基因家族</a> <a href="/tags/%E5%9F%BA%E5%9B%A0%E7%BB%84/" style="font-size: 11px;">基因组</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 17px;">小技巧</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7-SSH/" style="font-size: 10px;">小技巧 | SSH</a> <a href="/tags/%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" style="font-size: 10px;">序列比对</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" style="font-size: 11px;">数据挖掘</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12px;">数据结构</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-C/" style="font-size: 16px;">数据结构 | C/C++</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 12px;">服务器</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/" style="font-size: 10px;">正则表达式 | 字符串处理</a> <a href="/tags/%E6%AF%94%E8%BE%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/" style="font-size: 10px;">比较基因组学</a> <a href="/tags/%E6%B0%B4%E7%A8%BB-%E8%BD%AC%E5%BD%95%E7%BB%84/" style="font-size: 10px;">水稻 | 转录组</a> <a href="/tags/%E6%B0%B4%E7%A8%BB-%E8%BD%AC%E5%BD%95%E7%BB%84-%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">水稻 | 转录组 | 遗传定位</a> <a href="/tags/%E6%B3%A8%E9%87%8A/" style="font-size: 12px;">注释</a> <a href="/tags/%E6%B3%A8%E9%87%8A-MAKER/" style="font-size: 13px;">注释 | MAKER</a> <a href="/tags/%E6%B3%A8%E9%87%8A-%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" style="font-size: 10px;">注释 | 序列比对</a> <a href="/tags/%E6%B3%A8%E9%87%8A-%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">注释 | 流程工具</a> <a href="/tags/%E6%B3%A8%E9%87%8A-%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-MAKER/" style="font-size: 10px;">注释 | 流程工具 | MAKER</a> <a href="/tags/%E6%B3%A8%E9%87%8A-%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" style="font-size: 12px;">注释 | 重复序列</a> <a href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7/" style="font-size: 17px;">流程工具</a> <a href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F/" style="font-size: 10px;">流程工具 | 基因家族</a> <a href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">流程工具 | 服务器</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">深度学习</a> <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" style="font-size: 10px;">源码解读</a> <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-hash/" style="font-size: 10px;">源码解读 | hash</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 10px;">爬虫</a> <a href="/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" style="font-size: 10px;">环境变量</a> <a href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-WSL/" style="font-size: 10px;">环境配置 | WSL</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 11px;">算法</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E5%8F%91%E8%82%B2/" style="font-size: 12px;">系统发育</a> <a href="/tags/%E7%BB%84%E8%A3%85/" style="font-size: 18px;">组装</a> <a href="/tags/%E7%BB%84%E8%A3%85-Hi-C/" style="font-size: 16px;">组装 | Hi-C</a> <a href="/tags/%E7%BB%84%E8%A3%85-%E8%BD%AC%E5%BD%95%E7%BB%84-%E6%B3%A8%E9%87%8A/" style="font-size: 10px;">组装 | 转录组 | 注释</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 11px;">编程语言</a> <a href="/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 11px;">自然语言 | 深度学习</a> <a href="/tags/%E8%A1%A8%E8%A7%82%E7%BB%84/" style="font-size: 10px;">表观组</a> <a href="/tags/%E8%AF%BB%E4%B9%A6/" style="font-size: 11px;">读书</a> <a href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84/" style="font-size: 11px;">转录组</a> <a href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 11px;">转录组 | 单细胞</a> <a href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90-TCGA/" style="font-size: 10px;">转录组 | 差异分析 | TCGA</a> <a href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" style="font-size: 10px;">转录组 | 序列比对</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" style="font-size: 15px;">软件安装</a> <a href="/tags/%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">遗传定位</a> <a href="/tags/%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" style="font-size: 12px;">重复序列</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/02/%E5%A6%82%E4%BD%95%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8D%E5%86%8D%E9%BE%9F%E9%80%9F%E4%B8%8B%E8%BD%BDgithub%E7%9A%84%E6%95%B0%E6%8D%AE/">如何让服务器不再龟速下载github的数据</a>
          </li>
        
          <li>
            <a href="/2023/08/27/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E5%AE%B9%E5%99%A8singularity/">编译安装容器singularity</a>
          </li>
        
          <li>
            <a href="/2023/08/25/%E5%85%B3%E4%BA%8E%E7%94%B3%E8%AF%B7OpenAI%E7%9A%84API%E7%9A%84%E5%87%A0%E7%82%B9%E8%A1%A5%E5%85%85/">关于申请OpenAI的API的几点补充</a>
          </li>
        
          <li>
            <a href="/2023/08/18/%E4%BB%8Ehalo%E8%BF%81%E7%A7%BB%E5%88%B0hexo/">从halo迁移到hexo</a>
          </li>
        
          <li>
            <a href="/2023/06/24/Oatk%EF%BC%9A%E5%88%A9%E7%94%A8HiFi%20Read%E8%BF%9B%E8%A1%8C%E7%BB%86%E8%83%9E%E5%99%A8%E7%BB%84%E8%A3%85-oatk-assembly-of-organelles-using-hifi-read/">Oatk：利用HiFi Read进行细胞器组装</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 xuzhougeng<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>