<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>洲更的第二大脑</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="洲更的第二大脑">
<meta property="og:url" content="http://xuzhougeng.top/page/21/index.html">
<meta property="og:site_name" content="洲更的第二大脑">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="xuzhougeng">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="洲更的第二大脑" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">洲更的第二大脑</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xuzhougeng.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-三代组装软件miniasm笔记-Assemble-nanopore-using-minimap-and-miniasm" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/29/%E4%B8%89%E4%BB%A3%E7%BB%84%E8%A3%85%E8%BD%AF%E4%BB%B6miniasm%E7%AC%94%E8%AE%B0-Assemble-nanopore-using-minimap-and-miniasm/" class="article-date">
  <time class="dt-published" datetime="2019-08-29T22:50:12.814Z" itemprop="datePublished">2019-08-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/29/%E4%B8%89%E4%BB%A3%E7%BB%84%E8%A3%85%E8%BD%AF%E4%BB%B6miniasm%E7%AC%94%E8%AE%B0-Assemble-nanopore-using-minimap-and-miniasm/">三代组装软件miniasm笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>我们用来练手的文章发表在 <em>Nature Communication</em> ，”High contiguity Arabidopsis thaliana genome assembly with a single nanopore flow cell”, 非常不要脸的说，这篇文章是我师爷实验室发的。</p>
<p>简单讲讲故事内容，就是他们实验室买了一台nanopore仪器，就是下面这台， 目前仪器价格国内是8K左右，当然测序的价格就另说了。如同买台PS4主机，还要买游戏，买个单反，你还得买镜头。仪器只是败家的开始！</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-ada4497b7b113f99-90a7dabd172345d7bfb5087f9b4b9587.png" alt="nanopore"></p>
<p>他们认为三代测序目前有两大问题，测的还不够长以及不够准。nanopore解决了其中一个问题，不够长。<em>Arabidopsis thaliana</em> 当年用一代测序，虽然可以认为是组装的金标准了，但是还是有很多区域是BAC连BAC文库搞不定的，所以就用这台仪器把 <em>Arabidopsis thaliana</em> 测了一波。显然就测一个nanopore，还是已知序列的物种是不可能发文章的，于是他们又用Pacbio sequel测了一波。最后用bionano 光学图谱验证了一次(请大家自行计算要多少钱)。</p>
<p>光测序不行，还得组装对吧。传统的组装方法是想办法利用高深度和随机错误进行纠错，然后用纠错后的长序列进行组装，最后用二代进行纠错。对于一台不错的服务器（20W起步吧）大约花个十天半个月就行。作者或许认为买一台20多w的外设配合不到1w的测序仪可能是太蠢了，于是他用了比较Li Heng大神开发的工具，Minimap+miniasm进行组装，然后用racon+pillon进行纠错，用了一台Macbook Pro 15.6寸花了4天就搞定了，并且和常规工具比较，还算过得去哦。</p>
<p>下面就是正式的分析：</p>
<p>根据文章提供的项目编号”PRJEB21270”, 在European Nucleotide Archive上找到下载地址。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-57cf8b9704a5c90d-154ad858607d49858f55d5ab0905be20.png" alt="ENA搜索"></p>
<p>进入这个页面之后，就可以去下载作者用到的所有数据，我们下载Sequel和MinIon和Illuminia的数据就好了，数据量加起来差不多30G。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Sequal</span></span><br><span class="line">wget -c -q ftp://ftp.sra.ebi.ac.uk/vol1/ERA111/ERA1116568/bam/pb.bam</span><br><span class="line">wget -c -q ftp://ftp.sra.ebi.ac.uk/vol1/ERA111/ERA1116568/bam/pb.bam.bai</span><br><span class="line"><span class="comment">## MinION</span></span><br><span class="line">wget -c -q ftp://ftp.sra.ebi.ac.uk/vol1/ERA111/ERA1116595/fastq/ont.fq.gz</span><br></pre></td></tr></table></figure>

<p>对于Illumina的二代测序，需要用prefetch进行下载</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Illuminia MiSeq</span></span><br><span class="line">prefetch ERR2173372</span><br><span class="line">fasterq-dump -O  . ERR2173372</span><br></pre></td></tr></table></figure>

<p>拿到数据之后，我们就可以用作者提供的分析流程进行重复了。地址为<a target="_blank" rel="noopener" href="https://github.com/fbemm/onefc-oneasm/wiki/Assembly-Generation">https://github.com/fbemm/onefc-oneasm/wiki/Assembly-Generation</a></p>
<blockquote>
<p>这就是大神的自信，把代码都给你，反正你也看不懂。当然我在重复的时候用的都是最新的软件，所以会有所不同</p>
</blockquote>
<p>第一步：拿着80%～90%正确率的原始数据相互比对， 找序列之间的Overlap。这一步，我花了30分钟</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time ~/opt/biosoft/minimap2/minimap2 -t 10 -x ava-ont ont.fq ont.fq &gt; gzip -1 ont.paf.gz &amp;</span><br></pre></td></tr></table></figure>

<p>第二步：找到Overlap，就能够进行组装了。这一步我花了2分钟</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time ~/opt/biosoft/miniasm/miniasm -f ont.fq ont.paf &gt; ONTmin.gfa &amp;</span><br><span class="line">awk <span class="string">&#x27;/^S/&#123;print &quot;&gt;&quot;$2&quot;\n&quot;$3&#125;&#x27;</span> ONTmin.gfa | seqkit <span class="built_in">seq</span> &gt; ONTmin_IT0.fasta &amp;</span><br></pre></td></tr></table></figure>

<p>第三步： 原始的组装结果充满了错误，所以需要进行纠错。纠错分为两种，一种是用三代自身数据，一种是用二代数据进行纠错。当然这两步都是需要的</p>
<p>首先使用三代数据进行纠错，古语有云“事不过三”一般迭代个三次就差不多。这三步，差不多用了1个小时。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Iteration 1</span></span><br><span class="line">~/opt/biosoft/minimap2/minimap2 ONTmin_IT0.fasta ont.fq &gt; ONTmin_IT0.paf &amp;</span><br><span class="line">time ~/opt/biosoft/racon/build/bin/racon -t 10 ont.fq ONTmin_IT0.paf ONTmin_IT0.fasta &gt; ONTmin_IT1.fasta &amp;</span><br><span class="line"><span class="comment"># Iteration 2</span></span><br><span class="line">~/opt/biosoft/minimap2/minimap2 ONTmin_IT1.fasta ont.fq &gt; ONTmin_IT1.paf</span><br><span class="line">time ~/opt/biosoft/racon/build/bin/racon -t 10 ont.fq ONTmin_IT1.paf ONTmin_IT1.fasta&gt; ONTmin_IT2.fasta</span><br><span class="line"><span class="comment"># Iteration 3</span></span><br><span class="line">~/opt/biosoft/minimap2/minimap2 ONTmin_IT2.fasta ont.fq &gt; ONTmin_IT2.paf</span><br><span class="line">time ~/opt/biosoft/racon/build/bin/racon -t 10 ont.fq ONTmin_IT2.paf ONTmin_IT2.fasta &gt; ONTmin_IT3.fasta</span><br></pre></td></tr></table></figure>

<p>之后使用二代数据进行纠错。二代数据虽然短，但是测序质量高，所以一般都要用它进行纠错。推荐用30X PCR free的illuminia 测序数据。</p>
<p>Step 1: 数据预处理，过滤低质量短读，去接头。工具很多，常用的是trimmomatic，cutadapter.  我安利一个国内海普洛斯搞的一个工具fastp。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data clean</span></span><br><span class="line">fastp -q 30 -5 -l 100 -i ERR2173372_1.fastq -I ERR2173372_2.fastq -o i1_clean_1.fq -O i1_clean_2.fq </span><br></pre></td></tr></table></figure>

<p>这里标准为：平均质量高于Q30，对5‘端进行低质量碱基删除，保留大于100bp的短读</p>
<p>Step2:  比对，这一步基本都只用了bwa了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># align</span></span><br><span class="line">bwa index ONTmin_IT3.fasta</span><br><span class="line">bwa mem -t 8 ONTmin_IT3.fasta il_clean_1.fastq il_clean_2.fastq | samtools <span class="built_in">sort</span> -@ 8 &gt; ONTmin_IT3.bam</span><br></pre></td></tr></table></figure>

<p>step3: 使用比对后的BAM文件进行纠错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># short read consensus call</span></span><br><span class="line">java -Xmx16G -jar pilon-1.22.jar --genome ONTmin_IT3.fasta --frags ONTmin_IT3.bam --fix snps --output ONTmin_IT4</span><br></pre></td></tr></table></figure>

<p>二代纠错的时间明显比之前的久，需要一天时间。</p>
<p>大家拿出自己的笔记本实际感受下呗</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>nanopore组装拟南芥: High contiguity Arabidopsis thaliana genome assembly with a single nanopore flow cell</li>
<li>不纠错组装: Minimap and miniasm: fast mapping and de novo assembly for noisy long sequences</li>
<li>三代组装软件评测: Comprehensive evaluation of non-hybrid genome assembly tools for third-generation PacBio long-read sequence data</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/29/%E4%B8%89%E4%BB%A3%E7%BB%84%E8%A3%85%E8%BD%AF%E4%BB%B6miniasm%E7%AC%94%E8%AE%B0-Assemble-nanopore-using-minimap-and-miniasm/" data-id="cllgasdsa0085dkov34urbdbr" data-title="三代组装软件miniasm笔记" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%84%E8%A3%85/" rel="tag">组装</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-使用purge_haplogs处理基因组杂合区域-purge_haplotigs-allelic-contig-reassignment-for-third-gen-diploid-genome-assemblies" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/29/%E4%BD%BF%E7%94%A8purge_haplogs%E5%A4%84%E7%90%86%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%9D%82%E5%90%88%E5%8C%BA%E5%9F%9F-purge_haplotigs-allelic-contig-reassignment-for-third-gen-diploid-genome-assemblies/" class="article-date">
  <time class="dt-published" datetime="2019-08-29T13:26:33.195Z" itemprop="datePublished">2019-08-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/29/%E4%BD%BF%E7%94%A8purge_haplogs%E5%A4%84%E7%90%86%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%9D%82%E5%90%88%E5%8C%BA%E5%9F%9F-purge_haplotigs-allelic-contig-reassignment-for-third-gen-diploid-genome-assemblies/">使用purge_haplogs处理基因组杂合区域</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>FALCON和Canu的组装后会得到一个单倍型融合的基因组，用来表示二倍体基因组。之后，FALCON Unzip和Supernova这类软件进一步处理其中等位基因区域，将这部分区间进行拆分。</p>
<p>当基因组某些区域可能有着比较高的杂合度，这会导致基因组该区域的两个单倍型被分别组装成primary contig， 而不是一个为primary contig， 另一个是associated haplotig. 如果下游分析主要关注于单倍型，这就会导致一些问题。</p>
<p>那么有没有解决方案呢？其实也很好办，就是找到相似度很高的contig，将他们拆分。目前已经有一些软件可以完成类似任务，如 <strong>HaploMerger2</strong>, <strong>Redundans</strong>, 这不过这些软件主要处理二代组装结果。</p>
<p> <code>purge_haplogs</code>则是最近开发，用于三代组装的基因组。它根据minimap2的比对结果，通过分析比对read的覆盖度决定谁去谁留。该工具适用于单倍型组装软件，例如 Canu, FALCON或 FALCON-Unzip primary contigs, 或者是分相后的二倍体组装(Falcon-Unzip primary contigs + haplotigs 。</p>
<p>它的工作流程如下图所示。一般只需要两个输入文件，组装草图(FASTA格式) 和 比对的BAM文件。同时还可以提供重复序列注释的BED文件，辅助处理高重复的contig。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-aa0d1c1178c3046a-0cd9a3bad7ce4e4f9c775ba526caaf67.png" alt="分析流程"></p>
<blockquote>
<p><strong>建议</strong>: 用原来用于组装的read进行比对。对于多个匹配的read，建议采取random best，也就是随便找一个。</p>
</blockquote>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p><code>purge_haplotigs</code>依赖软件比较多，手动安装会很麻烦，但是他可以直接用bioconda装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">conda create -n purge_haplotigs_env</span><br><span class="line">conda activate purge_haplotigs_env</span><br><span class="line">conda install purge_haplotigs</span><br></pre></td></tr></table></figure>

<p>安装完成后需要一步测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">purge_haplotigs <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h2 id="简明教程"><a href="#简明教程" class="headerlink" title="简明教程"></a>简明教程</h2><p>数据准备。 需要下载的数据集分为两个部分，一个是FALCON-Unzip后的primary contig 和 halplotigs. 另一个则是已经比完后的BAM文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> purge_haplotigs_tutorial</span><br><span class="line"><span class="built_in">cd</span> purge_haplotigs_tutorial</span><br><span class="line">wget https://zenodo.org/record/841398/files/cns_h_ctg.fasta</span><br><span class="line">wget https://zenodo.org/record/841398/files/cns_p_ctg.aligned.sd.bam <span class="comment"># 1.7G</span></span><br><span class="line">wget https://zenodo.org/record/841398/files/cns_p_ctg.aligned.sd.bam.bai </span><br><span class="line"> wget https://zenodo.org/record/841398/files/cns_p_ctg.fasta</span><br><span class="line">wget https://zenodo.org/record/841398/files/cns_p_ctg.fasta.fai</span><br></pre></td></tr></table></figure>

<p>当然我们不可能直接就拿到比对好的BAM文件，我们一般是有组装后的基因组以及用于组装的subread，假设这两个文件命名为, genome.fa 和 subreads.fasta.gz.</p>
<p>官方提供的新比对代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">minimap2 -t 4 -ax map-pb genome.fa subreads.fasta.gz --secondary=no \</span><br><span class="line">    | samtools <span class="built_in">sort</span> -m 1G -o aligned.bam -T tmp.ali</span><br></pre></td></tr></table></figure>

<p>如下是旧版代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">minimap2 -ax map-pb genome.fa subreads.fasta.gz \</span><br><span class="line">    | samtools view -hF 256 - \</span><br><span class="line">    | samtools <span class="built_in">sort</span> -@ 8 -m 1G -o aligned.bam -T tmp.ali</span><br></pre></td></tr></table></figure>

<p>如果你有二代测序数据，也可以用BWA-MEM进行比对得到BAM文件。</p>
<p>第一步：使用<code>purge_haplotigs  readhist</code>从BAM中统计read深度，绘制柱状图。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新</span></span><br><span class="line">purge_haplotigs  hist  -b aligned.bam  -g genome.fasta  -t 20</span><br><span class="line"><span class="comment"># 旧</span></span><br><span class="line"><span class="comment"># purge_haplotigs  readhist  -b aligned.bam  -g genome.fasta  -t 20</span></span><br><span class="line"><span class="comment"># -t 线程数, 不宜过高，过高反而没有效果。</span></span><br></pre></td></tr></table></figure>

<p>也就是下图，你能明显的看到图中有两个峰，一个是单倍型的覆盖度，另一个二倍型的覆盖度，</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-b3c0c46eba030da3-f23b4f0d95094a4eb78d42c7e6f8a875.png" alt="高杂合基因组read-depth histogram"></p>
<p>你可能还想知道高纯合基因组是什么样的效果，我也找了一个纯合的物种做了也做了read-depth 柱状图，</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-77166f97f8b14c91-4965aa2fbcaf48a590a98091d9f7d0af.png" alt="纯合基因组read-depth histogram"></p>
<p>之后你需要根据read-depth 柱状图 确定这两个峰的位置用于下一步。下面是两个例子。对于我们则是，20，65，190.</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-7561308e761d13ee-12e97f73e8c84bcb8e3b7051a08ceda7.png" alt="两个例子"></p>
<p>第二步: 根据read-depth信息选择阈值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新</span></span><br><span class="line">purge_haplotigs  contigcov  -i cns_p_ctg.aligned.sd.bam.gencov  -o coverage_stats.csv  -l 20  -m 75  -h 190</span><br><span class="line"><span class="comment"># 旧</span></span><br><span class="line"><span class="comment"># purge_haplotigs  contigcov  -i cns_p_ctg.aligned.sd.bam.gencov  -o coverage_stats.csv  -l 20  -m 75  -h 190</span></span><br></pre></td></tr></table></figure>

<p>这一步生成的文件是”coverage_stats.csv”</p>
<p>第三步：区分haplotigs. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">purge_haplotigs purge  -g cns_p_ctg.fasta  -c coverage_stats.csv  -b cns_p_ctg.aligned.sd.bam  -t 4  -a 60</span><br></pre></td></tr></table></figure>

<p>这一步会得到如下文件</p>
<ul>
<li>curated.artefacts.fasta：无用的contig，也就是没有足够覆盖度的contig.</li>
<li>curated.fasta：新的单倍型组装</li>
<li>curated.haplotigs.fasta：从原本组装分出来的haplotigs</li>
<li>curated.reassignments.tsv: 单倍型的分配信息</li>
<li>curated.contig_associations.log: 运行日志, 下面是其中一个记录，表示000004F_004和000004F_027是000004F_017的HAPLOTIG, 而000004F_017和000004F_013又是000004F,的HAPLOTIG。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">000004F,PRIMARY -&gt; 000004F_013,HAPLOTIG</span><br><span class="line">                -&gt; 000004F_017,HAPLOTIG </span><br><span class="line">                                        -&gt; 000004F_004,HAPLOTIG</span><br><span class="line">                                        -&gt; 000004F_027,HAPLOTIG</span><br></pre></td></tr></table></figure>

<p>在”curated.reassignments.tsv”文件中有6列</p>
<ul>
<li>reassigned_contig: 用于比较的contig</li>
<li>top_hit_contig: 最好的被比对的contig</li>
<li>second_hit_contig: 第二个被比对的contig</li>
<li>best_match_coverage: 最好的匹配覆盖度</li>
<li>max_match_coverage :  最高的匹配深度</li>
<li>reassignment: 标记为haplotype 还是 repeat，或者是keep</li>
</ul>
<p>由于我们用的是单倍型组装primary contigs而不是二倍体组装的parimary + haplotigs, 因此我们需要将FALCON_Unzip的haplotgi合并到重新分配的haplotigs中，这样子我们依旧拥有二倍体组装结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> cns_h_ctg.fasta &gt;&gt; curated.haplotigs.fasta</span><br></pre></td></tr></table></figure>

<h3 id="检查dotplots"><a href="#检查dotplots" class="headerlink" title="检查dotplots"></a>检查dotplots</h3><p>如果在第三步<code>purge_haplotigs purge</code>中添加了<code>-d/--dotplots</code>参数，即为每个reassigned_contigs和unassigned_contigs生成用于人工检查的共线性图，那么在最终的输出结果中会有两个文件目录</p>
<ul>
<li>dotplots_reassigned_contigs</li>
<li>dotplots_unassigned_contigs</li>
</ul>
<p>官方提供了5个可能出现的共线性图</p>
<p>第一种: <a target="_blank" rel="noopener" href="https://bitbucket.org/repo/Ej8Mz7/images/2663721414-haplotig.png">Haplotig</a>，最佳情况，完美的共线性关系</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/12/image-20191211103643627-2242c4d3dbb646019a52ec5d23c3a4a7.png" alt="Haplotig"></p>
<p>第二种: <a target="_blank" rel="noopener" href="https://bitbucket.org/repo/Ej8Mz7/images/3628840007-haploid_diploid_hemizygous.png">大部分是haplotigs</a>, 说明这个contig部分是二倍型，部分是单倍型，可能是半合子(hemizygous)</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/12/image-20191211103820925-4dc398c1eef94efa8e6fe42c49ae8dd0.png" alt="mostly haplotig"></p>
<p>第三种: Haplotigs里有大量的<a target="_blank" rel="noopener" href="https://bitbucket.org/repo/Ej8Mz7/images/854324485-repeat_rich.png">串联重复</a></p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/12/image-20191211104431607-4df146fcbf1d4e178c13c2d205430204.png" alt="tandem repeat"></p>
<p>第四种: Haplotigs是<a target="_blank" rel="noopener" href="https://bitbucket.org/repo/Ej8Mz7/images/1079545124-haplotig_with_palindrome.png">回文序列(palindrome)</a></p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/12/image-20191211104300406-d4ff89a584c64324812cb1c3dd407d56.png" alt="palindrome"></p>
<p>第五种: contig从string graph中<a target="_blank" rel="noopener" href="https://bitbucket.org/repo/Ej8Mz7/images/228451888-repeats_string_graph_short_cut.png">knots</a>产生，这种情况不算是haplotigs，但是对于短读序列的比对会造成麻烦</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/12/image-20191211104509706-8895b6b368bc4255aa702af868f3e7af.png" alt="knots"></p>
<p>你可能需要看大量的图才能有感觉，到底应该把哪些Purge_haplotigs错误认为是haplotig的contig放回到primary contig中。</p>
<h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><p>为什么第一步的 read 覆盖深度分析能判断基因组是否冗余呢？这是因为对于坍缩的单倍型，那么含有等位的基因的read只能比对到该位置上，而如果杂合度太高被拆分成两个不同的contig，那么含有等位的基因的read就会分别比对到不同的read上，导致深度降低一半。下图A就是一个典型的包含冗余基因组的read覆盖度分布</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-2f26047d1da456f5-72ba2aa4116245759f400928dae6d383.png" alt="read-深度分析"></p>
<p>分析流程的第二步的任务就是人工划分出如下图B部分，绿色的部分是坍缩单倍型contig，蓝色的部分是潜在的冗余contig。之后，分析流程会计算这些区域中的contig的覆盖度。 对于绿色部分中的contig，如果覆盖度低于80%, 会进行标记用于后续分析。如果深度非常低，那么很有可能就是组装引入错误，深度非常高的部分基本就是重复序列或者是细胞器的contig，这些黄色的contig可以在后续的组装出分开。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-0ae4a373254ca9e8-a7ccd5ff06a94fd08c5001b57f6c1f52.png" alt="划分区间"></p>
<p>第三步就是同源序列进行识别和分配。所有标记的contig之后会用Minimap2在整个组装进行搜索，寻找相似度较高的离散区间（如下图C）。如果一个Contig的联配得分大于阈值(默认70%), 那么就会被标记为haplotigs. 如果一个contig的最大联配得分大于阈值(默认250%), 会被标记成重复序列，这有可能是潜在的有问题contig，或许是坍缩的contig或者低复杂度序列。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-ca64a560ff4099bd-c42225d428ee40bb9f5feb048e7963a9.png" alt="移除haplotigs"></p>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul>
<li>Purge Haplotigs: allelic contig reassignment for third-gen diploid genome assemblies</li>
<li><a target="_blank" rel="noopener" href="https://bitbucket.org/mroachawri/purge_haplotigs">https://bitbucket.org/mroachawri/purge_haplotigs</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/29/%E4%BD%BF%E7%94%A8purge_haplogs%E5%A4%84%E7%90%86%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%9D%82%E5%90%88%E5%8C%BA%E5%9F%9F-purge_haplotigs-allelic-contig-reassignment-for-third-gen-diploid-genome-assemblies/" data-id="cllgasduk00dndkov366a01hn" data-title="使用purge_haplogs处理基因组杂合区域" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%84%E8%A3%85/" rel="tag">组装</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-使用TransDecoder寻找转录本中的编码区-Find-ORF-in-transcripts-using-TransDecoder" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/28/%E4%BD%BF%E7%94%A8TransDecoder%E5%AF%BB%E6%89%BE%E8%BD%AC%E5%BD%95%E6%9C%AC%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E5%8C%BA-Find-ORF-in-transcripts-using-TransDecoder/" class="article-date">
  <time class="dt-published" datetime="2019-08-28T22:43:45.469Z" itemprop="datePublished">2019-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/28/%E4%BD%BF%E7%94%A8TransDecoder%E5%AF%BB%E6%89%BE%E8%BD%AC%E5%BD%95%E6%9C%AC%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E5%8C%BA-Find-ORF-in-transcripts-using-TransDecoder/">使用TransDecoder寻找转录本中的编码区</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>TransDecoder能够从转录本序列中鉴定候选编码区。这些转录本序列可以来自于Trinity的从头组装，或者来自于Cufflinks或者StringTie的组装结果。</p>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>从<a target="_blank" rel="noopener" href="https://github.com/TransDecoder/TransDecoder/releases">https://github.com/TransDecoder/TransDecoder/releases</a>下载最新版的TransDecoder，以v5.5.0为例</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/opt/biosoft &amp;&amp; <span class="built_in">cd</span> ~/opt/biosoft</span><br><span class="line">wget https://github.com/TransDecoder/TransDecoder/archive/TransDecoder-v5.5.0.zip</span><br><span class="line">unzip TransDecoder-v5.5.0.zip</span><br><span class="line"><span class="built_in">mv</span> TransDecoder-TransDecoder-v5.5.0 TransDecoder-v5.5.0</span><br></pre></td></tr></table></figure>

<h2 id="运行TransDecoder"><a href="#运行TransDecoder" class="headerlink" title="运行TransDecoder"></a>运行TransDecoder</h2><p>我们从cufflinks或stringtie输出的gtf文件开始分析流程，因此你会有两个输入文件</p>
<ul>
<li>transcripts.gtf: 记录预测转录本的GTF文件</li>
<li>genome.fasta: 参考基因组序列</li>
</ul>
<p><strong>第一步</strong>: 从GTF文件中提取FASTA序列</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/TransDecoder-v5.5.0/util/gtf_genome_to_cdna_fasta.pl transcripts.gtf genome.fasta &gt; transcripts.fasta</span><br></pre></td></tr></table></figure>

<p><strong>第二步</strong>: 将GTF文件转成GFF3格式</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/TransDecoder-v5.5.0/util/gtf_to_alignment_gff3.pl transcripts.gtf &gt; transcripts.gff3</span><br></pre></td></tr></table></figure>

<p><strong>第三步</strong>: 预测转录本中长的开放阅读框, 默认是100个氨基酸，可以用<code>-m</code>修改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/TransDecoder-v5.5.0/TransDecoder.LongOrfs -t transcripts.fasta</span><br></pre></td></tr></table></figure>

<p><strong>第四步</strong>: 使用DIAMOND对上一步输出的<code>transcripts.fasta.transdecoder.pep</code>在蛋白数据库中进行搜索，寻找同源证据支持</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载数据并解压缩</span></span><br><span class="line">wget ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/complete/uniprot_sprot.fasta.gz</span><br><span class="line">gunzip uniprot_sprot.fasta.gz</span><br><span class="line"><span class="comment"># 建立索引</span></span><br><span class="line">diamond makedb --<span class="keyword">in</span> uniprot_sprot.fasta --db uniprot_sprot.fasta</span><br><span class="line"><span class="comment"># BLASTP比对</span></span><br><span class="line">diamond blastp -d uniprot_sprot.fasta -q transcripts.fasta.transdecoder_dir/longest_orfs.pep --evalue 1e-5 --max-target-seqs 1 &gt; blastp.outfmt6</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于DIAMOND的使用，参考这篇说明<a href="/archives/Fast-and-sensitive-protein-alignment-using-diamond">DIAMOND: 超快的蛋白序列比对软件</a></p>
</blockquote>
<p><strong>第五步</strong>: 预测可能的编码区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/TransDecoder-v5.5.0/TransDecoder.Predict \</span><br><span class="line">    -t transcripts.fasta \</span><br><span class="line">    --retain_blastp_hits blastp.outfmt6 </span><br></pre></td></tr></table></figure>

<p><strong>第六步</strong>: 生成基于参考基因组的编码区注释文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/TransDecoder-v5.5.0/util/cdna_alignment_orf_to_genome_orf.pl \</span><br><span class="line">     transcripts.fasta.transdecoder.gff3 \</span><br><span class="line">     transcripts.gff3 \</span><br><span class="line">     transcripts.fasta &gt; transcripts.fasta.transdecoder.genome.gff3</span><br></pre></td></tr></table></figure>

<p>最终输出文件如下:</p>
<ul>
<li>transcripts.fasta.transdecoder.pep: 最终预测的CDS对应的蛋白序列</li>
<li>transcripts.fasta.transdecoder.cds: 最终预测的CDS序列</li>
<li>transcripts.fasta.transdecoder.gff3: 最终ORF对应的GFF3</li>
<li>transcripts.fasta.transdecoder.bed: 以BED格式存放ORF位置信息</li>
<li>transcripts.fasta.transdecoder.genome.gff3: 基于参考基因组的GFF3文件</li>
</ul>
<p>其中BED和GFF3可以放到IGV上展示，手动检查下结果</p>
<blockquote>
<p>假如是Trinity从头预测的转录本，没有参考基因组，那么就运行第三步，第四步和第五步</p>
</blockquote>
<p>在transcripts.fasta.transdecoder.cds文件中，每个fasta序列的头信息部分会有一个ORF type，分为如下几个类型</p>
<ul>
<li>‘complete’: 包含起始密码子和终止密码子</li>
<li>‘5prime_partial’: 缺失起始密码子, 可能只有部分的N端序列</li>
<li>‘3prime_partial’: 缺失终止密码子, 可能只有部分的C端序列</li>
<li>‘internal’: 意味着同时是5prime-partial和3prime-partial</li>
</ul>
<p>通常而言，我们会用complete的cds寻找同源证据，然后选择高可信度的序列用于训练，而不是哪些特别长且没有已知蛋白支持的序列。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/TransDecoder/TransDecoder/wiki">https://github.com/TransDecoder/TransDecoder/wiki</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/PASApipeline/PASApipeline/wiki/PASA_abinitio_training_sets">https://github.com/PASApipeline/PASApipeline/wiki/PASA_abinitio_training_sets</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/28/%E4%BD%BF%E7%94%A8TransDecoder%E5%AF%BB%E6%89%BE%E8%BD%AC%E5%BD%95%E6%9C%AC%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E5%8C%BA-Find-ORF-in-transcripts-using-TransDecoder/" data-id="cllgasduf00d7dkov6ust4pq5" data-title="使用TransDecoder寻找转录本中的编码区" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%84%E8%A3%85-%E8%BD%AC%E5%BD%95%E7%BB%84-%E6%B3%A8%E9%87%8A/" rel="tag">组装 | 转录组 | 注释</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-DIAMOND_ 超快的蛋白序列比对软件-Fast-and-sensitive-protein-alignment-using-diamond" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/28/DIAMOND_%20%E8%B6%85%E5%BF%AB%E7%9A%84%E8%9B%8B%E7%99%BD%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9%E8%BD%AF%E4%BB%B6-Fast-and-sensitive-protein-alignment-using-diamond/" class="article-date">
  <time class="dt-published" datetime="2019-08-28T21:27:53.717Z" itemprop="datePublished">2019-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/28/DIAMOND_%20%E8%B6%85%E5%BF%AB%E7%9A%84%E8%9B%8B%E7%99%BD%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9%E8%BD%AF%E4%BB%B6-Fast-and-sensitive-protein-alignment-using-diamond/">DIAMOND:超快的蛋白序列比对软件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>今天用BLASTX将我的转录本序列在UniProt蛋白数据库(700w条序列)中搜索，80个线程，过了1小时大概就分析1000条吧。实在是有点慢，于是我想到之前耳闻的DIAMOND，据说速度非常快，于是我测试了下。没想到，这工具居然那么快。</p>
<p>根据DIAMOND介绍，它有以下特点</p>
<ul>
<li>比BLAST快500到20,000倍</li>
<li>长序列的移框联配分析(frameshift alignment)</li>
<li>资源消耗小，普通台式机和笔记本都能运行</li>
<li>输出格式多样</li>
</ul>
<p>我就看中它一点，速度快。</p>
<p>软件安装异常的简单，因为提供了预编译的64位可执行文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://github.com/bbuchfink/diamond/releases/download/v0.9.25/diamond-linux64.tar.gz</span><br><span class="line">tar xzf diamond-linux64.tar.gz</span><br><span class="line"><span class="comment"># 有root全新啊</span></span><br><span class="line">sudo <span class="built_in">mv</span> diamond /usr/local/bin</span><br><span class="line"><span class="comment"># 无root权限, ~/bin是自己当前目录下</span></span><br><span class="line"><span class="built_in">mv</span> diamond ~/bin</span><br></pre></td></tr></table></figure>

<p>因为 diamon的功能就是将蛋白或者翻译后的核苷酸和蛋白数据库进行比对，没有BLAST那么多功能，所以软件使用也是异常的简单。</p>
<p>第一步: 先从NCBI上下载蛋白数据库。 NR库是NCBI的非冗余蛋白数据库，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget ftp://ftp.ncbi.nlm.nih.gov/blast/db/FASTA/nr.gz</span><br><span class="line">gunzip nr.gz</span><br></pre></td></tr></table></figure>

<p>也可以从<a href="ftp://ftp.ncbi.nlm.nih.gov/refseq/release/plant/">ftp://ftp.ncbi.nlm.nih.gov/refseq/release/plant/</a>下载植物的蛋白数据库</p>
<p>第二步: 建库。就两个参数，<code>--in nr</code>输入文件，<code>--db nr</code> 输出的数据库前缀. 氨基酸序列中的结尾可以有”*”</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diamond makedb --<span class="keyword">in</span> nr --db nr</span><br></pre></td></tr></table></figure>

<p><strong>注</strong>: 假如要根据GFF提取蛋白序列，一定要注意输出的氨基酸序列中不能有”.”在序列中，否则会报错。可以通过<code>seqkit grep -s -vrp &#39;&quot;\.&quot;&#39; input.fa &gt; output.fa</code> 进行过滤。</p>
<p>第三步: 搜索。就两个子命令，blastp和blastx，前者比对蛋白，后者比对DNA序列</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">diamond blastx --db nr -q reads.fna -o dna_matches_fmt6.txt</span><br><span class="line">diamond blastp --db nr -q reads.faa -o protein_matches_fmt6.txt</span><br></pre></td></tr></table></figure>

<p><code>-q/--query</code>输入检索序列，<code>--out/-o</code>输出文件，默认以<code>--outfmt 6</code>输出结果和BLAST+的<code>--outfmt 6</code>结果一致。</p>
<p>注意事项:</p>
<ul>
<li>默认参数主要是针对短序列，对于比较长的序列，使用<code>--sensitive</code>或<code>--more-senstive</code>提高敏感度。</li>
<li>默认的e-value阈值是0.001, 而BLAST是10，因此会比BLAST结果更加严格</li>
</ul>
<p>性能优化:</p>
<ul>
<li>设置比较低的<code>-e</code>参数</li>
<li>设置<code>-k</code>参数，减少输出的联配数目。这会降低临时文件大小和最终结果</li>
<li><code>--top</code>会输出得分比最好的分数低一定百分比的结果，</li>
<li><code>--compress 1</code>: 输出结果会以gzip进行压缩</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>Benjamin Buchfink, Chao Xie, and Daniel H. Huson. Fast and sensitive protein alignment<br>using diamond. Nature methods, 12(1):59–60, Jan 2015.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/28/DIAMOND_%20%E8%B6%85%E5%BF%AB%E7%9A%84%E8%9B%8B%E7%99%BD%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9%E8%BD%AF%E4%BB%B6-Fast-and-sensitive-protein-alignment-using-diamond/" data-id="cllgasdp4001edkovdtj2fyz8" data-title="DIAMOND:超快的蛋白序列比对软件" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" rel="tag">注释 | 序列比对</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-使用MAKER进行全基因组基因注释-基础篇-whole-genome-gene-annotation-using-maker" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/28/%E4%BD%BF%E7%94%A8MAKER%E8%BF%9B%E8%A1%8C%E5%85%A8%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%9F%BA%E5%9B%A0%E6%B3%A8%E9%87%8A-%E5%9F%BA%E7%A1%80%E7%AF%87-whole-genome-gene-annotation-using-maker/" class="article-date">
  <time class="dt-published" datetime="2019-08-28T09:22:20.738Z" itemprop="datePublished">2019-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/28/%E4%BD%BF%E7%94%A8MAKER%E8%BF%9B%E8%A1%8C%E5%85%A8%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%9F%BA%E5%9B%A0%E6%B3%A8%E9%87%8A-%E5%9F%BA%E7%A1%80%E7%AF%87-whole-genome-gene-annotation-using-maker/">使用MAKER进行全基因组基因注释-基础篇</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-3219030babf92e35-42d10cc44f5d4d159cecec7bc04c0087.png" alt="maker"></p>
<p>在基因组注释上，MAKER算是一个很强大的分析流程。能够识别重复序列，将EST和蛋白序列比对到基因组，进行从头预测，并在最后整合这三个结果保证结果的可靠性。此外，MAKER还可以不断训练，最初的输出结果可以继续用作输入训练基因预测的算法，从而获取更高质量的基因模型。</p>
<p>Maker的使用比较简单，在软件安装成后，会有一个”data”文件夹存放测试数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> ~/opt/biosoft/maker/data</span><br><span class="line">dpp_contig.fasta  dpp_est.fasta  dpp_protein.fasta  hsap_contig.fasta  hsap_est.fasta  hsap_protein.fasta  te_proteins.fasta</span><br></pre></td></tr></table></figure>

<p>以”dpp”开头的数据集为例，protein表示是同源物种的蛋白序列，est是表达序列标签，存放的是片段化的cDNA序列，而contig则是需要被预测的基因组序列。</p>
<p>让我们新建一个文件夹，并将这些测试数据拷贝过来。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> test01 ; <span class="built_in">cd</span> test01</span><br><span class="line"><span class="built_in">cp</span> ~/opt/biosoft/maker/data/dpp* .</span><br></pre></td></tr></table></figure>

<p>由于基因组注释设计到多个程序，多个步骤，每个步骤可能都有很多参数需要调整，因此就需要建立专门的配置文件用来告诉maker应该如何控制流程的运行。</p>
<p>如下步骤创建三个以ctl结尾的配置文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/maker/bin/maker -CTL</span><br><span class="line"><span class="built_in">ls</span> *.ctl</span><br><span class="line">maker_bopts.ctl  maker_exe.ctl  maker_opts.ctl</span><br></pre></td></tr></table></figure>

<ul>
<li>maker_exe.ctl: 执行程序的路径</li>
<li>maker_bopt.ctl: BLAST和Exonerat的过滤参数</li>
<li>maker_opt.ctl: 其他信息，例如输入基因组文件</li>
</ul>
<p>maker_exe.ctl和maker_bopt.ctl可以简单用less查看，可不做修改，maker_opt.ctl是主要调整的对象。 使用<code>vim maker_opt.ctl</code>修改如下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">genome=dpp_contig.fasta</span><br><span class="line">est=dpp_est.fasta</span><br><span class="line">protein=dpp_protein.fasta</span><br><span class="line">est2genome=1</span><br></pre></td></tr></table></figure>

<p>修改完之后多花几分钟看看每个参数的设置，尽管很枯燥，但是考虑这个工具你可能会反复多次使用，所以这点时间是一定要花的。</p>
<p>随后就可以在当前路径运行程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/maker/bin/maker &amp;&gt; maker.log &amp;</span><br></pre></td></tr></table></figure>

<p>输出结果见”dpp_contig.maker.output”, 重点是”dpp_contig_master_datastore_index.log”文件，由于maker会拆分数据集并行计算，因此该文件记录总体的运行情况，需要关注其中是否有”FAILED”,”RETRY”,”SKIPPED_SAMLL”,”DIED_SIPPED_PERMANET”，因为这意味着有些数据出于某些原因没有运算。</p>
<p>最后，我们需要将并行运算的结果进行整合，导出GFF文件, 转录本序列和蛋白序列</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/maker/bin/fasta_merge -d dpp_contig_master_datastore_index.log</span><br><span class="line">~/opt/biosoft/maker/bin/gff3_merge -d dpp_contig_master_datastore_index.log</span><br></pre></td></tr></table></figure>

<p>在该目录下就会出现, “dpp_contig.all.gff”, “dpp_contig.all.maker.proteins.fasta”,”dpp_contig.all.maker.transcripts.fasta”</p>
<p>其中GFF文件就需要用IGV，JBrowse, Apollo下展示来检查下注释是否正确。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><strong>软件安装</strong>：MAKER可以免费用于学术用途，但是未经许可不可商用。目前有两个版本2018年5月4日更新的2.31.10和测试版3.01.02.出于稳定性考虑，安装前者。后续假设已经在<a target="_blank" rel="noopener" href="http://yandell.topaz.genetics.utah.edu/cgi-bin/maker_license.cgi">http://yandell.topaz.genetics.utah.edu/cgi-bin/maker_license.cgi</a>进行登记，并且下载了压缩包”maker-2.31.10.tgz”</p>
<p>先检查下自己的系统情况，看需要补充哪些库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar xf maker-2.31.10.tgz</span><br><span class="line"><span class="built_in">cd</span> maker/src</span><br><span class="line">perl Build.PL</span><br></pre></td></tr></table></figure>

<p>这一步之后会罗列出后续需要运行的命令来完成安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./Build installdeps</span><br><span class="line">./Build installexes</span><br><span class="line">./Build install</span><br><span class="line">./Build status</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>Genome Annotation and Curation Using MAKER and MAKER-P</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/28/%E4%BD%BF%E7%94%A8MAKER%E8%BF%9B%E8%A1%8C%E5%85%A8%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%9F%BA%E5%9B%A0%E6%B3%A8%E9%87%8A-%E5%9F%BA%E7%A1%80%E7%AF%87-whole-genome-gene-annotation-using-maker/" data-id="cllgasdt600bddkov864t2hb7" data-title="使用MAKER进行全基因组基因注释-基础篇" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-MAKER/" rel="tag">注释 | MAKER</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-三代组装软件Canu使用-Assembly-PacBio-Nanopore-Using-Canu" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/28/%E4%B8%89%E4%BB%A3%E7%BB%84%E8%A3%85%E8%BD%AF%E4%BB%B6Canu%E4%BD%BF%E7%94%A8-Assembly-PacBio-Nanopore-Using-Canu/" class="article-date">
  <time class="dt-published" datetime="2019-08-28T09:15:56.916Z" itemprop="datePublished">2019-08-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/28/%E4%B8%89%E4%BB%A3%E7%BB%84%E8%A3%85%E8%BD%AF%E4%BB%B6Canu%E4%BD%BF%E7%94%A8-Assembly-PacBio-Nanopore-Using-Canu/">三代组装软件Canu使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Canu简介"><a href="#Canu简介" class="headerlink" title="Canu简介"></a>Canu简介</h2><p>Canu是Celera的继任者，能用于组装PacBio和Nanopore两家公司得到的测序结果。</p>
<p>Canu分为三个步骤，纠错，修整和组装，每一步都差不多是如下几个步骤：</p>
<ul>
<li>加载read到read数据库，gkpStore</li>
<li>对k-mer进行技术，用于计算序列间的overlap</li>
<li>计算overlap</li>
<li>加载overlap到overlap数据库，OvlStore</li>
<li>根据read和overlap完成特定分析目标<ul>
<li>read纠错时会从overlap中挑选一致性序列替换原始的噪声read</li>
<li>read修整时会使用overlap确定read哪些区域是高质量区域，哪些区域质量较低需要修整。最后保留单个最高质量的序列块</li>
<li>序列组装时根据一致的overlap对序列进行编排(layout), 最后得到contig。</li>
</ul>
</li>
</ul>
<p>这三步可以分开运行，既可以用Canu纠错后结果作为其他组装软件的输入，也可以将其他软件的纠错结果作为Canu的输入，因此下面分别运行这三步,并介绍重要的参数。</p>
<p>几个全局参数：genomeSize设置预估的基因组大小，这用于让Canu估计测序深度； maxThreads设置运行的最大线程数；rawErrorRate用来设置两个未纠错read之间最大期望差异碱基数；correctedErrorRate则是设置纠错后read之间最大期望差异碱基数，这个参数需要在 <strong>组装</strong> 时多次调整；minReadLength表示只使用大于阈值的序列，minOverlapLength表示Overlap的最小长度。提高minReadLength可以提高运行速度，增加minOverlapLength可以降低假阳性的overlap。</p>
<h2 id="组装实战"><a href="#组装实战" class="headerlink" title="组装实战"></a>组装实战</h2><h3 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h3><p>数据来自于发表在 Nature Communication 的一篇文章 “<a target="_blank" rel="noopener" href="https://www.nature.com/articles/s41467-018-03016-2">High contiguity Arabidopsis thaliana genome assembly with a single nanopore flow cell</a>“。 这篇文章提供了 <em>Arabidopsis thaliana</em> KBS-Mac-74 的30X短片段文库二代测序、PacBio和Nanopore的三代测序以及Bionano测序数据, 由于拟南芥的基因组被认为是植物中的金标准，因此文章提供的数据适合非常适合用于练习。根据文章提供的项目编号”PRJEB21270”, 在European Nucleotide Archive上找到下载地址。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-865750ef37870824-ad0c686583d34095b555a8ad4401b70c.png" alt="ENA搜索"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## PacBio Sequal</span></span><br><span class="line">wget -c -q ftp://ftp.sra.ebi.ac.uk/vol1/ERA111/ERA1116568/bam/pb.bam</span><br><span class="line"><span class="comment">## MinION</span></span><br><span class="line">wget -c -q ftp://ftp.sra.ebi.ac.uk/vol1/ERA111/ERA1116595/fastq/ont.fq.gz</span><br><span class="line"><span class="comment"># Illuminia MiSeq</span></span><br><span class="line">wget -c -q ftp://ftp.sra.ebi.ac.uk/vol1/ERA111/ERA1116569/fastq/il_1.fq.gz</span><br><span class="line">wget -c -q ftp://ftp.sra.ebi.ac.uk/vol1/ERA111/ERA1116569/fastq/il_2.fq.gz</span><br></pre></td></tr></table></figure>

<p>下载的PacBio数据以BAM格式存储，可以通过安装PacBio的smrtlink工具套装，使用其中的bam2fasta工具进行转换.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># build index for convert</span></span><br><span class="line">~/opt/biosoft/smrtlink/smrtcmds/bin/pbindex pb.bam &amp;</span><br><span class="line"><span class="comment"># convert bam to fasta</span></span><br><span class="line">~/opt/biosoft/smrtlink/smrtcmds/bin/bam2fasta -o pb pb.bam &amp;</span><br></pre></td></tr></table></figure>

<p>其实<code>samtools fasta</code>也可以将bam转成fasta文件，并且不影响之后的组装。</p>
<blockquote>
<p>PacBio的smrtlink工具套装大小为1.4G，不但下载速度慢，安装也要手动确认各种我不清楚的选项, 唯一好处就是工具很全。</p>
</blockquote>
<h3 id="运行Canu"><a href="#运行Canu" class="headerlink" title="运行Canu"></a>运行Canu</h3><p><strong>第一步</strong>：纠错。三代测序本身错误率高，使得原始数据充满了噪音。这一步就是通过序列之间的相互比较纠错得到高可信度的碱基。主要调整两个参数</p>
<ul>
<li>corOutCoverage: 用于控制多少数据用于纠错。比如说拟南芥是120M基因组，100X测序后得到了12G数据，如果只打算使用最长的6G数据进行纠错，那么参数就要设置为50(120m x 50)。设置一个大于测序深度的数值，例如120，表示使用所有数据。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">canu -correct \</span><br><span class="line">    -p ath -d pb_ath \</span><br><span class="line">    Threads=10 gnuplotTested=<span class="literal">true</span>\</span><br><span class="line">    genomeSize=120m minReadLength=2000 minOverlapLength=500\</span><br><span class="line">    corOutCoverage=120 corMinCoverage=2 \</span><br><span class="line">    -pacbio-raw pb.fasta.gz</span><br></pre></td></tr></table></figure>

<p>可以将上述命令保存到shell脚本中进行运行, <code>nohup bash run_canu.sh 2&gt; correct.log &amp;</code>.</p>
<p>注: 1.7版本里会没有默认没有安装gnuplot出错，因此gnuplotTested&#x3D;true 可以跳过检查。</p>
<p><strong>第二步</strong>：修整。这一步的目的是为了获取更高质量的序列，移除可疑区域（如残留的SMRTbell接头).</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">canu -trim \</span><br><span class="line">        -p ath -d pb_ath</span><br><span class="line">        maxThreads=20 gnuplotTested=<span class="literal">true</span>\</span><br><span class="line">        genomeSize=120m minReadLength=2000 minOverlapLength=500\</span><br><span class="line">        -pacbio-corrected ath/pb_ath.correctedReads.fasta.gz</span><br></pre></td></tr></table></figure>

<p><strong>第三步</strong>: 组装。在前两步获得高质量的序列后，就可以正式进行组装. 这一步主要调整的就是纠错后的序列的错误率， correctedErrorRate，它会影响utgOvlErrorRate。这一步可以尝试多个参数，因为速度比较块。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># error rate 0.035</span></span><br><span class="line">canu -assemble \</span><br><span class="line">    -p ath -d ath-erate-0.035 \</span><br><span class="line">    maxThreads=20 gnuplotTested=<span class="literal">true</span> \</span><br><span class="line">    genomeSize=120m\</span><br><span class="line">    correctedErrorRate=0.035 \</span><br><span class="line">    -pacbio-corrected atg/pb_ath.trimmedReads.fasta.gz</span><br><span class="line"><span class="comment"># error rate 0.050</span></span><br><span class="line">canu -assemble \</span><br><span class="line">    -p ath -d ath-erate-0.050 \</span><br><span class="line">    maxThreads=20 gnuplotTested=<span class="literal">true</span> \</span><br><span class="line">    genomeSize=120m\</span><br><span class="line">    correctedErrorRate=0.050 \</span><br><span class="line">    -pacbio-corrected atg/pb_ath.trimmedReads.fasta.gz</span><br></pre></td></tr></table></figure>

<p>最后输出文件下的<code>ath.contigs.fasta</code>就是结果文件。</p>
<h2 id="一些宝贵的建议"><a href="#一些宝贵的建议" class="headerlink" title="一些宝贵的建议"></a>一些宝贵的建议</h2><h3 id="Nanopore组装"><a href="#Nanopore组装" class="headerlink" title="Nanopore组装"></a>Nanopore组装</h3><p>对于Nanopore数据，使用Canu组装并不是一个非常好的选择，我曾经以一个600多M的物种100X数据进行组装，在120线程，花了整整一个多月的时间，尽管它的组装效果真的是很好。</p>
<ul>
<li>rawErrorRate: 从0.144 调整到 0.12 或者更低，速度会提高5到10倍</li>
<li>readSamplingCoverage, readSamplingBias: 可以抽取部分数据进行纠错，而不是全部数据</li>
<li>corOutCoverage&#x3D;30:  默认的30X或者40X的组装效果其实不错</li>
<li><code>-fast</code>: 对于1Gb以下的物种，可以加上该参数，会明显提高速度</li>
</ul>
<h3 id="高杂合物种组装"><a href="#高杂合物种组装" class="headerlink" title="高杂合物种组装"></a>高杂合物种组装</h3><p>对于高杂合物种的组装，Canu建议是用 <code>batOptions=-dg 3 -db 3 -dr 1 -ca 500 -cp 50</code>参数尽量分出两套单倍型，然后对基因组去冗余。</p>
<p><code>batOptions</code>表示传递后续的参数给组装软件<code>bogart</code>, <code>-dg 3 -db3</code>降低自动确定阈值时的错误率离差(deviation)，从而更好的分开单倍型。<code>-dr 1 -ca 500 -cp 50</code>会影响错误组装的拆分，对于一个模棱两可的contig，如果至少另一条可选路径的overlap长度至少时500bp，或者说另一条可选路径时在长度上和当前最佳路径存在50%的差异，那么就将contig进行拆分。</p>
<p>关于杂合物种组装的讨论，参考<a target="_blank" rel="noopener" href="https://github.com/marbl/canu/issues/201#issuecomment-233750764">https://github.com/marbl/canu/issues/201#issuecomment-233750764</a></p>
<h3 id="购买SSD避免服务器IO瓶颈"><a href="#购买SSD避免服务器IO瓶颈" class="headerlink" title="购买SSD避免服务器IO瓶颈"></a>购买SSD避免服务器IO瓶颈</h3><p>如果你的服务器线程数很多，你在普通的机械硬盘上运行组装，而且你的系统还是CentOS，那么你需要调整一个参数，避免其中一步的IO严重影响服务器性能。</p>
<p>Canu通过两个策略进行并行，bucketizing (‘ovb’ 任务) 和 sorting (‘ovs’ 任务)。 bucketizing会从1-overlap读取输出的overlap，将他们<strong>复制</strong>一份作为中间文件。sorting一步将这些文件加载到内存中进行排序然后<strong>写出</strong>到硬盘上。 如果你的overlap输出特别多，那么该步骤将会瞬间挤爆的你的IO.</p>
<p>为了避免悲剧发生，请增加如下参数: <code>ovsMemory=16G ovbConcurrency=15 ovsConcurrency=15</code>， 也就是降低这两步同时投递的任务数，缓解IO压力。</p>
<h3 id="如何用不同服务器处理同一个任务"><a href="#如何用不同服务器处理同一个任务" class="headerlink" title="如何用不同服务器处理同一个任务"></a>如何用不同服务器处理同一个任务</h3><p>overlap这一步时间久，如果并没有服务器集群，而是有多台服务器，可以参考如下方法进行数据并行处理（必须要安装相同的Canu版本）</p>
<p>假如Canu任务中的prefix参数为coc, 用scp进行数据的传递</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp -r coc.seqStore wangjw@10.10.87.132:/data1/wjw/Coc/Canu</span><br><span class="line">scp -r unitigging/1-overlapper/overlap.sh wangjw@10.10.87.132:/data1/wjw/Coc/Canu</span><br><span class="line">scp -r unitigging/0-mercounts/ wangjw@10.10.87.132:/data1/wjw/Coc/Canu</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>到目标服务器的canu目录下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> unitigging</span><br><span class="line"><span class="built_in">mkdir</span> -p unitigging/1-overlapper</span><br><span class="line"><span class="built_in">mv</span> 0-mercounts/  unitigging/</span><br><span class="line"><span class="built_in">mv</span> overlap.sh unitigging/1-overlapper/</span><br></pre></td></tr></table></figure>

<p>修改<code>overlap.sh</code>里的bin路径，指定当前服务器的canu路径</p>
<p>之后运行任务即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> unitigging/1-overlapper/</span><br><span class="line">./overlap.sh 77 &amp;&gt; 77.<span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<p>运行完任务之后，将目前服务器<code>unitigging/1-overlapper/001</code>目录下的<code>000077.oc 000077.ovb 000077.stats</code>文件传送回原来的服务器<code>unitigging/1-overlapper/001</code>下即可。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>官方文档: <a target="_blank" rel="noopener" href="https://canu.readthedocs.io/en/latest/index.html">https://canu.readthedocs.io/en/latest/index.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/28/%E4%B8%89%E4%BB%A3%E7%BB%84%E8%A3%85%E8%BD%AF%E4%BB%B6Canu%E4%BD%BF%E7%94%A8-Assembly-PacBio-Nanopore-Using-Canu/" data-id="cllgasds20082dkovc4651yku" data-title="三代组装软件Canu使用" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%84%E8%A3%85/" rel="tag">组装</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-使用TEclass对TE一致性序列进行分类-classify-te-consensus-sequence-by-teclass" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/27/%E4%BD%BF%E7%94%A8TEclass%E5%AF%B9TE%E4%B8%80%E8%87%B4%E6%80%A7%E5%BA%8F%E5%88%97%E8%BF%9B%E8%A1%8C%E5%88%86%E7%B1%BB-classify-te-consensus-sequence-by-teclass/" class="article-date">
  <time class="dt-published" datetime="2019-08-27T21:56:48.413Z" itemprop="datePublished">2019-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/27/%E4%BD%BF%E7%94%A8TEclass%E5%AF%B9TE%E4%B8%80%E8%87%B4%E6%80%A7%E5%BA%8F%E5%88%97%E8%BF%9B%E8%A1%8C%E5%88%86%E7%B1%BB-classify-te-consensus-sequence-by-teclass/">使用TEclass对TE一致性序列进行分类</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>软件地址在<a target="_blank" rel="noopener" href="http://www.compgen.uni-muenster.de/tools/teclass/index.hbi">http://www.compgen.uni-muenster.de/tools/teclass/index.hbi?</a>, 由于TEclass这个软件已经许久没有更新了，因此还要讲解下安装步骤。</p>
<blockquote>
<p>最近更新了一个2.1.3c, 经过我测试发现，应该就是把之前无法下载URL做了更新。classifiers.tar.gz无更新。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.compgen.uni-muenster.de/tools/teclass/download/TEclass-2.1.3.tar.gz</span><br><span class="line">tar xf TEclass-2.1.3.tar.gz</span><br><span class="line"><span class="built_in">cd</span> TEclass-2.1.3</span><br></pre></td></tr></table></figure>

<p>下载依赖的软件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh Download_dependencies.sh</span><br></pre></td></tr></table></figure>

<p> 由于代码老旧，部分内容无法自动下载，需要手动下载， 例如librf, blast.  最终要保证文件夹下有如下文件</p>
<ul>
<li>libsvm.tar.gz: <a target="_blank" rel="noopener" href="http://www.csie.ntu.edu.tw/~cjlin/libsvm/">http://www.csie.ntu.edu.tw/~cjlin/libsvm/</a></li>
<li>glimmer.tar.gz:  <a target="_blank" rel="noopener" href="http://ccb.jhu.edu/software/glimmer/">http://ccb.jhu.edu/software/glimmer/</a></li>
<li>librf.tar.gz: <a target="_blank" rel="noopener" href="http://mtv.ece.ucsb.edu/benlee/librf.html">http://mtv.ece.ucsb.edu/benlee/librf.html</a></li>
<li>lvq_pak.tar: <a target="_blank" rel="noopener" href="http://www.cis.hut.fi/research/som-research/nnrc-programs.shtml">http://www.cis.hut.fi/research/som-research/nnrc-programs.shtml</a></li>
<li>blast.tar.gz: <a href="ftp://ftp.ncbi.nlm.nih.gov/blast/executables/legacy.NOTSUPPORTED">ftp://ftp.ncbi.nlm.nih.gov/blast/executables/legacy.NOTSUPPORTED</a></li>
</ul>
<p>例如blast</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o <span class="string">&#x27;blast.tar.gz&#x27;</span> ftp://ftp.ncbi.nlm.nih.gov/blast/executables/legacy.NOTSUPPORTED/2.2.26/blast-2.2.26-x64-linux.tar.gz</span><br></pre></td></tr></table></figure>

<p>编译依赖的软件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh Compile_dependencies.sh</span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-3885005894b4ac70-0f20bdb0eaad4826a9dd4fdf81c587bc.png" alt="安装过程"></p>
<p>安装TEclass, 这一步可以跳过 RepBase的配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl Configure.pl</span><br></pre></td></tr></table></figure>

<p>安装预编译的分类器，这一步在TEclass的目录下运行，并解压缩</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.compgen.uni-muenster.de/tools/teclass/download/classifiers.tar.gz</span><br><span class="line"><span class="built_in">mv</span> classifiers.tar.gz classifiers/</span><br><span class="line"><span class="built_in">cd</span> classifiers</span><br><span class="line">tar xf classifiers.tar.gz</span><br></pre></td></tr></table></figure>

<p>测试运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./TEclassTest.pl ./testfile.fa</span><br></pre></td></tr></table></figure>

<h2 id="软件使用"><a href="#软件使用" class="headerlink" title="软件使用"></a>软件使用</h2><h3 id="构建分类器"><a href="#构建分类器" class="headerlink" title="构建分类器"></a>构建分类器</h3><p>如果你想使用最新的RepBase，那么就需要自己从<a target="_blank" rel="noopener" href="http://www.girinst.org/repbase/index.html">RepBase</a>下载数据进行构建。</p>
<p>如果是单核处理器，可能要花费数周的时间，所以建议用上你的所有线程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/TEclassBuild.pl -x 0  -o new_classifiers -p 99</span><br></pre></td></tr></table></figure>

<h3 id="重复序列分类"><a href="#重复序列分类" class="headerlink" title="重复序列分类"></a>重复序列分类</h3><p>在RepeatModeler建模后，提取Unknown序列使用<code>TEclassTest</code>进行归类，假如输入文件命名为Modelerunknown.lib</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEclassTest Modelerunknown.lib</span><br></pre></td></tr></table></figure>

<p>结果在<code>Modelerunknown.lib_xxxx</code>, <code>xxxx</code>是你运行日期。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Modelerunknown.lib <span class="comment"># 输入文件</span></span><br><span class="line">Modelerunknown.lib.html </span><br><span class="line">Modelerunknown.lib.lib <span class="comment"># 输出结果</span></span><br><span class="line">Modelerunknown.lib.stat <span class="comment">#结果统计</span></span><br></pre></td></tr></table></figure>

<p><code>Modelerunknown.lib.lib</code>中的fasta会有分类信息，如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;rnd-1_family-12<span class="comment">#Unknown ( RepeatScout Family Size = 705, Final Multiple Alignment Size = 88, Localized to 114 out of 117 contigs )|TEclass result: LTR|forward|ORFs: 583..2355:+1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，TEclass的输出结果是不被RepeatMasker所识别的，需要你更改原来的#Unknown为你的预测结果才行。</p>
</blockquote>
<p>其他参数:</p>
<ul>
<li><code>-c</code>: 训练的分类器所在路径, 默认是<code>TEclass-2.1classifiers</code></li>
<li><code>-o</code>: 输出结果路径，默认在当前文件下新建</li>
<li><code>-r</code>: 预测输入序列的反向互补序列</li>
</ul>
<p>参考文献:  TEclass: a tool for automated classification of unknown eukaryotic transposable elements</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/27/%E4%BD%BF%E7%94%A8TEclass%E5%AF%B9TE%E4%B8%80%E8%87%B4%E6%80%A7%E5%BA%8F%E5%88%97%E8%BF%9B%E8%A1%8C%E5%88%86%E7%B1%BB-classify-te-consensus-sequence-by-teclass/" data-id="cllgasdue00d3dkov0tq4fwxr" data-title="使用TEclass对TE一致性序列进行分类" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" rel="tag">注释 | 重复序列</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-使用Pilon对基因组进行polish-Polish-genome-assembly-by-pilon" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/27/%E4%BD%BF%E7%94%A8Pilon%E5%AF%B9%E5%9F%BA%E5%9B%A0%E7%BB%84%E8%BF%9B%E8%A1%8Cpolish-Polish-genome-assembly-by-pilon/" class="article-date">
  <time class="dt-published" datetime="2019-08-27T20:21:45.500Z" itemprop="datePublished">2019-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/27/%E4%BD%BF%E7%94%A8Pilon%E5%AF%B9%E5%9F%BA%E5%9B%A0%E7%BB%84%E8%BF%9B%E8%A1%8Cpolish-Polish-genome-assembly-by-pilon/">使用Pilon对基因组进行polish</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="使用Pilon对基因组进行polish"><a href="#使用Pilon对基因组进行polish" class="headerlink" title="使用Pilon对基因组进行polish"></a>使用Pilon对基因组进行polish</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>官方提供了编译好的jar包，方便使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/broadinstitute/pilon/releases/download/v1.22/pilon-1.22.jar</span><br><span class="line">java -Xmx16G -jar pilon-1.22.jar</span><br></pre></td></tr></table></figure>

<p>如果要顺利运行程序，要求JAVA &gt; 1.7, 以及根据基因组大小而定的内存，一般而言是1M大小的基因对应1GB的内存。</p>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>Pilon有如下作用</p>
<ol>
<li>对初步组装进行polish</li>
<li>寻找同一物种不同株系间的变异，包括结构变异检测</li>
</ol>
<p>他以FASTA和BAM文件作为输入，根据比对结果对输入的参考基因组进行提高，包括</p>
<ul>
<li>单碱基差异</li>
<li>小的插入缺失(indels)</li>
<li>较大的插入缺失或者block替换时间</li>
<li>填充参考序列中的N</li>
<li>找到局部的错误组装</li>
</ul>
<p>最后它输出polish后的FASTA文件, 以及包含变异信息的VCF文件(可选)</p>
<h2 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h2><p>推荐使用PCR-free建库测序得到的Illumina paired-end数据，这样子避免了PCR-duplication,有效数据更多，也不需要在分析过程中标记重复。</p>
<p>下面步骤，假设你的组装文件为<code>draft.fa</code>, 质量控制后的illumina双端测序数据分别为<code>read_1.fq.gz</code>和<code>read_2.fq.gz</code></p>
<p>第一步：比对</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bwa index -p index/draft draft.fa</span><br><span class="line">bwa mem -t 20 index/draft read_1.fq.gz read_2.fq.gz | samtools <span class="built_in">sort</span> -@ 10 -O bam -o align.bam</span><br><span class="line">samtools index -@ 10 align.bam</span><br></pre></td></tr></table></figure>

<p>第二步：标记重复（非PCR-free建库)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sambamba markdup -t 10 align.bam align_markdup.bam</span><br></pre></td></tr></table></figure>

<p>第三步：过滤高质量比对的read</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samtools view -@ 10 -q 30 align_markdup.bam &gt; align_filter.bam</span><br><span class="line">samtools index -@ 10 align_filter.bam</span><br></pre></td></tr></table></figure>

<p>第三步：使用Pilon进行polish</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MEMORY= <span class="comment">#根据基因组大小而定</span></span><br><span class="line">java -Xmx<span class="variable">$&#123;MEMORY&#125;</span>G -jar pilon-1.22.jar --genome draft.fa --frags align_filer.bam \</span><br><span class="line">    --fix snps,indels \</span><br><span class="line">    --output pilon_polished --vcf &amp;&gt; pilon.log</span><br></pre></td></tr></table></figure>

<p>关于Pilon的一些参数说明：</p>
<ul>
<li><code>--frags</code>表示输入的是1kb以内的paired-end文库，<code>--jumps</code>表示 大于1k以上的mate pair文库,  <code>--bam</code>则是让软件自己猜测</li>
<li><code>-vcf</code>: 输出一个vcf文件，包含每个碱基的信息</li>
<li><code>--fix</code>:  Pilon将会处理的内容，基本上选<code>snps</code>和<code>indels</code>就够了</li>
<li><code>--variant</code>: 启发式的变异检测，等价于<code>--vcf --fix all,breaks</code>, 如果是polish不要使用该选项</li>
<li><code>minmq</code>: 用于Pilon堆叠的read最低比对质量，默认是0。</li>
</ul>
<h2 id="阅读日志输出"><a href="#阅读日志输出" class="headerlink" title="阅读日志输出"></a>阅读日志输出</h2><blockquote>
<p>这个日志文件是标准输出而不是标准错误输出，不过保险起见用<code>&amp;&gt;</code></p>
</blockquote>
<p>最开始，Pilon会输出他的版本信息（如下示例），以及将会对基因组做的调整,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pilon version 1.14 Sat Oct 31 14:30:00 2015 -0400</span><br><span class="line">Genome: genome.fasta</span><br><span class="line">Fixing snps, indels</span><br></pre></td></tr></table></figure>

<p>其中Fixing后面的含义为：</p>
<ul>
<li>“snps”:  单碱基差异</li>
<li>“indels”:小的indel的差异</li>
<li>“amb”:  替换原有的N</li>
<li>“gaps”: 填充基因组的gap</li>
<li>“local”： 检测和修改错误组装</li>
<li>“all”:  上述所有</li>
<li>“none”: 不是上述的任何一种</li>
</ul>
<p>接着Pilon会分染色体对BAM文件进行处理，根据BAM文件进行堆叠(pileup), 这个时候它会输出有效reads的深度，这里的有效reads包括未成对的read和正确成对的read。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Processing ctg1:1-5414473</span><br><span class="line">frags align_mkdup.bam: coverage 19</span><br><span class="line">Total Reads: 808985, Coverage: 19, minDepth: 5</span><br></pre></td></tr></table></figure>

<p>从Pilon v1.4开始，Pilon还会输出基因组得到确认的碱基比例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Confirmed 5403864 of 5414473 bases (99.80%)</span><br></pre></td></tr></table></figure>

<p>后续是Pilon将会对原参考基因组做的一些调整的总体情况，如下表示纠正2个snp, 2个小的插入，4个缺失。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Corrected 2 snps; 0 ambiguous bases; corrected 2 small insertions totaling 12 bases, 4 small deletions totaling 6 bases</span><br></pre></td></tr></table></figure>

<p>最后声明当前部分处理结束</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Finished processing ctg1:1-5414473</span><br></pre></td></tr></table></figure>

<p>如果，在<code>--fix</code>中选了<code>gaps</code>, 那么输出的内容还有如下内容。其中<code>82048 -0 +276</code>解释为在坐标82428处移除0个碱基，插入276个碱基。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Attempting to fill gaps</span></span><br><span class="line">fix gap: scaffold00001:82428-93547 82428 -0 +276 ClosedGap</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考资料</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/broadinstitute/pilon/wiki/Standard-Output">https://github.com/broadinstitute/pilon/wiki/Standard-Output</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/broadinstitute/pilon/wiki/Methods-of-Operation">https://github.com/broadinstitute/pilon/wiki/Methods-of-Operation</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/27/%E4%BD%BF%E7%94%A8Pilon%E5%AF%B9%E5%9F%BA%E5%9B%A0%E7%BB%84%E8%BF%9B%E8%A1%8Cpolish-Polish-genome-assembly-by-pilon/" data-id="cllgasdtc00brdkov0kfrezri" data-title="使用Pilon对基因组进行polish" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何使用MUMmer比对大片段序列-Using-MUMmer-to-align-genome" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8MUMmer%E6%AF%94%E5%AF%B9%E5%A4%A7%E7%89%87%E6%AE%B5%E5%BA%8F%E5%88%97-Using-MUMmer-to-align-genome/" class="article-date">
  <time class="dt-published" datetime="2019-08-27T20:18:54.545Z" itemprop="datePublished">2019-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8MUMmer%E6%AF%94%E5%AF%B9%E5%A4%A7%E7%89%87%E6%AE%B5%E5%BA%8F%E5%88%97-Using-MUMmer-to-align-genome/">如何使用MUMmer比对大片段序列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="如何使用MUMmer比对大片段序列"><a href="#如何使用MUMmer比对大片段序列" class="headerlink" title="如何使用MUMmer比对大片段序列"></a>如何使用MUMmer比对大片段序列</h1><p>测序技术刚开始发展的时候，大家得到的序列都是单个基因的长度，所以一般都是逐个基因的比较，用的都是BLAST或FASTA通过逐个基因联配的方式搜索数据库。但是1999年后，越来越多的物种全基因组出现，比如说在1999年出现了_Helicobacter pylori_的第二类菌株的基因组序列，就需要研究同一物种不同品系进化过程的基因组变化，比如说基因倒置现象。传统的BLAST&#x2F;FASTA就用不了，就需要用到新的工具，这就是MUMmer出现的历史背景。</p>
<p>那么MUMmer能用来研究什么呢？比如说细菌的不同菌株基因组中倒置现象，人和老鼠的基因组在进化上的重排现象。还有比较同一物种的不同组装结果等。MUMmer的算法基础(suffix tree)使得它的速度比BLASTZ(k-mers)快得多，但是灵敏度低，也就是检测不到比较弱的匹配，但是作者说这都是可以通过修改参数进行改善</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>MUMmer是开源软件，因此可以通过下载源码编译的方式进行安装，同时biconda上已经有编译好的二进制版本方便用conda进行安装。目前，我个人比较推荐使用源码编译的方式进行安装。目前MUMmer已经更新到第四版，但是还在测试中，所以文章也没有发，求稳还是用3.23.</p>
<blockquote>
<p>多说一句，如果在bioconda频道上搜索mummer, 会发现一个pymummer，不要以为这是mummer的源代码用python改写，它仅仅做到了通过调用系统安装的MUMmer的工具的方式运行而已，并且功能目前实在是太弱了。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MUMmer3.23</span></span><br><span class="line">wget https://gigenet.dl.sourceforge.net/project/mummer/mummer/3.23/MUMmer3.23.tar.gz</span><br><span class="line">tar -xf MUMmer3.23.tar.gz</span><br><span class="line"><span class="built_in">cd</span>  MUMmer3.23</span><br><span class="line">make install</span><br><span class="line"><span class="comment"># MUMmer4.00-beta2</span></span><br><span class="line">wget https://github.com/mummer4/mummer/releases/download/v4.0.0beta2/mummer-4.0.0beta2.tar.gz</span><br><span class="line">tar xf mummer-4.0.0beta2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> mummer-4.0.0beta2</span><br><span class="line">./configure --prefix=<span class="variable">$HOME</span>/biosoft/mummer-4.0.0beta2 &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>为了方便使用记得将软件路径加入PATH。</p>
<h2 id="MUMmer使用方法"><a href="#MUMmer使用方法" class="headerlink" title="MUMmer使用方法"></a>MUMmer使用方法</h2><p>MUMmer的核心基于 <em>Maximal exact matching</em> 算法开发的<code>mummer</code>。其他工具(<code>nucmer</code>,<code>promer</code>)都是基于<code>mummer</code>的开发的流程。这些流程的分析策略分为三步：</p>
<ol>
<li>用<code>mummer</code>在两个输入中找<strong>给定长度</strong>的极大唯一匹配( <em>Maximal exact matching</em> )</li>
<li>然后将这些匹配区域<strong>聚类</strong>成较大不完全联配区域, 作为锚定点(anchor)</li>
<li>最后它从每个匹配外部扩展联配, 形成有gap的联配。</li>
</ol>
<h3 id="Maximal-exact-matching"><a href="#Maximal-exact-matching" class="headerlink" title="Maximal exact matching"></a>Maximal exact matching</h3><p>MUMmer核心是基于后缀树(suffix tree)数据结构的最大匹配路径。 根据这个算法开发出来的<code>repeat-match</code>和<code>exact-tandems</code>可以从单个序列中检测重复，<code>mummer</code>则是用于联配两条或两条以上的序列。由于MUMmer的其他工具基本都是基于mummer开发的，于是理解mummer就变得非常重要。</p>
<blockquote>
<p>概念1：suffix tree: 表示一个字符串的所有子字符串的数据结构，比如说abc的所有子字符串就是a,ab,ac,bc,abc.<br>概念2：Maximal Unique Match: 指的是匹配仅在两个比较序列中各出现一次</p>
</blockquote>
<p><strong>mummer</strong>: 基于后缀树(suffix tree)数据结构，能够在两条序列中有效定位极大唯一匹配(<em>maximal unique matches</em>)，因此它比较适用于产生一组准确匹配(exact matches)以点图形式展示，或者用来锚定从而产生逐对联配(pair-wise alignments)</p>
<p>大部分情况下都不会直接用到<code>mummer</code>，所以只要知道MUMmer历经几次升级，使得<code>mummer</code>可以能够只找在reference和query都唯一的匹配(第一版功能)，也可以找需要在reference唯一的匹配(第二版新增)，甚至不在乎是否唯一的匹配(第三版新增),参数分别为<code>-mum</code>,<code>-mumreference</code>,<code>maxmatch</code>。</p>
<p><strong>repeat-match</strong>和<strong>exact-tandems</strong>比较少用，毕竟参数也不多，似乎有其他更好的工具能用来寻找序列中的重复区。</p>
<h3 id="Clustering-聚类"><a href="#Clustering-聚类" class="headerlink" title="Clustering:聚类"></a>Clustering:聚类</h3><p><code>MUMmer</code>的聚类算法能够比较智能地把几个独立地匹配按照顺序聚成一块。分为两种模式<code>gaps</code>和<code>mgaps</code>。这两者差别在于是否允许重排,分别用于<code>run-mummer1</code>,<code>run-mummer3</code>.</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-0253b2e225d9b1ee-618c91073ab347c0b055eab1cc466dea.gif" alt="gaps"><br><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-af765e2d4c9d861d-03f5a9dd03e941ea8758b0be5ac2968f.gif" alt="mgaps"></p>
<blockquote>
<p>基于<code>gap</code>和<code>mgaps</code>的输出，第四版还提供了<code>annotate</code>和<code>combineMUMs</code>两个工具增加联配信息。</p>
</blockquote>
<h3 id="联配构建工具"><a href="#联配构建工具" class="headerlink" title="联配构建工具"></a>联配构建工具</h3><p>基于上述两个工具，作者编写了4个工作流程，方便实际使用。</p>
<ul>
<li><code>nucmer</code>: 由Perl写的流程，用于联配很相近(closely related)核酸序列。它比较适合<strong>定位和展示高度保守的DNA序列</strong>。注意，为了提高nucmer的精确性，最好把输入序列先做<strong>遮盖(mask)<strong>避免不感兴趣的序列的联配，或者</strong>修改单一性限制</strong>降低重复导致的联配数。</li>
<li><code>promer</code>：也是Perl写的流程，它以翻译后的<strong>氨基酸序列</strong>进行联配，工作原理同<code>nucmer</code>.</li>
<li><code>run-mummer1</code>,<code>run-mummer3</code>： 两者是基于cshell写的流程，用于两个序列的常规联配，和promer,nucmer类似，只不过能够自动识别序列类型。它们擅长联配<strong>相似度高</strong>的DNA序列，找到它们的不同，也就是适合找SNP或者纠错。前者用于1v1无重排，后者1v多有重排</li>
</ul>
<p>重点介绍一下<code>nucmer</code>的使用。reference和query文件都需要时fasta格式，每个都可以有多条序列。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nucmer [options] &lt;reference&gt; &lt;query file&gt;</span><br></pre></td></tr></table></figure>

<p>参数我将其分为五个部分，匹配算法，聚类，外延、其他和新增</p>
<p>匹配:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--mum, --mumreference(默认), --maxmatch</span><br><span class="line">--minmatch/-l: 单个匹配最小长度</span><br><span class="line">--forwoard/-f, --reverse/-r: 只匹配正链或只匹配负链。</span><br></pre></td></tr></table></figure>

<p>聚类：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--mincluster/-c: 用于聚类的匹配最低长度，默认65</span><br><span class="line">--maxgap/-g: 两个相邻匹配间的最大gap长度，默认90</span><br><span class="line">--diagdiff/-D: 一个聚类中两个邻接匹配，最大对角差分，默认5</span><br><span class="line">--diagfactor/-d: 也是和对角差分相关参数，只不过和gap长度有关，默认0.12</span><br></pre></td></tr></table></figure>

<p>外延:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--breaklen/-b: 在对联配两端拓展式，在终止后继续延伸的程度，默认200</span><br><span class="line">--[no]extend：是否外延，默认是</span><br><span class="line">--[no]optimize：是否优化，默认是。即在联配分数较低时不会立刻终止，而是回顾整条联配，看能否苟延残喘一会。</span><br></pre></td></tr></table></figure>

<p>其他:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--depend: 显示依赖信息后退出</span><br><span class="line">--coords: 调用show-coords输出坐标信息</span><br><span class="line">--prefix/-p: 输出文件的前缀</span><br><span class="line">--[no]delta: 是否输出delta文件，默认是</span><br></pre></td></tr></table></figure>

<p><strong>新增</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在第四版新增的参数</span></span><br><span class="line">--threads/-t: 多核心</span><br><span class="line">---delta=PATH: 指定位置，而不是当前</span><br><span class="line">--sam-short=PATH：保存为SAM短格式，不保存匹配的序列，也就是第十列为*</span><br><span class="line">--sam-long=PATH： 保存为SAM长格式，保存匹配的序列</span><br><span class="line">--save=PREFIX：保存suffix array</span><br><span class="line">--load=PREIFX：加载suffix array</span><br></pre></td></tr></table></figure>

<p>运行后得到一个delta格式的文件，它的作用是记录每个联配的坐标，每个联配中的插入和缺失的距离。下面逐行进行解释</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/home/username/reference.fasta /home/username/query.fasta <span class="comment"># 两个比较文件的位置</span></span><br><span class="line">PROMER <span class="comment"># 程序运行类型： NUCMER或PROMER</span></span><br><span class="line">&gt;tagA1 tagB1 3000000 2000000 <span class="comment"># 一组联配(可以有多个小匹配)，ref的fastaID，qry的fastaID，ref序列长度，qry序列长度</span></span><br><span class="line">1667803 1667078 1641506 1640769 14 7 2 <span class="comment"># 第一小组 ref起始，ref结束，qry起始，qry结束，错误数(不相同碱基+indel碱基数)，相似错误(非正匹配得分) 终止密码子(NUCMER为0)。 如果结束大于起始，表示在负链。</span></span><br><span class="line">-145 <span class="comment"># qry的145有插入</span></span><br><span class="line">-3   <span class="comment"># qry的145+3=148有插入</span></span><br><span class="line">-1   <span class="comment"># qry的145+3+1=149有插入</span></span><br><span class="line">40   <span class="comment"># qry的145+3+1+40=149有缺失</span></span><br><span class="line">0 <span class="comment"># 表示当前匹配结束</span></span><br><span class="line">1667804 1667079 1641507 1640770 10 5 3 <span class="comment"># 第二小组</span></span><br><span class="line">-146</span><br><span class="line">-1</span><br><span class="line">-1</span><br><span class="line">-34</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h4 id="用法举例"><a href="#用法举例" class="headerlink" title="用法举例"></a>用法举例</h4><h5 id="两个完整度高的基因组"><a href="#两个完整度高的基因组" class="headerlink" title="两个完整度高的基因组"></a>两个完整度高的基因组</h5><p>比较常见的用法是把一条连续的序列和另一条连续的序列比。比如说两个细菌的菌株,直接用<code>mummer</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://mummer.sourceforge.net/examples/data/H_pylori26695_Eslice.fasta</span><br><span class="line">wget http://mummer.sourceforge.net/examples/data/H_pyloriJ99_Eslice.fasta</span><br><span class="line">mummer -mum -b -c H_pylori26695_Eslice.fasta H_pyloriJ99_Eslice.fasta &gt; 26695_J99.mums</span><br><span class="line"><span class="comment"># -mum: 计算在两个序列中唯一的最大匹配数</span></span><br><span class="line"><span class="comment"># -b: 计算正向和反向匹配数</span></span><br><span class="line"><span class="comment"># -c: 报告反向互补序列相对于原始请求序列的位置</span></span><br></pre></td></tr></table></figure>

<p>或者是<strong>高度相似</strong>序列，不含重排</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run-mummer1 ref.fasta qry.fasta ref_qry</span><br><span class="line"><span class="comment"># 仅报告负链匹配序列</span></span><br><span class="line">run-mummer1 ref.fasta qry.fasta ref_qry -r</span><br></pre></td></tr></table></figure>

<p>或者是<strong>高度相似</strong>序列，存在重排现象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run-mummer3 ref.fasta qry.fasta ref_qry</span><br></pre></td></tr></table></figure>

<p>以上的<code>run-mummer*</code>比较关注序列的不同之处，那么对于<strong>相似度没有那么高</strong>的两个序列，就需要用到<code>nucmer</code>。<code>nucmer</code>关注序列的相似之处，所以它允许重排，倒置和重复现象。<code>nucmer</code>允许多对多的比较方式，当然比较常用的是多对一的比较。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nucmer --maxgap=500 --mincluster=100 --prefix=ref_qry ref.fasta qry.fasta</span><br><span class="line"><span class="comment">## --maxgap: 两个match间最大gap为500</span></span><br><span class="line"><span class="comment">##--minclster: 至少要有100个match才能算做一簇</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意一点： 第四版中<code>run-mummer1, run-mummer3</code>已经被废弃了，就是尽管保留了，但是没有对它做任何升级的意思。</p>
</blockquote>
<p>如果是<strong>有点差异</strong>的两个序列，可以用翻译的氨基酸序列进行比较</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promer --prefix=ref_qry ref.fasta qry.fasta</span><br></pre></td></tr></table></figure>

<h5 id="两个基因草图"><a href="#两个基因草图" class="headerlink" title="两个基因草图"></a>两个基因草图</h5><p>上面都是两条序列间的比较，但是研究植物的人更容易遇到的是两个物种的基因组都只有scafold级别，甚至是contig级别。那么就可以使用<code>nucmer</code>或<code>promer</code>构建序列间的可能联配。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先过滤低于1kb的序列</span></span><br><span class="line">bioawk -c fastx <span class="string">&#x27;&#123;if (length($seq) &gt; 1000) print &quot;&gt;&quot;$name &quot;\n&quot;$seq&#125;&#x27;</span> ~/reference/genome/rice_contigs/HP1 &gt; HP103_1kb.fa</span><br><span class="line">bioawk -c fastx <span class="string">&#x27;&#123;if (length($seq) &gt; 1000) print &quot;&gt;&quot;$name &quot;\n&quot;$seq&#125;&#x27;</span> ~/reference/genome/rice_contigs/HP119.fa &gt; HP119_1kb.fa</span><br><span class="line"><span class="comment"># 处理，时间会比较久，因为分别有20109，17877条contig</span></span><br><span class="line">nucmer --prefix HP103_HP119 HP103_1kb.fa HP119_1kb.fa &amp;</span><br></pre></td></tr></table></figure>

<h5 id="一个基因草图对一个完整基因组"><a href="#一个基因草图对一个完整基因组" class="headerlink" title="一个基因草图对一个完整基因组"></a>一个基因草图对一个完整基因组</h5><p>这里可以比较一下水稻日本晴基因组和其他地方品种</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nucmer  --prefix IRGSP1_DHX2 ~/reference/genome/IRGSP1.0/IRGSP-1.0_genome.fasta ~/reference/genome/rice_contigs/DHX2.fa</span><br><span class="line"><span class="comment"># 第四版提供SAM输出和多核支持</span></span><br><span class="line">~/biosoft/mummer-4.0.0beta2/bin/nucmer -t 15 --sam-short=SAM_OUT/DHX2 ~/reference/genome/IRGSP1.0/IRGSP-1.0_genome.fasta ~/reference/genome/rice_contigs/DHX2.fa &amp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在第四版中新增了一个<code>dnadiff</code>，进一步封装<code>nucmer</code>和其他数据整理工具，基本上没啥参数，而输出很齐全，非常的人性化。在不知如何开始的时候，可以无脑用这个。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 已有delta文件</span></span><br><span class="line">dnadiff -d IRGSP1_DHX2.delta</span><br><span class="line"><span class="comment"># 未有delta文件</span></span><br><span class="line">dnadiff IRGSP1_DHX2 ~/reference/genome/IRGSP1.0/IRGSP-1.0_genome.fasta ~/reference/genome/rice_contigs/DHX2.fa</span><br></pre></td></tr></table></figure>

<h2 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a>数据整理</h2><p>之前得到的数据还需要用<code>delta-filter</code>,<code>show-coords</code>和<code>show-tilling</code>进行进一步整理才能用于后续的分析。后续操作基于上面的基因草图和完成基因组比较结果。</p>
<p>最初的比对结果保留了最多的信息，需要用<code>delta-filter</code>进行一波过滤，除去不太合适的部分。过滤选项有</p>
<ul>
<li><code>-i</code>: 最小的相似度 [0,100], 默认0</li>
<li><code>-l</code>: 最小的匹配长度 默认0.</li>
<li><code>-u</code>: 最小的联配唯一度 [0,100], 默认0</li>
<li><code>-o</code>: 最大重叠度，针对<code>-r</code>和<code>-q</code>设置。 [0,100], 默认100</li>
<li><code>-g</code>: 1对1全局匹配，不允许重排</li>
<li><code>-1</code>: 1对1联配，允许重排，是<code>-r</code>和<code>-q</code>的交集</li>
<li><code>-m</code>: 多对对联配，允许重排，是<code>-r</code>和<code>-q</code>的合集。</li>
<li><code>-q</code>: 仅保留每个query在reference上的最佳位置,允许多条query在reference上重叠</li>
<li><code>-r</code>: 仅保留每个reference在query上的最佳位置,允许多条reference在query上重叠</li>
</ul>
<p>以上顺序是<code>-i -l -u -q -r -g -m -1</code>.光看参数估计不太明白，来一波图解。referece的一个片段可以联配到query的多个片段上，同样的query的一个片段也可以联配到reference的多个片段上，那么如何取舍呢？</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-22510b4f02161663-a24f4839916849139ea95f8c1870400c.jpg" alt="多对多"></p>
<p>通过<code>-i</code>,<code>-l</code>可以先过滤一些比较短，并且相似度比较低的匹配情况。进一步，计算长度和相似度的乘积(加权最长增加子集)，对于<code>-q</code>而言就是保留左2，对于<code>-r</code>则是保留右3. 这就是传说中的三角关系，这种关系可以用<code>-m</code>保留或者用<code>-q</code>消灭。</p>
<p>比如说我想看contig和reference两者唯一匹配，并且长度在1000，相似度大于90.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delta-filter -i 89 -l 1000 -1 IRGSP1_DHX2.delta &gt; IRGSP1_DHX2_i89_l1000_1.delta.filter</span><br></pre></td></tr></table></figure>

<p>如何才能验证上面参数运行的结果是符合要求的呢？毕竟数据分析第一原则“不要轻易相信分析结果，需要多次验证才能使用”。</p>
<p>可以先用<code>show-coord</code>以人类可读的格式显示匹配的坐标。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show-coords -r IRGSP1_DHX2_i89_l1000_1.delta.filter &gt; IRGSP1_DHX2_i89_l1000_1.coord</span><br><span class="line"><span class="comment"># -r：以refID排序，相对的，还有-q，以queryID排序</span></span><br><span class="line">less IRGSP1_DHX2_i89_l1000_1.coord</span><br></pre></td></tr></table></figure>

<p>不难发现这个位置锚定的非常不错，至少暂时看起来没有重叠之处</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-22d43cfb51512b11-8b277c2214a3461cb1a8f391e5448ee5.jpg" alt="coord信息"></p>
<p>用<code>show-aligns</code>看某一个匹配的序列比对情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show-aligns IRGSP1_DHX2_i89_l1000_1.delta.filter chr01 DHX2_00006753 | less</span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-a34cd3bd38efe73e-ea70a7ac864f4edfb78414df00eba7f3.jpg" alt="alignment"></p>
<p>针对reference有很长的组装序列的情况，还可以用<code>show-tilling</code>将contig回贴到reference上，如果装了gnuplot还能用<code>mummerplot</code>可视化点图.<code>show-tiling</code>会尝试根据contig和reference匹配信息构建出tiling path(不好翻译呀。。)，不怎么用得到。</p>
<p><code>show-snps</code>可以根据delta文件整理出SNP信息，我表示也没有怎么用到。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8MUMmer%E6%AF%94%E5%AF%B9%E5%A4%A7%E7%89%87%E6%AE%B5%E5%BA%8F%E5%88%97-Using-MUMmer-to-align-genome/" data-id="cllgasdv400fkdkov30kk2ubv" data-title="如何使用MUMmer比对大片段序列" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SAMtools_ SAM格式的处理利器-samtools-usage-documents" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/27/SAMtools_%20SAM%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86%E5%88%A9%E5%99%A8-samtools-usage-documents/" class="article-date">
  <time class="dt-published" datetime="2019-08-27T19:50:29.749Z" itemprop="datePublished">2019-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/27/SAMtools_%20SAM%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86%E5%88%A9%E5%99%A8-samtools-usage-documents/">SAMtools:SAM格式的处理利器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="SAM格式介绍"><a href="#SAM格式介绍" class="headerlink" title="SAM格式介绍"></a>SAM格式介绍</h2><p>SAM全称是Sequence Alignment&#x2F;Map, 是目前最常用的存放比对或联配数据的格式。无论是重测序，还是转录组，还是表观组，几乎所有流程都会产生SAM&#x2F;BAM文件作为中间步骤，然后是后续专门的分析过程。</p>
<p>以一个简单的例子介绍.第一幅图表示read和参考基因组比对可能出现的情况。r001&#x2F;2表示paired end数据。r003是嵌合read，r004则是原序列打断后比对结果。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-0bd4d534d1e2a601-3b9976cd770a443f93b11b5e58d8acee.jpg" alt="原始数据"></p>
<p>经过专门的比对软件，如BWA,BOWTIE2等，得到的SAM文件如下所示,需要研究的就是如下这几行。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-1db9c0789e0e4e07-c8be7037bbd4477d9828cd462df64849.jpg" alt="比对后存放形式"></p>
<h3 id="术语和概念"><a href="#术语和概念" class="headerlink" title="术语和概念"></a>术语和概念</h3><p>在学习SAM格式之前，请确认自己是否对如下概念有清楚的认识|</p>
<ul>
<li>read: 测序仪返回的原始序列.一个read可以包括多个segment。read之间的先后顺序表示被测序仪读到的时间前后关系.</li>
<li>segment:  一段连续的序列或子序列</li>
<li>linear alignment: 线性联配表示一个read比对到单个参考序列，可以存在插入，缺失，跳过(skip),剪切(clip), 但是不存在方向改变的情况(比如说一部分和正向链联配，另一个位置则是和负向链联配）。最简单的判断的方式就是，一个linear alignment只用一行记录。</li>
<li>chimeric alignment: 嵌合联配需要多行记录。比如说r003第一个记录是后6个匹配，第二个记录则是反向序列的后5个匹配。第一个被称之为”representative”,其他都是”supplementary”</li>
<li>read alignment: 无论是linear alignment, 还是chimeric alignment, 只要能完整表示一个read，都成为是read alignment</li>
<li>multiple mapping: 由于存在重复区，一个read 可能比对到参考基因组的不同区域。其中一个被认为是primary，其他都是secondary.</li>
<li>两个系统|1-based coordinate system（SAM,VCF,GFF,wiggle)和0-based coordinate system(BAM, BCFv2, BED, PSL).自行用R和Python感受一下两者的不同。</li>
</ul>
<blockquote>
<p>chimeric alignment 可能是结构变异，基因融合，参考序列误组装，RNA-Seq，实验protocol等因素造成。对于chimeric alignment的里面每一个linear alignment而言，由于相互之前不存在重叠，故而联配质量较高，适合用于SNP&#x2F;INDEL calling.相反, multiple mapping则是因为重复造成(read越长出现的概率越低), 相互之间存在重叠，仅有其中一条有最优的匹配，其他联配质量过低会被SNP&#x2F;INDEL caller忽略。</p>
</blockquote>
<h3 id="第一部分-SAM-Header-非强制"><a href="#第一部分-SAM-Header-非强制" class="headerlink" title="第一部分| SAM Header(非强制)"></a>第一部分| SAM Header(非强制)</h3><p>这个部分能够被<code>/^@[A-Z][A-Z](t[A-Za-z][A-Za-z0-9]:[ -~]+)+$/</code>或<code>/^@COt.*/</code>这两个表达式进行匹配。比如说你随便有一个BAM文件（包含header）,就能被这个表达式进行匹配。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samtools view -h S43S1-M_H3K5FDMXX_L1_sort.bam </span><br><span class="line">| awk &#x27;$0 ~ /^@[A-Z][A-Z](t[A-Za-z][A-Za-z0-9]:[ -~]+)+$/ &#123; print $0&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-6b45ac06bb250dd7-e15291c1683440f99f97ba9eae1bedd0.jpg" alt="header"></p>
<p>其中第一行<code>@HD</code>，表示参考基因组的排序情况. 然后<code>@SQ</code>则是参考基因组的每一条序列的具体信息，命名和长度。<code>@PG</code>记录运行的命令，以便你检查代码。对于GATK还需要提供<code>@RG</code>给出每个read所在group的信息，只要保证是独一即可。</p>
<h3 id="第二部分-联配必要信息"><a href="#第二部分-联配必要信息" class="headerlink" title="第二部分| 联配必要信息"></a>第二部分| 联配必要信息</h3><p>第二部分具体记录每一个read的联配结果，一共有11+n列。我将第二张图的信息复制保存到test.sam中，仅仅看第一行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">samtools view test.sam | head -n1 | tr &#x27;t&#x27; &#x27;n&#x27; | nl</span><br><span class="line">   1  r001                   # QNAME: read信息</span><br><span class="line">   2  99                     # FLAG: 信息量大</span><br><span class="line">   3  ref                    # RNAME: 参考序列</span><br><span class="line">   4  7                      # POS:比对到的位置</span><br><span class="line">   5  30                     # MAPQ: 比对质量</span><br><span class="line">   6  8M2I4M1D3M             # CIGAR: 信息量大</span><br><span class="line">   7  =                      # RNEXT: 配对read所在序列，=表示同一条序列</span><br><span class="line">   8  37                     # PNEXT: 配对read所在位置</span><br><span class="line">   9  39                     # TLENT: 观察到的模板长度</span><br><span class="line">  10  TTAGATAAAGGATACTG      # SEQ: segment序列</span><br><span class="line">  11  *                      # QUAL: segment的质量</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">*表示信息不存在</span></span><br></pre></td></tr></table></figure>

<p>简单解释TLENT: 通过IGV可视化展示克制，TLENT相当于read发现了参考序列那些区域。如果是PE数据还可以推断出文库平均大小。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-e9bf3249407e89c5-7310bdf13fbe4e5291323ec4d0e31b47.jpg" alt="一个PE数据"><br><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-ade968d846e1503b-a08ed8269aa84adfa0af0c67dd2dea13.jpg" alt="IGV展示"></p>
<p>详细介绍FLAG: FLAG的主要目的就是用较少的记录长度表示当前记录的序列的匹配情况。相当于开关，仅有有无两个状态，有某个数值就表示序列符合某个情况。</p>
<table>
<thead>
<tr>
<th align="center">flag</th>
<th align="center">代表</th>
<th align="left">具体含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1(0x1)</td>
<td align="center">PAIRED</td>
<td align="left">代表这个序列采用的是PE双端测序</td>
</tr>
<tr>
<td align="center">2(0x2)</td>
<td align="center">PROPER_PAIR</td>
<td align="left">代表这个序列和参考序列完全匹配，没有插入缺失</td>
</tr>
<tr>
<td align="center">4(0x4)</td>
<td align="center">UNMAP</td>
<td align="left">代表这个序列没有mapping到参考序列上</td>
</tr>
<tr>
<td align="center">8(0x8)</td>
<td align="center">MUNMAP</td>
<td align="left">代表这个序列的另一端序列没有比对到参考序列上，比如这条序列是R1,它对应的R2端序列没有比对到参考序列上</td>
</tr>
<tr>
<td align="center">16(0x10)</td>
<td align="center">REVERSE</td>
<td align="left">代表这个序列比对到参考序列的负链上</td>
</tr>
<tr>
<td align="center">32(0x20)</td>
<td align="center">MREVERSE</td>
<td align="left">代表这个序列对应的另一端序列比对到参考序列的负链上</td>
</tr>
<tr>
<td align="center">64(0x40)</td>
<td align="center">READ1</td>
<td align="left">代表这个序列是R1端序列， read1;</td>
</tr>
<tr>
<td align="center">128(0x80)</td>
<td align="center">READ2</td>
<td align="left">代表这个序列是R2端序列，read2；</td>
</tr>
<tr>
<td align="center">256(0x100)</td>
<td align="center">SECONDARY</td>
<td align="left">代表这个序列不是主要的比对，一条序列可能比对到参考序列的多个位置，只有一个是首要的比对位置，其他都是次要的</td>
</tr>
<tr>
<td align="center">512(0x200)</td>
<td align="center">QCFAIL</td>
<td align="left">代表这个序列在QC时失败了，被过滤不掉了（# 这个标签不常用）</td>
</tr>
<tr>
<td align="center">1024(0x400)</td>
<td align="center">DUP</td>
<td align="left">代表这个序列是PCR重复序列（#这个标签不常用）</td>
</tr>
<tr>
<td align="center">2048(0x800)</td>
<td align="center">SUPPLEMENTARY</td>
<td align="left">代表这个序列是补充的比对（#这个标签具体什么意思，没搞清楚，但是不常用）</td>
</tr>
</tbody></table>
<p>举例说明，比如说实例中的99&#x3D;64+32+2+1, 也就是这个记录所代表的read是来自于双端测序R1，且匹配的非常好，对应的另一条链匹配到了负链(自己是正链)。而147&#x3D;128+16+2+1则是表示这个记录来自于双端测序的R2,完全匹配到负链. 如果是163和83，你会发现163&#x3D;147-16+32, 83&#x3D;99-32+16,也就是刚好和前面的不同，也就是说R1匹配负链，R2匹配正链。如果是81和161，由于161&#x3D;163-2,81&#x3D;83-2. 表明这些read不是完全匹配，存在插入缺失</p>
<p>那么问题来了,如下是我某一次比对的flag的统计情况，你能看出什么来</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-0bc3d3108151aea9-ea0a8dac31c34f52862b7840e65d2555.jpg" alt="小测试"></p>
<p><strong>常见的FLAGs</strong>:</p>
<ul>
<li>其中一条reads没有map上: 73, 133, 89 121, 165, 181, 101, 117, 153, 185, 59, 137</li>
<li>两条reads都没有map上: 77,141</li>
<li>比对上了，方向也对，也在插入大小(insert size)内: 99, 147, 83, 163</li>
<li>比对上了，也在插入大小(insert size)内， 但是反向不对:67, 131, 115, 179</li>
<li>单一配对，就是插入大小(insert size)不对: 81, 161, 97, 145, 65, 129, 113, 177</li>
</ul>
<p>FLAG仅仅存储比对的大致情况，每条比对上的read的实际情况则是要用CIGAR进行记录. 依旧举几个例子,比如说，这是双端测序的一条read比对情况，其中一个是117表示没有匹配上，所以记录就是<code>*</code>,另一个是185表示这条序列完美匹配，所以记录是<code>150M</code>.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ST-E00600:109:H3K5FALXX:2:1103:17996:34788      117     Chr1    38      0       *       =       38      0       TTTATACACTATGATTTTCAAAGTGAGAATCCGGTTTGTGGTTTATTGTTTTAGGTATTTAGTTATTAATGTATTTTGGATTTATTGATTTAGTGTTTTAGTGATTAATTATTCATTGTTTTAGTGTTTATGGTTTAGTGTTTAGGGTTT  J-7-J------JJJ7JJJ-J-J---JJ-----JJJJJ--J-JJJJ-----JJ--JJJJJJ-J--JJJ7JJ-7-J-J-777JJJJ777JJ7JJ77J7JJJJ7777JJ77777JJJ777J77J77J7JJJJ77JJJJJJJ7JJJJJJFFFAA  MC:Z:150M       AS:i:0  XS:i:0</span><br><span class="line">ST-E00600:109:H3K5FALXX:2:1103:17996:34788      185     Chr1    38      60      150M    =       38      0       CATTAATCCCTAAATCCCTAAATCTTTAAATCCTACATCCATGAATCCCTAAATAACTAATTCCCTAAACCCGAAACCTGTTTCTCTGGTTGAAAATCATTGTGTATATAATGATAATTTTATCGTTTTTATGTAATTGCTTATTGTTTT  J-JJ7JJJ-JJJ7JJ--JJJ--JJ-JJJJJJ-JJJJJJ--J-JJJJJJJJJ--JJ-JJJJJJJ-JJJJ--J----J-J--JJJJJJ777JJJ77J7JJJJJJJ7JJJJJ7JJJJJ77JJJJJJ7JJ7JJJ7JJJJJJJJJJJJJJFFF&lt;A  NM:i:4  MD:Z:1C53C22G69G1       AS:i:136        XS:i:0</span><br></pre></td></tr></table></figure>

<p>来一个复杂的例子<code>69H10M3I31M37H</code>，表示150bp的读长，先删掉69个碱基，后面是10个匹配，后面相比较参考基因组有3个插入，随后是31个匹配，最后再剔除37个基因,通过IGV查看在参考基因组的情况如下图所示。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-90fdafbe0c86de64-28e3859cf8ed4fc1bcef912acd3e2d6f.jpg" alt="IGV查看FLAGS"></p>
<p>我还发现这段区域存在特别多的clip，加载GFF查看注释信息后发现这是内含子区域。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-a3cec89579792559-b2d659fc3dba4625b3c3e50bf41da961.jpg" alt="IGV检查"></p>
<p>实际上，CIGAR一共有9个字符，分别是M(alignment match),I(insertion),D(deletion),N(skip),S(soft clip),H(hard clip),P(padding),&#x3D;(sequence match), X(sequence mismatch).值得提醒就是M表示序列能够联配，但是存在碱基不一致，&#x3D;表示碱基相同。S和H一般用于read前后出现大部分的错配，但是中间能够联配的情况，其中S表示序列会出现在SEQ中，H则不会出现在SEQ列中。</p>
<h3 id="第三部分，可选信息"><a href="#第三部分，可选信息" class="headerlink" title="第三部分，可选信息"></a>第三部分，可选信息</h3><p>除了之前的11列必须要有的信息外，后面的其他列都是不同的比对软件自定义的额外信息，称之为标签（TAG)。标签的格式一般为<code>TAG:TYPE:VALUE</code>，比如说<code>NM:i:4 MD:Z:1C53C22G69G1 AS:i:136 XS:i:0</code>。这部分内容见<a target="_blank" rel="noopener" href="http://samtools.github.io/hts-specs/SAMtags.pdf">http://samtools.github.io/hts-specs/SAMtags.pdf</a>. 介绍几个比较常见的标签</p>
<ul>
<li>NM: 编辑距离(edit distance)</li>
<li>MD: 错配位置&#x2F;碱基(mismatching positions&#x2F;bases)</li>
<li>AS: 联配得分(Alignment score)</li>
<li>BC: 条码序列（barcode sequence)</li>
<li>XS: 次优联配得分(suboptimal alignment score)</li>
</ul>
<h2 id="能用于处理SAM格式的工具们"><a href="#能用于处理SAM格式的工具们" class="headerlink" title="能用于处理SAM格式的工具们"></a>能用于处理SAM格式的工具们</h2><p>后续演示所用数据通过如下方法获取</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># efetch下载参考基因组</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/biostar/refs/ebola</span><br><span class="line"><span class="built_in">cd</span> ~/biostar</span><br><span class="line">efetch -db=nuccore -format=fasta -<span class="built_in">id</span>=AF086833 &gt; ~/refs/ebola/1976.fa</span><br><span class="line">REF=~/biostar/refs/ebola/1976.fa</span><br><span class="line"><span class="comment"># 构建索引</span></span><br><span class="line">bwa index <span class="variable">$REF</span></span><br><span class="line">bowtie2-build <span class="variable">$REF</span> <span class="variable">$REF</span></span><br><span class="line"><span class="comment"># 获取10000行的fastq PE数据</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/biostar/fastq</span><br><span class="line"><span class="built_in">cd</span> ~/biostar/fastq</span><br><span class="line">fastq-dump -X 10000 --split-files SRR1972739</span><br><span class="line">R1=~/biostar/fastq/SRR1972739_1.fastq</span><br><span class="line">R2=~/biostar/fastq/SRR1972739_2.fastq</span><br></pre></td></tr></table></figure>

<p>处理SAM的命令行工具有<code>samtools</code>,<code>bamtools</code>,<code>picard</code>,<code>sambamba</code>,<code>samblaster</code>等，其中<code>samtools</code>和<code>bamtools</code>和<code>picard</code>比较全能，功能中存在重叠，更多是互补，而<code>sambamba</code>和<code>samblaster</code>则是运行速度更快，功能不太全。</p>
<h3 id="使用SAMtools创建SAM-BAM和CRAM"><a href="#使用SAMtools创建SAM-BAM和CRAM" class="headerlink" title="使用SAMtools创建SAM,BAM和CRAM"></a>使用SAMtools创建SAM,BAM和CRAM</h3><p>SAM格式是目前用来存放大量核酸比对结果信息的通用格式，也是人类能够“直接”阅读的格式类型，而BAM和CRAM是为了方便传输，降低存储压力将SAM进行压缩得到的格式形式。 为了高效处理SAM文件，李恒写了配套的SAMtools, 文章在2009年发表在bioinformatics上，由于samtools的版本经常更新，如果有些工具用不了，你或许要更新版本了。</p>
<p>如果不加任何其他参数，比对软件就能得到“标准”的SAM格式的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bwa mem <span class="variable">$REF</span> <span class="variable">$R1</span> <span class="variable">$R2</span> &gt; bwa.sam</span><br><span class="line">bowtie2 -x <span class="variable">$REF</span> -1 <span class="variable">$R1</span> -2 <span class="variable">$R2</span> &gt; bowtie.sam</span><br></pre></td></tr></table></figure>

<p>原始SAM格式体积又大，没有排序，不利于后续的分析操作，所以需要经过几步的格式转换成为BAM。1.3版本之后的samtools可以一步进行格式转换和排序.</p>
<p><strong>注</strong>，BAM格式必须要建立索引才能快速读取指定位置的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.3版本前</span></span><br><span class="line">samtools view -bS bwa.sam &gt; bwa.bam</span><br><span class="line">samtools <span class="built_in">sort</span> bwa.bam &gt; bwa_sorted.bam</span><br><span class="line">samtools index bwa_sorted.bam</span><br><span class="line"><span class="comment"># 1.3版本后</span></span><br><span class="line">samtools <span class="built_in">sort</span> bwa.sam &gt; bwa_sorted.bam</span><br><span class="line">samtools index bwa_sorted.bam</span><br></pre></td></tr></table></figure>

<p>CRAM是比BAM压缩更加高压的格式，原因是它是基于一个参考序列，这样子就能去掉很多冗余的内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samtools <span class="built_in">sort</span> --reference <span class="variable">$REF</span> -O cram bwa.sam &gt; bwa.cram</span><br><span class="line">samtools index bwa.cram</span><br></pre></td></tr></table></figure>

<p>这一小节学习了两个samtools子命令:<code>sort</code>和<code>index</code>，前者能一边排序一边进行格式转换，后者则是对BAM进行索引。</p>
<h3 id="使用SAMtool查看-过滤-转换SAM-BAM-CRAM文件"><a href="#使用SAMtool查看-过滤-转换SAM-BAM-CRAM文件" class="headerlink" title="使用SAMtool查看&#x2F;过滤&#x2F;转换SAM&#x2F;BAM&#x2F;CRAM文件"></a>使用SAMtool查看&#x2F;过滤&#x2F;转换SAM&#x2F;BAM&#x2F;CRAM文件</h3><p>上一节得到的SAM&#x2F;BAM&#x2F;CRAM文件都可以用samtools的<code>view</code>进行更加复杂的操作，只不过要注意读取CRAM格式需要提供参考序列，不然打不开。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samtools view bwa_sorted.bam</span><br><span class="line">samtools view -T <span class="variable">$REF</span> bwa.cram</span><br></pre></td></tr></table></figure>

<p>samtools的<code>view</code>在增加额外参数后能实现更多的操作，比如说SAM和BAM&#x2F;CRAM之间的格式转换(-b, -c, -T)，过滤或提取出目标联配(-t,-L ,-r,-R,-q,-l,-m,-f,-F,-G), 举几个例子说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留mapping quality 大于 10的结果</span></span><br><span class="line">samtools view -q 10 bwa_sorted.bam -b -o bwa_sorted_mq10.bam</span><br><span class="line"><span class="comment"># 统计结果中恰当配对的结果(0x3 3 PARIED,PROPER_PAIR)</span></span><br><span class="line">samtools view -c -f 3 bwa_sorted.bam</span><br><span class="line"><span class="comment"># 或反向选择</span></span><br><span class="line">samtools view -c -F 3 bwa_sorted.bam</span><br></pre></td></tr></table></figure>

<h3 id="使用PrettySam更好的可视化SAM文件"><a href="#使用PrettySam更好的可视化SAM文件" class="headerlink" title="使用PrettySam更好的可视化SAM文件"></a>使用PrettySam更好的可视化SAM文件</h3><p>尽管我上面说SAM是适合人类阅读的数据，但是直接读SAM还是挺费脑子的。GitHub上有一个PrettySam能够更好的展示SAM&#x2F;BAM文件，虽然感觉没多大实际效果，但是有利于我们方便了解SAM格式，项目地址为<a target="_blank" rel="noopener" href="http://lindenb.github.io/jvarkit/PrettySam.html">http://lindenb.github.io/jvarkit/PrettySam.html</a>.</p>
<p>他的安装比较麻烦，需要JDK版本为1.8且是Oracle, 以及GNU Make &gt;&#x3D;3.81, curl&#x2F;wget, git 和 xslproc.安装如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;https://github.com/lindenb/jvarkit.git&quot;</span></span><br><span class="line"><span class="built_in">cd</span> jvarkit</span><br><span class="line">make prettysam</span><br><span class="line"><span class="built_in">cp</span> dist/prettysam.jar ~/usr/jars/</span><br></pre></td></tr></table></figure>

<p>使用起来非常简单，效果也比较酷炫，比较适合演示用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar usr/jars/prettysam.jar ~/biostar/ebola.sam --colors</span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-cc3914ebeb956c14-4fefa542d581406db0bd6a048d49e97c.jpg" alt="PrettySam"></p>
<h3 id="为SAM-BAM添加Read-Groups"><a href="#为SAM-BAM添加Read-Groups" class="headerlink" title="为SAM&#x2F;BAM添加Read Groups"></a>为SAM&#x2F;BAM添加Read Groups</h3><p>使用GATK分析BAM文件时需要BAM文件的header里有RG部分，<code>@RG</code>至少由三个记录(ID,LB,SM)组成，需要根据实际情况增加。RG可以在前期比对时添加RG部分，也可以在后续处理时增加</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TAG=<span class="string">&#x27;@RG\tID:xzg\tSM:Ebola\tLB:patient_100&#x27;</span></span><br><span class="line"><span class="comment"># Add the tags during alignment</span></span><br><span class="line">bwa mem -R <span class="variable">$TAG</span> <span class="variable">$REF</span> <span class="variable">$R1</span> <span class="variable">$R2</span> | samtools <span class="built_in">sort</span> &gt; bwa.bam</span><br><span class="line">samtools index bwa.bam</span><br><span class="line"><span class="comment"># Add tags with samtools addreplacerg</span></span><br><span class="line">samtools addreplacerg -r <span class="variable">$TAG</span> bwa_sorted.bam -o bwa_sorted_with_rg.bam</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://samtools.github.io/hts-specs/SAMv1.pdf">Sequence Alignment&#x2F;Map Format Specification</a></li>
<li><a target="_blank" rel="noopener" href="http://samtools.github.io/hts-specs/SAMtags.pdf">SAM tags</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/27/SAMtools_%20SAM%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86%E5%88%A9%E5%99%A8-samtools-usage-documents/" data-id="cllgasdq9004idkov575rdo57" data-title="SAMtools:SAM格式的处理利器" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/samtools/" rel="tag">samtools</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/20/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/19/">19</a><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><a class="page-number" href="/page/23/">23</a><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/22/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/R/">R</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/">基因组学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/">数据科学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/">文献阅读</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%87%E7%AB%A0%E9%87%8D%E7%8E%B0/">文章重现</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1-%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/">生信软件工具箱 | 基因组学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E5%AD%A6/">转录组学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ATAC-seq-%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">ATAC-seq | 单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ATAC-seq-%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90/" rel="tag">ATAC-seq | 差异分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ATAC-seq-%E8%A1%A8%E8%A7%82%E7%BB%84-ChIP-seq/" rel="tag">ATAC-seq | 表观组 | ChIP-seq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ATAC-seq-%E8%A1%A8%E8%A7%82%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">ATAC-seq | 表观组 | 单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BigWig/" rel="tag">BigWig</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BioNano/" rel="tag">BioNano</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/" rel="tag">C&#x2F;C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C-%E7%AE%97%E6%B3%95/" rel="tag">C&#x2F;C++ | 算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ChIP-seq/" rel="tag">ChIP-seq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub/" rel="tag">GitHub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hi-C/" rel="tag">Hi-C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JCVI/" rel="tag">JCVI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MacOS/" rel="tag">MacOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NGS/" rel="tag">NGS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NGS-%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" rel="tag">NGS | 遗传定位</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBMC/" rel="tag">PBMC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Perl-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" rel="tag">Perl | 软件安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT-MSVC/" rel="tag">QT | MSVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Seurat/" rel="tag">Seurat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Seurat-%E5%8D%95%E7%BB%86%E8%83%9E-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" rel="tag">Seurat | 单细胞 | 数据挖掘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Seurat-%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">Seurat | 转录组 | 单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%BC%80%E5%8F%91/" rel="tag">Web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zotero-%E6%96%87%E7%8C%AE-%E5%9D%9A%E6%9E%9C%E4%BA%91/" rel="tag">Zotero | 文献 | 坚果云</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/biocondutor/" rel="tag">biocondutor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/conda/" rel="tag">conda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/samtools/" rel="tag">samtools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typora/" rel="tag">typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" rel="tag">个人博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="tag">可视化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-CIRCOS/" rel="tag">可视化 | CIRCOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-JCVI/" rel="tag">可视化 | JCVI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">可视化 | 单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-%E6%AF%94%E8%BE%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/" rel="tag">可视化 | 比较基因组学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F/" rel="tag">基因家族</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E5%9B%A0%E7%BB%84/" rel="tag">基因组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7-SSH/" rel="tag">小技巧 | SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" rel="tag">序列比对</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" rel="tag">数据挖掘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-C/" rel="tag">数据结构 | C&#x2F;C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/" rel="tag">正则表达式 | 字符串处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AF%94%E8%BE%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/" rel="tag">比较基因组学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B0%B4%E7%A8%BB-%E8%BD%AC%E5%BD%95%E7%BB%84/" rel="tag">水稻 | 转录组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B0%B4%E7%A8%BB-%E8%BD%AC%E5%BD%95%E7%BB%84-%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" rel="tag">水稻 | 转录组 | 遗传定位</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A/" rel="tag">注释</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-MAKER/" rel="tag">注释 | MAKER</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" rel="tag">注释 | 序列比对</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7/" rel="tag">注释 | 流程工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-MAKER/" rel="tag">注释 | 流程工具 | MAKER</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" rel="tag">注释 | 重复序列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7/" rel="tag">流程工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F/" rel="tag">流程工具 | 基因家族</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">流程工具 | 服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" rel="tag">源码解读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-hash/" rel="tag">源码解读 | hash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" rel="tag">环境变量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-WSL/" rel="tag">环境配置 | WSL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E5%8F%91%E8%82%B2/" rel="tag">系统发育</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E8%A3%85/" rel="tag">组装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E8%A3%85-Hi-C/" rel="tag">组装 | Hi-C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E8%A3%85-%E8%BD%AC%E5%BD%95%E7%BB%84-%E6%B3%A8%E9%87%8A/" rel="tag">组装 | 转录组 | 注释</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">自然语言 | 深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A1%A8%E8%A7%82%E7%BB%84/" rel="tag">表观组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag">读书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84/" rel="tag">转录组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">转录组 | 单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90-TCGA/" rel="tag">转录组 | 差异分析 | TCGA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" rel="tag">转录组 | 序列比对</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" rel="tag">软件安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" rel="tag">遗传定位</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" rel="tag">重复序列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/ATAC-seq-%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 20px;">ATAC-seq | 单细胞</a> <a href="/tags/ATAC-seq-%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90/" style="font-size: 10px;">ATAC-seq | 差异分析</a> <a href="/tags/ATAC-seq-%E8%A1%A8%E8%A7%82%E7%BB%84-ChIP-seq/" style="font-size: 10px;">ATAC-seq | 表观组 | ChIP-seq</a> <a href="/tags/ATAC-seq-%E8%A1%A8%E8%A7%82%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 10px;">ATAC-seq | 表观组 | 单细胞</a> <a href="/tags/BigWig/" style="font-size: 10px;">BigWig</a> <a href="/tags/BioNano/" style="font-size: 10px;">BioNano</a> <a href="/tags/C-C/" style="font-size: 19px;">C/C++</a> <a href="/tags/C-C-%E7%AE%97%E6%B3%95/" style="font-size: 10px;">C/C++ | 算法</a> <a href="/tags/ChIP-seq/" style="font-size: 10px;">ChIP-seq</a> <a href="/tags/GitHub/" style="font-size: 11px;">GitHub</a> <a href="/tags/Hi-C/" style="font-size: 10px;">Hi-C</a> <a href="/tags/JCVI/" style="font-size: 10px;">JCVI</a> <a href="/tags/MacOS/" style="font-size: 16px;">MacOS</a> <a href="/tags/NGS/" style="font-size: 11px;">NGS</a> <a href="/tags/NGS-%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">NGS | 遗传定位</a> <a href="/tags/PBMC/" style="font-size: 10px;">PBMC</a> <a href="/tags/Perl-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" style="font-size: 10px;">Perl | 软件安装</a> <a href="/tags/QT-MSVC/" style="font-size: 10px;">QT | MSVC</a> <a href="/tags/Seurat/" style="font-size: 10px;">Seurat</a> <a href="/tags/Seurat-%E5%8D%95%E7%BB%86%E8%83%9E-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" style="font-size: 10px;">Seurat | 单细胞 | 数据挖掘</a> <a href="/tags/Seurat-%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 10px;">Seurat | 转录组 | 单细胞</a> <a href="/tags/Web%E5%BC%80%E5%8F%91/" style="font-size: 11px;">Web开发</a> <a href="/tags/Zotero-%E6%96%87%E7%8C%AE-%E5%9D%9A%E6%9E%9C%E4%BA%91/" style="font-size: 11px;">Zotero | 文献 | 坚果云</a> <a href="/tags/biocondutor/" style="font-size: 10px;">biocondutor</a> <a href="/tags/conda/" style="font-size: 11px;">conda</a> <a href="/tags/samtools/" style="font-size: 10px;">samtools</a> <a href="/tags/typora/" style="font-size: 10px;">typora</a> <a href="/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">个人博客</a> <a href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 13px;">单细胞</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/" style="font-size: 12px;">可视化</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-CIRCOS/" style="font-size: 14px;">可视化 | CIRCOS</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-JCVI/" style="font-size: 12px;">可视化 | JCVI</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 10px;">可视化 | 单细胞</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-%E6%AF%94%E8%BE%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/" style="font-size: 10px;">可视化 | 比较基因组学</a> <a href="/tags/%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F/" style="font-size: 11px;">基因家族</a> <a href="/tags/%E5%9F%BA%E5%9B%A0%E7%BB%84/" style="font-size: 11px;">基因组</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 17px;">小技巧</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7-SSH/" style="font-size: 10px;">小技巧 | SSH</a> <a href="/tags/%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" style="font-size: 10px;">序列比对</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" style="font-size: 11px;">数据挖掘</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12px;">数据结构</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-C/" style="font-size: 16px;">数据结构 | C/C++</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 12px;">服务器</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/" style="font-size: 10px;">正则表达式 | 字符串处理</a> <a href="/tags/%E6%AF%94%E8%BE%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/" style="font-size: 10px;">比较基因组学</a> <a href="/tags/%E6%B0%B4%E7%A8%BB-%E8%BD%AC%E5%BD%95%E7%BB%84/" style="font-size: 10px;">水稻 | 转录组</a> <a href="/tags/%E6%B0%B4%E7%A8%BB-%E8%BD%AC%E5%BD%95%E7%BB%84-%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">水稻 | 转录组 | 遗传定位</a> <a href="/tags/%E6%B3%A8%E9%87%8A/" style="font-size: 12px;">注释</a> <a href="/tags/%E6%B3%A8%E9%87%8A-MAKER/" style="font-size: 13px;">注释 | MAKER</a> <a href="/tags/%E6%B3%A8%E9%87%8A-%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" style="font-size: 10px;">注释 | 序列比对</a> <a href="/tags/%E6%B3%A8%E9%87%8A-%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">注释 | 流程工具</a> <a href="/tags/%E6%B3%A8%E9%87%8A-%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-MAKER/" style="font-size: 10px;">注释 | 流程工具 | MAKER</a> <a href="/tags/%E6%B3%A8%E9%87%8A-%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" style="font-size: 12px;">注释 | 重复序列</a> <a href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7/" style="font-size: 17px;">流程工具</a> <a href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F/" style="font-size: 10px;">流程工具 | 基因家族</a> <a href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">流程工具 | 服务器</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">深度学习</a> <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" style="font-size: 10px;">源码解读</a> <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-hash/" style="font-size: 10px;">源码解读 | hash</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 10px;">爬虫</a> <a href="/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" style="font-size: 10px;">环境变量</a> <a href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-WSL/" style="font-size: 10px;">环境配置 | WSL</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 11px;">算法</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E5%8F%91%E8%82%B2/" style="font-size: 12px;">系统发育</a> <a href="/tags/%E7%BB%84%E8%A3%85/" style="font-size: 18px;">组装</a> <a href="/tags/%E7%BB%84%E8%A3%85-Hi-C/" style="font-size: 16px;">组装 | Hi-C</a> <a href="/tags/%E7%BB%84%E8%A3%85-%E8%BD%AC%E5%BD%95%E7%BB%84-%E6%B3%A8%E9%87%8A/" style="font-size: 10px;">组装 | 转录组 | 注释</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 11px;">编程语言</a> <a href="/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 11px;">自然语言 | 深度学习</a> <a href="/tags/%E8%A1%A8%E8%A7%82%E7%BB%84/" style="font-size: 10px;">表观组</a> <a href="/tags/%E8%AF%BB%E4%B9%A6/" style="font-size: 11px;">读书</a> <a href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84/" style="font-size: 11px;">转录组</a> <a href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 11px;">转录组 | 单细胞</a> <a href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90-TCGA/" style="font-size: 10px;">转录组 | 差异分析 | TCGA</a> <a href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" style="font-size: 10px;">转录组 | 序列比对</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" style="font-size: 15px;">软件安装</a> <a href="/tags/%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">遗传定位</a> <a href="/tags/%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" style="font-size: 12px;">重复序列</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/18/%E4%BB%8Ehalo%E8%BF%81%E7%A7%BB%E5%88%B0hexo/">从halo迁移到hexo</a>
          </li>
        
          <li>
            <a href="/2023/06/24/Oatk%EF%BC%9A%E5%88%A9%E7%94%A8HiFi%20Read%E8%BF%9B%E8%A1%8C%E7%BB%86%E8%83%9E%E5%99%A8%E7%BB%84%E8%A3%85-oatk-assembly-of-organelles-using-hifi-read/">Oatk：利用HiFi Read进行细胞器组装</a>
          </li>
        
          <li>
            <a href="/2023/06/22/%E5%9C%A8Windows%E4%B8%AD%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EWSL%E7%9A%84Python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E7%8E%AF%E5%A2%83-building-a-wsl-based-python-data-science-environment-in-windows/">在Windows中搭建一个基于WSL的Python数据科学环境</a>
          </li>
        
          <li>
            <a href="/2023/06/16/%E7%94%A8Colab%E7%BC%93%E8%A7%A3%E6%88%91%E7%9A%84GPU%E7%84%A6%E8%99%91-%E7%94%A8colab%E7%BC%93%E8%A7%A3%E6%88%91%E7%9A%84gpu%E7%84%A6%E8%99%91/">用Colab缓解我的GPU焦虑</a>
          </li>
        
          <li>
            <a href="/2023/05/31/%E6%8E%8C%E6%8F%A1%E4%BA%86%E4%B8%80%E4%B8%AA%E5%85%B3%E4%BA%8EBcrypt%E5%8A%A0%E5%AF%86%E7%9A%84%E7%9F%A5%E8%AF%86-acquired-a-knowledge-of-bcrypt-encryption/">掌握了一个关于Bcrypt加密的知识</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 xuzhougeng<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>