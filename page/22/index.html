<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>洲更的第二大脑</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="洲更的第二大脑">
<meta property="og:url" content="http://xuzhougeng.top/page/22/index.html">
<meta property="og:site_name" content="洲更的第二大脑">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="xuzhougeng">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="洲更的第二大脑" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">洲更的第二大脑</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://xuzhougeng.top"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-使用Pilon对基因组进行polish-Polish-genome-assembly-by-pilon" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/27/%E4%BD%BF%E7%94%A8Pilon%E5%AF%B9%E5%9F%BA%E5%9B%A0%E7%BB%84%E8%BF%9B%E8%A1%8Cpolish-Polish-genome-assembly-by-pilon/" class="article-date">
  <time class="dt-published" datetime="2019-08-27T20:21:45.500Z" itemprop="datePublished">2019-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/27/%E4%BD%BF%E7%94%A8Pilon%E5%AF%B9%E5%9F%BA%E5%9B%A0%E7%BB%84%E8%BF%9B%E8%A1%8Cpolish-Polish-genome-assembly-by-pilon/">使用Pilon对基因组进行polish</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="使用Pilon对基因组进行polish"><a href="#使用Pilon对基因组进行polish" class="headerlink" title="使用Pilon对基因组进行polish"></a>使用Pilon对基因组进行polish</h1><h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>官方提供了编译好的jar包，方便使用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/broadinstitute/pilon/releases/download/v1.22/pilon-1.22.jar</span><br><span class="line">java -Xmx16G -jar pilon-1.22.jar</span><br></pre></td></tr></table></figure>

<p>如果要顺利运行程序，要求JAVA &gt; 1.7, 以及根据基因组大小而定的内存，一般而言是1M大小的基因对应1GB的内存。</p>
<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>Pilon有如下作用</p>
<ol>
<li>对初步组装进行polish</li>
<li>寻找同一物种不同株系间的变异，包括结构变异检测</li>
</ol>
<p>他以FASTA和BAM文件作为输入，根据比对结果对输入的参考基因组进行提高，包括</p>
<ul>
<li>单碱基差异</li>
<li>小的插入缺失(indels)</li>
<li>较大的插入缺失或者block替换时间</li>
<li>填充参考序列中的N</li>
<li>找到局部的错误组装</li>
</ul>
<p>最后它输出polish后的FASTA文件, 以及包含变异信息的VCF文件(可选)</p>
<h2 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h2><p>推荐使用PCR-free建库测序得到的Illumina paired-end数据，这样子避免了PCR-duplication,有效数据更多，也不需要在分析过程中标记重复。</p>
<p>下面步骤，假设你的组装文件为<code>draft.fa</code>, 质量控制后的illumina双端测序数据分别为<code>read_1.fq.gz</code>和<code>read_2.fq.gz</code></p>
<p>第一步：比对</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bwa index -p index/draft draft.fa</span><br><span class="line">bwa mem -t 20 index/draft read_1.fq.gz read_2.fq.gz | samtools <span class="built_in">sort</span> -@ 10 -O bam -o align.bam</span><br><span class="line">samtools index -@ 10 align.bam</span><br></pre></td></tr></table></figure>

<p>第二步：标记重复（非PCR-free建库)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sambamba markdup -t 10 align.bam align_markdup.bam</span><br></pre></td></tr></table></figure>

<p>第三步：过滤高质量比对的read</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samtools view -@ 10 -q 30 align_markdup.bam &gt; align_filter.bam</span><br><span class="line">samtools index -@ 10 align_filter.bam</span><br></pre></td></tr></table></figure>

<p>第三步：使用Pilon进行polish</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MEMORY= <span class="comment">#根据基因组大小而定</span></span><br><span class="line">java -Xmx<span class="variable">$&#123;MEMORY&#125;</span>G -jar pilon-1.22.jar --genome draft.fa --frags align_filer.bam \</span><br><span class="line">    --fix snps,indels \</span><br><span class="line">    --output pilon_polished --vcf &amp;&gt; pilon.log</span><br></pre></td></tr></table></figure>

<p>关于Pilon的一些参数说明：</p>
<ul>
<li><code>--frags</code>表示输入的是1kb以内的paired-end文库，<code>--jumps</code>表示 大于1k以上的mate pair文库,  <code>--bam</code>则是让软件自己猜测</li>
<li><code>-vcf</code>: 输出一个vcf文件，包含每个碱基的信息</li>
<li><code>--fix</code>:  Pilon将会处理的内容，基本上选<code>snps</code>和<code>indels</code>就够了</li>
<li><code>--variant</code>: 启发式的变异检测，等价于<code>--vcf --fix all,breaks</code>, 如果是polish不要使用该选项</li>
<li><code>minmq</code>: 用于Pilon堆叠的read最低比对质量，默认是0。</li>
</ul>
<h2 id="阅读日志输出"><a href="#阅读日志输出" class="headerlink" title="阅读日志输出"></a>阅读日志输出</h2><blockquote>
<p>这个日志文件是标准输出而不是标准错误输出，不过保险起见用<code>&amp;&gt;</code></p>
</blockquote>
<p>最开始，Pilon会输出他的版本信息（如下示例），以及将会对基因组做的调整,</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pilon version 1.14 Sat Oct 31 14:30:00 2015 -0400</span><br><span class="line">Genome: genome.fasta</span><br><span class="line">Fixing snps, indels</span><br></pre></td></tr></table></figure>

<p>其中Fixing后面的含义为：</p>
<ul>
<li>“snps”:  单碱基差异</li>
<li>“indels”:小的indel的差异</li>
<li>“amb”:  替换原有的N</li>
<li>“gaps”: 填充基因组的gap</li>
<li>“local”： 检测和修改错误组装</li>
<li>“all”:  上述所有</li>
<li>“none”: 不是上述的任何一种</li>
</ul>
<p>接着Pilon会分染色体对BAM文件进行处理，根据BAM文件进行堆叠(pileup), 这个时候它会输出有效reads的深度，这里的有效reads包括未成对的read和正确成对的read。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Processing ctg1:1-5414473</span><br><span class="line">frags align_mkdup.bam: coverage 19</span><br><span class="line">Total Reads: 808985, Coverage: 19, minDepth: 5</span><br></pre></td></tr></table></figure>

<p>从Pilon v1.4开始，Pilon还会输出基因组得到确认的碱基比例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Confirmed 5403864 of 5414473 bases (99.80%)</span><br></pre></td></tr></table></figure>

<p>后续是Pilon将会对原参考基因组做的一些调整的总体情况，如下表示纠正2个snp, 2个小的插入，4个缺失。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Corrected 2 snps; 0 ambiguous bases; corrected 2 small insertions totaling 12 bases, 4 small deletions totaling 6 bases</span><br></pre></td></tr></table></figure>

<p>最后声明当前部分处理结束</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Finished processing ctg1:1-5414473</span><br></pre></td></tr></table></figure>

<p>如果，在<code>--fix</code>中选了<code>gaps</code>, 那么输出的内容还有如下内容。其中<code>82048 -0 +276</code>解释为在坐标82428处移除0个碱基，插入276个碱基。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Attempting to fill gaps</span></span><br><span class="line">fix gap: scaffold00001:82428-93547 82428 -0 +276 ClosedGap</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考资料</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/broadinstitute/pilon/wiki/Standard-Output">https://github.com/broadinstitute/pilon/wiki/Standard-Output</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/broadinstitute/pilon/wiki/Methods-of-Operation">https://github.com/broadinstitute/pilon/wiki/Methods-of-Operation</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/27/%E4%BD%BF%E7%94%A8Pilon%E5%AF%B9%E5%9F%BA%E5%9B%A0%E7%BB%84%E8%BF%9B%E8%A1%8Cpolish-Polish-genome-assembly-by-pilon/" data-id="clm1z22aj0000ehn554401967" data-title="使用Pilon对基因组进行polish" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-如何使用MUMmer比对大片段序列-Using-MUMmer-to-align-genome" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8MUMmer%E6%AF%94%E5%AF%B9%E5%A4%A7%E7%89%87%E6%AE%B5%E5%BA%8F%E5%88%97-Using-MUMmer-to-align-genome/" class="article-date">
  <time class="dt-published" datetime="2019-08-27T20:18:54.545Z" itemprop="datePublished">2019-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8MUMmer%E6%AF%94%E5%AF%B9%E5%A4%A7%E7%89%87%E6%AE%B5%E5%BA%8F%E5%88%97-Using-MUMmer-to-align-genome/">如何使用MUMmer比对大片段序列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="如何使用MUMmer比对大片段序列"><a href="#如何使用MUMmer比对大片段序列" class="headerlink" title="如何使用MUMmer比对大片段序列"></a>如何使用MUMmer比对大片段序列</h1><p>测序技术刚开始发展的时候，大家得到的序列都是单个基因的长度，所以一般都是逐个基因的比较，用的都是BLAST或FASTA通过逐个基因联配的方式搜索数据库。但是1999年后，越来越多的物种全基因组出现，比如说在1999年出现了_Helicobacter pylori_的第二类菌株的基因组序列，就需要研究同一物种不同品系进化过程的基因组变化，比如说基因倒置现象。传统的BLAST&#x2F;FASTA就用不了，就需要用到新的工具，这就是MUMmer出现的历史背景。</p>
<p>那么MUMmer能用来研究什么呢？比如说细菌的不同菌株基因组中倒置现象，人和老鼠的基因组在进化上的重排现象。还有比较同一物种的不同组装结果等。MUMmer的算法基础(suffix tree)使得它的速度比BLASTZ(k-mers)快得多，但是灵敏度低，也就是检测不到比较弱的匹配，但是作者说这都是可以通过修改参数进行改善</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>MUMmer是开源软件，因此可以通过下载源码编译的方式进行安装，同时biconda上已经有编译好的二进制版本方便用conda进行安装。目前，我个人比较推荐使用源码编译的方式进行安装。目前MUMmer已经更新到第四版，但是还在测试中，所以文章也没有发，求稳还是用3.23.</p>
<blockquote>
<p>多说一句，如果在bioconda频道上搜索mummer, 会发现一个pymummer，不要以为这是mummer的源代码用python改写，它仅仅做到了通过调用系统安装的MUMmer的工具的方式运行而已，并且功能目前实在是太弱了。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MUMmer3.23</span></span><br><span class="line">wget https://gigenet.dl.sourceforge.net/project/mummer/mummer/3.23/MUMmer3.23.tar.gz</span><br><span class="line">tar -xf MUMmer3.23.tar.gz</span><br><span class="line"><span class="built_in">cd</span>  MUMmer3.23</span><br><span class="line">make install</span><br><span class="line"><span class="comment"># MUMmer4.00-beta2</span></span><br><span class="line">wget https://github.com/mummer4/mummer/releases/download/v4.0.0beta2/mummer-4.0.0beta2.tar.gz</span><br><span class="line">tar xf mummer-4.0.0beta2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> mummer-4.0.0beta2</span><br><span class="line">./configure --prefix=<span class="variable">$HOME</span>/biosoft/mummer-4.0.0beta2 &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>为了方便使用记得将软件路径加入PATH。</p>
<h2 id="MUMmer使用方法"><a href="#MUMmer使用方法" class="headerlink" title="MUMmer使用方法"></a>MUMmer使用方法</h2><p>MUMmer的核心基于 <em>Maximal exact matching</em> 算法开发的<code>mummer</code>。其他工具(<code>nucmer</code>,<code>promer</code>)都是基于<code>mummer</code>的开发的流程。这些流程的分析策略分为三步：</p>
<ol>
<li>用<code>mummer</code>在两个输入中找<strong>给定长度</strong>的极大唯一匹配( <em>Maximal exact matching</em> )</li>
<li>然后将这些匹配区域<strong>聚类</strong>成较大不完全联配区域, 作为锚定点(anchor)</li>
<li>最后它从每个匹配外部扩展联配, 形成有gap的联配。</li>
</ol>
<h3 id="Maximal-exact-matching"><a href="#Maximal-exact-matching" class="headerlink" title="Maximal exact matching"></a>Maximal exact matching</h3><p>MUMmer核心是基于后缀树(suffix tree)数据结构的最大匹配路径。 根据这个算法开发出来的<code>repeat-match</code>和<code>exact-tandems</code>可以从单个序列中检测重复，<code>mummer</code>则是用于联配两条或两条以上的序列。由于MUMmer的其他工具基本都是基于mummer开发的，于是理解mummer就变得非常重要。</p>
<blockquote>
<p>概念1：suffix tree: 表示一个字符串的所有子字符串的数据结构，比如说abc的所有子字符串就是a,ab,ac,bc,abc.<br>概念2：Maximal Unique Match: 指的是匹配仅在两个比较序列中各出现一次</p>
</blockquote>
<p><strong>mummer</strong>: 基于后缀树(suffix tree)数据结构，能够在两条序列中有效定位极大唯一匹配(<em>maximal unique matches</em>)，因此它比较适用于产生一组准确匹配(exact matches)以点图形式展示，或者用来锚定从而产生逐对联配(pair-wise alignments)</p>
<p>大部分情况下都不会直接用到<code>mummer</code>，所以只要知道MUMmer历经几次升级，使得<code>mummer</code>可以能够只找在reference和query都唯一的匹配(第一版功能)，也可以找需要在reference唯一的匹配(第二版新增)，甚至不在乎是否唯一的匹配(第三版新增),参数分别为<code>-mum</code>,<code>-mumreference</code>,<code>maxmatch</code>。</p>
<p><strong>repeat-match</strong>和<strong>exact-tandems</strong>比较少用，毕竟参数也不多，似乎有其他更好的工具能用来寻找序列中的重复区。</p>
<h3 id="Clustering-聚类"><a href="#Clustering-聚类" class="headerlink" title="Clustering:聚类"></a>Clustering:聚类</h3><p><code>MUMmer</code>的聚类算法能够比较智能地把几个独立地匹配按照顺序聚成一块。分为两种模式<code>gaps</code>和<code>mgaps</code>。这两者差别在于是否允许重排,分别用于<code>run-mummer1</code>,<code>run-mummer3</code>.</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-0253b2e225d9b1ee-618c91073ab347c0b055eab1cc466dea.gif" alt="gaps"><br><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-af765e2d4c9d861d-03f5a9dd03e941ea8758b0be5ac2968f.gif" alt="mgaps"></p>
<blockquote>
<p>基于<code>gap</code>和<code>mgaps</code>的输出，第四版还提供了<code>annotate</code>和<code>combineMUMs</code>两个工具增加联配信息。</p>
</blockquote>
<h3 id="联配构建工具"><a href="#联配构建工具" class="headerlink" title="联配构建工具"></a>联配构建工具</h3><p>基于上述两个工具，作者编写了4个工作流程，方便实际使用。</p>
<ul>
<li><code>nucmer</code>: 由Perl写的流程，用于联配很相近(closely related)核酸序列。它比较适合<strong>定位和展示高度保守的DNA序列</strong>。注意，为了提高nucmer的精确性，最好把输入序列先做<strong>遮盖(mask)<strong>避免不感兴趣的序列的联配，或者</strong>修改单一性限制</strong>降低重复导致的联配数。</li>
<li><code>promer</code>：也是Perl写的流程，它以翻译后的<strong>氨基酸序列</strong>进行联配，工作原理同<code>nucmer</code>.</li>
<li><code>run-mummer1</code>,<code>run-mummer3</code>： 两者是基于cshell写的流程，用于两个序列的常规联配，和promer,nucmer类似，只不过能够自动识别序列类型。它们擅长联配<strong>相似度高</strong>的DNA序列，找到它们的不同，也就是适合找SNP或者纠错。前者用于1v1无重排，后者1v多有重排</li>
</ul>
<p>重点介绍一下<code>nucmer</code>的使用。reference和query文件都需要时fasta格式，每个都可以有多条序列。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nucmer [options] &lt;reference&gt; &lt;query file&gt;</span><br></pre></td></tr></table></figure>

<p>参数我将其分为五个部分，匹配算法，聚类，外延、其他和新增</p>
<p>匹配:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--mum, --mumreference(默认), --maxmatch</span><br><span class="line">--minmatch/-l: 单个匹配最小长度</span><br><span class="line">--forwoard/-f, --reverse/-r: 只匹配正链或只匹配负链。</span><br></pre></td></tr></table></figure>

<p>聚类：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--mincluster/-c: 用于聚类的匹配最低长度，默认65</span><br><span class="line">--maxgap/-g: 两个相邻匹配间的最大gap长度，默认90</span><br><span class="line">--diagdiff/-D: 一个聚类中两个邻接匹配，最大对角差分，默认5</span><br><span class="line">--diagfactor/-d: 也是和对角差分相关参数，只不过和gap长度有关，默认0.12</span><br></pre></td></tr></table></figure>

<p>外延:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--breaklen/-b: 在对联配两端拓展式，在终止后继续延伸的程度，默认200</span><br><span class="line">--[no]extend：是否外延，默认是</span><br><span class="line">--[no]optimize：是否优化，默认是。即在联配分数较低时不会立刻终止，而是回顾整条联配，看能否苟延残喘一会。</span><br></pre></td></tr></table></figure>

<p>其他:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--depend: 显示依赖信息后退出</span><br><span class="line">--coords: 调用show-coords输出坐标信息</span><br><span class="line">--prefix/-p: 输出文件的前缀</span><br><span class="line">--[no]delta: 是否输出delta文件，默认是</span><br></pre></td></tr></table></figure>

<p><strong>新增</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在第四版新增的参数</span></span><br><span class="line">--threads/-t: 多核心</span><br><span class="line">---delta=PATH: 指定位置，而不是当前</span><br><span class="line">--sam-short=PATH：保存为SAM短格式，不保存匹配的序列，也就是第十列为*</span><br><span class="line">--sam-long=PATH： 保存为SAM长格式，保存匹配的序列</span><br><span class="line">--save=PREFIX：保存suffix array</span><br><span class="line">--load=PREIFX：加载suffix array</span><br></pre></td></tr></table></figure>

<p>运行后得到一个delta格式的文件，它的作用是记录每个联配的坐标，每个联配中的插入和缺失的距离。下面逐行进行解释</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/home/username/reference.fasta /home/username/query.fasta <span class="comment"># 两个比较文件的位置</span></span><br><span class="line">PROMER <span class="comment"># 程序运行类型： NUCMER或PROMER</span></span><br><span class="line">&gt;tagA1 tagB1 3000000 2000000 <span class="comment"># 一组联配(可以有多个小匹配)，ref的fastaID，qry的fastaID，ref序列长度，qry序列长度</span></span><br><span class="line">1667803 1667078 1641506 1640769 14 7 2 <span class="comment"># 第一小组 ref起始，ref结束，qry起始，qry结束，错误数(不相同碱基+indel碱基数)，相似错误(非正匹配得分) 终止密码子(NUCMER为0)。 如果结束大于起始，表示在负链。</span></span><br><span class="line">-145 <span class="comment"># qry的145有插入</span></span><br><span class="line">-3   <span class="comment"># qry的145+3=148有插入</span></span><br><span class="line">-1   <span class="comment"># qry的145+3+1=149有插入</span></span><br><span class="line">40   <span class="comment"># qry的145+3+1+40=149有缺失</span></span><br><span class="line">0 <span class="comment"># 表示当前匹配结束</span></span><br><span class="line">1667804 1667079 1641507 1640770 10 5 3 <span class="comment"># 第二小组</span></span><br><span class="line">-146</span><br><span class="line">-1</span><br><span class="line">-1</span><br><span class="line">-34</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h4 id="用法举例"><a href="#用法举例" class="headerlink" title="用法举例"></a>用法举例</h4><h5 id="两个完整度高的基因组"><a href="#两个完整度高的基因组" class="headerlink" title="两个完整度高的基因组"></a>两个完整度高的基因组</h5><p>比较常见的用法是把一条连续的序列和另一条连续的序列比。比如说两个细菌的菌株,直接用<code>mummer</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget http://mummer.sourceforge.net/examples/data/H_pylori26695_Eslice.fasta</span><br><span class="line">wget http://mummer.sourceforge.net/examples/data/H_pyloriJ99_Eslice.fasta</span><br><span class="line">mummer -mum -b -c H_pylori26695_Eslice.fasta H_pyloriJ99_Eslice.fasta &gt; 26695_J99.mums</span><br><span class="line"><span class="comment"># -mum: 计算在两个序列中唯一的最大匹配数</span></span><br><span class="line"><span class="comment"># -b: 计算正向和反向匹配数</span></span><br><span class="line"><span class="comment"># -c: 报告反向互补序列相对于原始请求序列的位置</span></span><br></pre></td></tr></table></figure>

<p>或者是<strong>高度相似</strong>序列，不含重排</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">run-mummer1 ref.fasta qry.fasta ref_qry</span><br><span class="line"><span class="comment"># 仅报告负链匹配序列</span></span><br><span class="line">run-mummer1 ref.fasta qry.fasta ref_qry -r</span><br></pre></td></tr></table></figure>

<p>或者是<strong>高度相似</strong>序列，存在重排现象</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run-mummer3 ref.fasta qry.fasta ref_qry</span><br></pre></td></tr></table></figure>

<p>以上的<code>run-mummer*</code>比较关注序列的不同之处，那么对于<strong>相似度没有那么高</strong>的两个序列，就需要用到<code>nucmer</code>。<code>nucmer</code>关注序列的相似之处，所以它允许重排，倒置和重复现象。<code>nucmer</code>允许多对多的比较方式，当然比较常用的是多对一的比较。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nucmer --maxgap=500 --mincluster=100 --prefix=ref_qry ref.fasta qry.fasta</span><br><span class="line"><span class="comment">## --maxgap: 两个match间最大gap为500</span></span><br><span class="line"><span class="comment">##--minclster: 至少要有100个match才能算做一簇</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意一点： 第四版中<code>run-mummer1, run-mummer3</code>已经被废弃了，就是尽管保留了，但是没有对它做任何升级的意思。</p>
</blockquote>
<p>如果是<strong>有点差异</strong>的两个序列，可以用翻译的氨基酸序列进行比较</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promer --prefix=ref_qry ref.fasta qry.fasta</span><br></pre></td></tr></table></figure>

<h5 id="两个基因草图"><a href="#两个基因草图" class="headerlink" title="两个基因草图"></a>两个基因草图</h5><p>上面都是两条序列间的比较，但是研究植物的人更容易遇到的是两个物种的基因组都只有scafold级别，甚至是contig级别。那么就可以使用<code>nucmer</code>或<code>promer</code>构建序列间的可能联配。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先过滤低于1kb的序列</span></span><br><span class="line">bioawk -c fastx <span class="string">&#x27;&#123;if (length($seq) &gt; 1000) print &quot;&gt;&quot;$name &quot;\n&quot;$seq&#125;&#x27;</span> ~/reference/genome/rice_contigs/HP1 &gt; HP103_1kb.fa</span><br><span class="line">bioawk -c fastx <span class="string">&#x27;&#123;if (length($seq) &gt; 1000) print &quot;&gt;&quot;$name &quot;\n&quot;$seq&#125;&#x27;</span> ~/reference/genome/rice_contigs/HP119.fa &gt; HP119_1kb.fa</span><br><span class="line"><span class="comment"># 处理，时间会比较久，因为分别有20109，17877条contig</span></span><br><span class="line">nucmer --prefix HP103_HP119 HP103_1kb.fa HP119_1kb.fa &amp;</span><br></pre></td></tr></table></figure>

<h5 id="一个基因草图对一个完整基因组"><a href="#一个基因草图对一个完整基因组" class="headerlink" title="一个基因草图对一个完整基因组"></a>一个基因草图对一个完整基因组</h5><p>这里可以比较一下水稻日本晴基因组和其他地方品种</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nucmer  --prefix IRGSP1_DHX2 ~/reference/genome/IRGSP1.0/IRGSP-1.0_genome.fasta ~/reference/genome/rice_contigs/DHX2.fa</span><br><span class="line"><span class="comment"># 第四版提供SAM输出和多核支持</span></span><br><span class="line">~/biosoft/mummer-4.0.0beta2/bin/nucmer -t 15 --sam-short=SAM_OUT/DHX2 ~/reference/genome/IRGSP1.0/IRGSP-1.0_genome.fasta ~/reference/genome/rice_contigs/DHX2.fa &amp;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在第四版中新增了一个<code>dnadiff</code>，进一步封装<code>nucmer</code>和其他数据整理工具，基本上没啥参数，而输出很齐全，非常的人性化。在不知如何开始的时候，可以无脑用这个。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 已有delta文件</span></span><br><span class="line">dnadiff -d IRGSP1_DHX2.delta</span><br><span class="line"><span class="comment"># 未有delta文件</span></span><br><span class="line">dnadiff IRGSP1_DHX2 ~/reference/genome/IRGSP1.0/IRGSP-1.0_genome.fasta ~/reference/genome/rice_contigs/DHX2.fa</span><br></pre></td></tr></table></figure>

<h2 id="数据整理"><a href="#数据整理" class="headerlink" title="数据整理"></a>数据整理</h2><p>之前得到的数据还需要用<code>delta-filter</code>,<code>show-coords</code>和<code>show-tilling</code>进行进一步整理才能用于后续的分析。后续操作基于上面的基因草图和完成基因组比较结果。</p>
<p>最初的比对结果保留了最多的信息，需要用<code>delta-filter</code>进行一波过滤，除去不太合适的部分。过滤选项有</p>
<ul>
<li><code>-i</code>: 最小的相似度 [0,100], 默认0</li>
<li><code>-l</code>: 最小的匹配长度 默认0.</li>
<li><code>-u</code>: 最小的联配唯一度 [0,100], 默认0</li>
<li><code>-o</code>: 最大重叠度，针对<code>-r</code>和<code>-q</code>设置。 [0,100], 默认100</li>
<li><code>-g</code>: 1对1全局匹配，不允许重排</li>
<li><code>-1</code>: 1对1联配，允许重排，是<code>-r</code>和<code>-q</code>的交集</li>
<li><code>-m</code>: 多对对联配，允许重排，是<code>-r</code>和<code>-q</code>的合集。</li>
<li><code>-q</code>: 仅保留每个query在reference上的最佳位置,允许多条query在reference上重叠</li>
<li><code>-r</code>: 仅保留每个reference在query上的最佳位置,允许多条reference在query上重叠</li>
</ul>
<p>以上顺序是<code>-i -l -u -q -r -g -m -1</code>.光看参数估计不太明白，来一波图解。referece的一个片段可以联配到query的多个片段上，同样的query的一个片段也可以联配到reference的多个片段上，那么如何取舍呢？</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-22510b4f02161663-a24f4839916849139ea95f8c1870400c.jpg" alt="多对多"></p>
<p>通过<code>-i</code>,<code>-l</code>可以先过滤一些比较短，并且相似度比较低的匹配情况。进一步，计算长度和相似度的乘积(加权最长增加子集)，对于<code>-q</code>而言就是保留左2，对于<code>-r</code>则是保留右3. 这就是传说中的三角关系，这种关系可以用<code>-m</code>保留或者用<code>-q</code>消灭。</p>
<p>比如说我想看contig和reference两者唯一匹配，并且长度在1000，相似度大于90.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delta-filter -i 89 -l 1000 -1 IRGSP1_DHX2.delta &gt; IRGSP1_DHX2_i89_l1000_1.delta.filter</span><br></pre></td></tr></table></figure>

<p>如何才能验证上面参数运行的结果是符合要求的呢？毕竟数据分析第一原则“不要轻易相信分析结果，需要多次验证才能使用”。</p>
<p>可以先用<code>show-coord</code>以人类可读的格式显示匹配的坐标。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show-coords -r IRGSP1_DHX2_i89_l1000_1.delta.filter &gt; IRGSP1_DHX2_i89_l1000_1.coord</span><br><span class="line"><span class="comment"># -r：以refID排序，相对的，还有-q，以queryID排序</span></span><br><span class="line">less IRGSP1_DHX2_i89_l1000_1.coord</span><br></pre></td></tr></table></figure>

<p>不难发现这个位置锚定的非常不错，至少暂时看起来没有重叠之处</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-22d43cfb51512b11-8b277c2214a3461cb1a8f391e5448ee5.jpg" alt="coord信息"></p>
<p>用<code>show-aligns</code>看某一个匹配的序列比对情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show-aligns IRGSP1_DHX2_i89_l1000_1.delta.filter chr01 DHX2_00006753 | less</span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-a34cd3bd38efe73e-ea70a7ac864f4edfb78414df00eba7f3.jpg" alt="alignment"></p>
<p>针对reference有很长的组装序列的情况，还可以用<code>show-tilling</code>将contig回贴到reference上，如果装了gnuplot还能用<code>mummerplot</code>可视化点图.<code>show-tiling</code>会尝试根据contig和reference匹配信息构建出tiling path(不好翻译呀。。)，不怎么用得到。</p>
<p><code>show-snps</code>可以根据delta文件整理出SNP信息，我表示也没有怎么用到。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/27/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8MUMmer%E6%AF%94%E5%AF%B9%E5%A4%A7%E7%89%87%E6%AE%B5%E5%BA%8F%E5%88%97-Using-MUMmer-to-align-genome/" data-id="clm1z22h100e4ehn53v1p5k0h" data-title="如何使用MUMmer比对大片段序列" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-SAMtools_ SAM格式的处理利器-samtools-usage-documents" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/27/SAMtools_%20SAM%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86%E5%88%A9%E5%99%A8-samtools-usage-documents/" class="article-date">
  <time class="dt-published" datetime="2019-08-27T19:50:29.749Z" itemprop="datePublished">2019-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/27/SAMtools_%20SAM%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86%E5%88%A9%E5%99%A8-samtools-usage-documents/">SAMtools:SAM格式的处理利器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="SAM格式介绍"><a href="#SAM格式介绍" class="headerlink" title="SAM格式介绍"></a>SAM格式介绍</h2><p>SAM全称是Sequence Alignment&#x2F;Map, 是目前最常用的存放比对或联配数据的格式。无论是重测序，还是转录组，还是表观组，几乎所有流程都会产生SAM&#x2F;BAM文件作为中间步骤，然后是后续专门的分析过程。</p>
<p>以一个简单的例子介绍.第一幅图表示read和参考基因组比对可能出现的情况。r001&#x2F;2表示paired end数据。r003是嵌合read，r004则是原序列打断后比对结果。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-0bd4d534d1e2a601-3b9976cd770a443f93b11b5e58d8acee.jpg" alt="原始数据"></p>
<p>经过专门的比对软件，如BWA,BOWTIE2等，得到的SAM文件如下所示,需要研究的就是如下这几行。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-1db9c0789e0e4e07-c8be7037bbd4477d9828cd462df64849.jpg" alt="比对后存放形式"></p>
<h3 id="术语和概念"><a href="#术语和概念" class="headerlink" title="术语和概念"></a>术语和概念</h3><p>在学习SAM格式之前，请确认自己是否对如下概念有清楚的认识|</p>
<ul>
<li>read: 测序仪返回的原始序列.一个read可以包括多个segment。read之间的先后顺序表示被测序仪读到的时间前后关系.</li>
<li>segment:  一段连续的序列或子序列</li>
<li>linear alignment: 线性联配表示一个read比对到单个参考序列，可以存在插入，缺失，跳过(skip),剪切(clip), 但是不存在方向改变的情况(比如说一部分和正向链联配，另一个位置则是和负向链联配）。最简单的判断的方式就是，一个linear alignment只用一行记录。</li>
<li>chimeric alignment: 嵌合联配需要多行记录。比如说r003第一个记录是后6个匹配，第二个记录则是反向序列的后5个匹配。第一个被称之为”representative”,其他都是”supplementary”</li>
<li>read alignment: 无论是linear alignment, 还是chimeric alignment, 只要能完整表示一个read，都成为是read alignment</li>
<li>multiple mapping: 由于存在重复区，一个read 可能比对到参考基因组的不同区域。其中一个被认为是primary，其他都是secondary.</li>
<li>两个系统|1-based coordinate system（SAM,VCF,GFF,wiggle)和0-based coordinate system(BAM, BCFv2, BED, PSL).自行用R和Python感受一下两者的不同。</li>
</ul>
<blockquote>
<p>chimeric alignment 可能是结构变异，基因融合，参考序列误组装，RNA-Seq，实验protocol等因素造成。对于chimeric alignment的里面每一个linear alignment而言，由于相互之前不存在重叠，故而联配质量较高，适合用于SNP&#x2F;INDEL calling.相反, multiple mapping则是因为重复造成(read越长出现的概率越低), 相互之间存在重叠，仅有其中一条有最优的匹配，其他联配质量过低会被SNP&#x2F;INDEL caller忽略。</p>
</blockquote>
<h3 id="第一部分-SAM-Header-非强制"><a href="#第一部分-SAM-Header-非强制" class="headerlink" title="第一部分| SAM Header(非强制)"></a>第一部分| SAM Header(非强制)</h3><p>这个部分能够被<code>/^@[A-Z][A-Z](t[A-Za-z][A-Za-z0-9]:[ -~]+)+$/</code>或<code>/^@COt.*/</code>这两个表达式进行匹配。比如说你随便有一个BAM文件（包含header）,就能被这个表达式进行匹配。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samtools view -h S43S1-M_H3K5FDMXX_L1_sort.bam </span><br><span class="line">| awk &#x27;$0 ~ /^@[A-Z][A-Z](t[A-Za-z][A-Za-z0-9]:[ -~]+)+$/ &#123; print $0&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-6b45ac06bb250dd7-e15291c1683440f99f97ba9eae1bedd0.jpg" alt="header"></p>
<p>其中第一行<code>@HD</code>，表示参考基因组的排序情况. 然后<code>@SQ</code>则是参考基因组的每一条序列的具体信息，命名和长度。<code>@PG</code>记录运行的命令，以便你检查代码。对于GATK还需要提供<code>@RG</code>给出每个read所在group的信息，只要保证是独一即可。</p>
<h3 id="第二部分-联配必要信息"><a href="#第二部分-联配必要信息" class="headerlink" title="第二部分| 联配必要信息"></a>第二部分| 联配必要信息</h3><p>第二部分具体记录每一个read的联配结果，一共有11+n列。我将第二张图的信息复制保存到test.sam中，仅仅看第一行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">samtools view test.sam | head -n1 | tr &#x27;t&#x27; &#x27;n&#x27; | nl</span><br><span class="line">   1  r001                   # QNAME: read信息</span><br><span class="line">   2  99                     # FLAG: 信息量大</span><br><span class="line">   3  ref                    # RNAME: 参考序列</span><br><span class="line">   4  7                      # POS:比对到的位置</span><br><span class="line">   5  30                     # MAPQ: 比对质量</span><br><span class="line">   6  8M2I4M1D3M             # CIGAR: 信息量大</span><br><span class="line">   7  =                      # RNEXT: 配对read所在序列，=表示同一条序列</span><br><span class="line">   8  37                     # PNEXT: 配对read所在位置</span><br><span class="line">   9  39                     # TLENT: 观察到的模板长度</span><br><span class="line">  10  TTAGATAAAGGATACTG      # SEQ: segment序列</span><br><span class="line">  11  *                      # QUAL: segment的质量</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">*表示信息不存在</span></span><br></pre></td></tr></table></figure>

<p>简单解释TLENT: 通过IGV可视化展示克制，TLENT相当于read发现了参考序列那些区域。如果是PE数据还可以推断出文库平均大小。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-e9bf3249407e89c5-7310bdf13fbe4e5291323ec4d0e31b47.jpg" alt="一个PE数据"><br><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-ade968d846e1503b-a08ed8269aa84adfa0af0c67dd2dea13.jpg" alt="IGV展示"></p>
<p>详细介绍FLAG: FLAG的主要目的就是用较少的记录长度表示当前记录的序列的匹配情况。相当于开关，仅有有无两个状态，有某个数值就表示序列符合某个情况。</p>
<table>
<thead>
<tr>
<th align="center">flag</th>
<th align="center">代表</th>
<th align="left">具体含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1(0x1)</td>
<td align="center">PAIRED</td>
<td align="left">代表这个序列采用的是PE双端测序</td>
</tr>
<tr>
<td align="center">2(0x2)</td>
<td align="center">PROPER_PAIR</td>
<td align="left">代表这个序列和参考序列完全匹配，没有插入缺失</td>
</tr>
<tr>
<td align="center">4(0x4)</td>
<td align="center">UNMAP</td>
<td align="left">代表这个序列没有mapping到参考序列上</td>
</tr>
<tr>
<td align="center">8(0x8)</td>
<td align="center">MUNMAP</td>
<td align="left">代表这个序列的另一端序列没有比对到参考序列上，比如这条序列是R1,它对应的R2端序列没有比对到参考序列上</td>
</tr>
<tr>
<td align="center">16(0x10)</td>
<td align="center">REVERSE</td>
<td align="left">代表这个序列比对到参考序列的负链上</td>
</tr>
<tr>
<td align="center">32(0x20)</td>
<td align="center">MREVERSE</td>
<td align="left">代表这个序列对应的另一端序列比对到参考序列的负链上</td>
</tr>
<tr>
<td align="center">64(0x40)</td>
<td align="center">READ1</td>
<td align="left">代表这个序列是R1端序列， read1;</td>
</tr>
<tr>
<td align="center">128(0x80)</td>
<td align="center">READ2</td>
<td align="left">代表这个序列是R2端序列，read2；</td>
</tr>
<tr>
<td align="center">256(0x100)</td>
<td align="center">SECONDARY</td>
<td align="left">代表这个序列不是主要的比对，一条序列可能比对到参考序列的多个位置，只有一个是首要的比对位置，其他都是次要的</td>
</tr>
<tr>
<td align="center">512(0x200)</td>
<td align="center">QCFAIL</td>
<td align="left">代表这个序列在QC时失败了，被过滤不掉了（# 这个标签不常用）</td>
</tr>
<tr>
<td align="center">1024(0x400)</td>
<td align="center">DUP</td>
<td align="left">代表这个序列是PCR重复序列（#这个标签不常用）</td>
</tr>
<tr>
<td align="center">2048(0x800)</td>
<td align="center">SUPPLEMENTARY</td>
<td align="left">代表这个序列是补充的比对（#这个标签具体什么意思，没搞清楚，但是不常用）</td>
</tr>
</tbody></table>
<p>举例说明，比如说实例中的99&#x3D;64+32+2+1, 也就是这个记录所代表的read是来自于双端测序R1，且匹配的非常好，对应的另一条链匹配到了负链(自己是正链)。而147&#x3D;128+16+2+1则是表示这个记录来自于双端测序的R2,完全匹配到负链. 如果是163和83，你会发现163&#x3D;147-16+32, 83&#x3D;99-32+16,也就是刚好和前面的不同，也就是说R1匹配负链，R2匹配正链。如果是81和161，由于161&#x3D;163-2,81&#x3D;83-2. 表明这些read不是完全匹配，存在插入缺失</p>
<p>那么问题来了,如下是我某一次比对的flag的统计情况，你能看出什么来</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-0bc3d3108151aea9-ea0a8dac31c34f52862b7840e65d2555.jpg" alt="小测试"></p>
<p><strong>常见的FLAGs</strong>:</p>
<ul>
<li>其中一条reads没有map上: 73, 133, 89 121, 165, 181, 101, 117, 153, 185, 59, 137</li>
<li>两条reads都没有map上: 77,141</li>
<li>比对上了，方向也对，也在插入大小(insert size)内: 99, 147, 83, 163</li>
<li>比对上了，也在插入大小(insert size)内， 但是反向不对:67, 131, 115, 179</li>
<li>单一配对，就是插入大小(insert size)不对: 81, 161, 97, 145, 65, 129, 113, 177</li>
</ul>
<p>FLAG仅仅存储比对的大致情况，每条比对上的read的实际情况则是要用CIGAR进行记录. 依旧举几个例子,比如说，这是双端测序的一条read比对情况，其中一个是117表示没有匹配上，所以记录就是<code>*</code>,另一个是185表示这条序列完美匹配，所以记录是<code>150M</code>.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ST-E00600:109:H3K5FALXX:2:1103:17996:34788      117     Chr1    38      0       *       =       38      0       TTTATACACTATGATTTTCAAAGTGAGAATCCGGTTTGTGGTTTATTGTTTTAGGTATTTAGTTATTAATGTATTTTGGATTTATTGATTTAGTGTTTTAGTGATTAATTATTCATTGTTTTAGTGTTTATGGTTTAGTGTTTAGGGTTT  J-7-J------JJJ7JJJ-J-J---JJ-----JJJJJ--J-JJJJ-----JJ--JJJJJJ-J--JJJ7JJ-7-J-J-777JJJJ777JJ7JJ77J7JJJJ7777JJ77777JJJ777J77J77J7JJJJ77JJJJJJJ7JJJJJJFFFAA  MC:Z:150M       AS:i:0  XS:i:0</span><br><span class="line">ST-E00600:109:H3K5FALXX:2:1103:17996:34788      185     Chr1    38      60      150M    =       38      0       CATTAATCCCTAAATCCCTAAATCTTTAAATCCTACATCCATGAATCCCTAAATAACTAATTCCCTAAACCCGAAACCTGTTTCTCTGGTTGAAAATCATTGTGTATATAATGATAATTTTATCGTTTTTATGTAATTGCTTATTGTTTT  J-JJ7JJJ-JJJ7JJ--JJJ--JJ-JJJJJJ-JJJJJJ--J-JJJJJJJJJ--JJ-JJJJJJJ-JJJJ--J----J-J--JJJJJJ777JJJ77J7JJJJJJJ7JJJJJ7JJJJJ77JJJJJJ7JJ7JJJ7JJJJJJJJJJJJJJFFF&lt;A  NM:i:4  MD:Z:1C53C22G69G1       AS:i:136        XS:i:0</span><br></pre></td></tr></table></figure>

<p>来一个复杂的例子<code>69H10M3I31M37H</code>，表示150bp的读长，先删掉69个碱基，后面是10个匹配，后面相比较参考基因组有3个插入，随后是31个匹配，最后再剔除37个基因,通过IGV查看在参考基因组的情况如下图所示。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-90fdafbe0c86de64-28e3859cf8ed4fc1bcef912acd3e2d6f.jpg" alt="IGV查看FLAGS"></p>
<p>我还发现这段区域存在特别多的clip，加载GFF查看注释信息后发现这是内含子区域。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-a3cec89579792559-b2d659fc3dba4625b3c3e50bf41da961.jpg" alt="IGV检查"></p>
<p>实际上，CIGAR一共有9个字符，分别是M(alignment match),I(insertion),D(deletion),N(skip),S(soft clip),H(hard clip),P(padding),&#x3D;(sequence match), X(sequence mismatch).值得提醒就是M表示序列能够联配，但是存在碱基不一致，&#x3D;表示碱基相同。S和H一般用于read前后出现大部分的错配，但是中间能够联配的情况，其中S表示序列会出现在SEQ中，H则不会出现在SEQ列中。</p>
<h3 id="第三部分，可选信息"><a href="#第三部分，可选信息" class="headerlink" title="第三部分，可选信息"></a>第三部分，可选信息</h3><p>除了之前的11列必须要有的信息外，后面的其他列都是不同的比对软件自定义的额外信息，称之为标签（TAG)。标签的格式一般为<code>TAG:TYPE:VALUE</code>，比如说<code>NM:i:4 MD:Z:1C53C22G69G1 AS:i:136 XS:i:0</code>。这部分内容见<a target="_blank" rel="noopener" href="http://samtools.github.io/hts-specs/SAMtags.pdf">http://samtools.github.io/hts-specs/SAMtags.pdf</a>. 介绍几个比较常见的标签</p>
<ul>
<li>NM: 编辑距离(edit distance)</li>
<li>MD: 错配位置&#x2F;碱基(mismatching positions&#x2F;bases)</li>
<li>AS: 联配得分(Alignment score)</li>
<li>BC: 条码序列（barcode sequence)</li>
<li>XS: 次优联配得分(suboptimal alignment score)</li>
</ul>
<h2 id="能用于处理SAM格式的工具们"><a href="#能用于处理SAM格式的工具们" class="headerlink" title="能用于处理SAM格式的工具们"></a>能用于处理SAM格式的工具们</h2><p>后续演示所用数据通过如下方法获取</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># efetch下载参考基因组</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/biostar/refs/ebola</span><br><span class="line"><span class="built_in">cd</span> ~/biostar</span><br><span class="line">efetch -db=nuccore -format=fasta -<span class="built_in">id</span>=AF086833 &gt; ~/refs/ebola/1976.fa</span><br><span class="line">REF=~/biostar/refs/ebola/1976.fa</span><br><span class="line"><span class="comment"># 构建索引</span></span><br><span class="line">bwa index <span class="variable">$REF</span></span><br><span class="line">bowtie2-build <span class="variable">$REF</span> <span class="variable">$REF</span></span><br><span class="line"><span class="comment"># 获取10000行的fastq PE数据</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/biostar/fastq</span><br><span class="line"><span class="built_in">cd</span> ~/biostar/fastq</span><br><span class="line">fastq-dump -X 10000 --split-files SRR1972739</span><br><span class="line">R1=~/biostar/fastq/SRR1972739_1.fastq</span><br><span class="line">R2=~/biostar/fastq/SRR1972739_2.fastq</span><br></pre></td></tr></table></figure>

<p>处理SAM的命令行工具有<code>samtools</code>,<code>bamtools</code>,<code>picard</code>,<code>sambamba</code>,<code>samblaster</code>等，其中<code>samtools</code>和<code>bamtools</code>和<code>picard</code>比较全能，功能中存在重叠，更多是互补，而<code>sambamba</code>和<code>samblaster</code>则是运行速度更快，功能不太全。</p>
<h3 id="使用SAMtools创建SAM-BAM和CRAM"><a href="#使用SAMtools创建SAM-BAM和CRAM" class="headerlink" title="使用SAMtools创建SAM,BAM和CRAM"></a>使用SAMtools创建SAM,BAM和CRAM</h3><p>SAM格式是目前用来存放大量核酸比对结果信息的通用格式，也是人类能够“直接”阅读的格式类型，而BAM和CRAM是为了方便传输，降低存储压力将SAM进行压缩得到的格式形式。 为了高效处理SAM文件，李恒写了配套的SAMtools, 文章在2009年发表在bioinformatics上，由于samtools的版本经常更新，如果有些工具用不了，你或许要更新版本了。</p>
<p>如果不加任何其他参数，比对软件就能得到“标准”的SAM格式的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bwa mem <span class="variable">$REF</span> <span class="variable">$R1</span> <span class="variable">$R2</span> &gt; bwa.sam</span><br><span class="line">bowtie2 -x <span class="variable">$REF</span> -1 <span class="variable">$R1</span> -2 <span class="variable">$R2</span> &gt; bowtie.sam</span><br></pre></td></tr></table></figure>

<p>原始SAM格式体积又大，没有排序，不利于后续的分析操作，所以需要经过几步的格式转换成为BAM。1.3版本之后的samtools可以一步进行格式转换和排序.</p>
<p><strong>注</strong>，BAM格式必须要建立索引才能快速读取指定位置的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.3版本前</span></span><br><span class="line">samtools view -bS bwa.sam &gt; bwa.bam</span><br><span class="line">samtools <span class="built_in">sort</span> bwa.bam &gt; bwa_sorted.bam</span><br><span class="line">samtools index bwa_sorted.bam</span><br><span class="line"><span class="comment"># 1.3版本后</span></span><br><span class="line">samtools <span class="built_in">sort</span> bwa.sam &gt; bwa_sorted.bam</span><br><span class="line">samtools index bwa_sorted.bam</span><br></pre></td></tr></table></figure>

<p>CRAM是比BAM压缩更加高压的格式，原因是它是基于一个参考序列，这样子就能去掉很多冗余的内容。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samtools <span class="built_in">sort</span> --reference <span class="variable">$REF</span> -O cram bwa.sam &gt; bwa.cram</span><br><span class="line">samtools index bwa.cram</span><br></pre></td></tr></table></figure>

<p>这一小节学习了两个samtools子命令:<code>sort</code>和<code>index</code>，前者能一边排序一边进行格式转换，后者则是对BAM进行索引。</p>
<h3 id="使用SAMtool查看-过滤-转换SAM-BAM-CRAM文件"><a href="#使用SAMtool查看-过滤-转换SAM-BAM-CRAM文件" class="headerlink" title="使用SAMtool查看&#x2F;过滤&#x2F;转换SAM&#x2F;BAM&#x2F;CRAM文件"></a>使用SAMtool查看&#x2F;过滤&#x2F;转换SAM&#x2F;BAM&#x2F;CRAM文件</h3><p>上一节得到的SAM&#x2F;BAM&#x2F;CRAM文件都可以用samtools的<code>view</code>进行更加复杂的操作，只不过要注意读取CRAM格式需要提供参考序列，不然打不开。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">samtools view bwa_sorted.bam</span><br><span class="line">samtools view -T <span class="variable">$REF</span> bwa.cram</span><br></pre></td></tr></table></figure>

<p>samtools的<code>view</code>在增加额外参数后能实现更多的操作，比如说SAM和BAM&#x2F;CRAM之间的格式转换(-b, -c, -T)，过滤或提取出目标联配(-t,-L ,-r,-R,-q,-l,-m,-f,-F,-G), 举几个例子说明</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留mapping quality 大于 10的结果</span></span><br><span class="line">samtools view -q 10 bwa_sorted.bam -b -o bwa_sorted_mq10.bam</span><br><span class="line"><span class="comment"># 统计结果中恰当配对的结果(0x3 3 PARIED,PROPER_PAIR)</span></span><br><span class="line">samtools view -c -f 3 bwa_sorted.bam</span><br><span class="line"><span class="comment"># 或反向选择</span></span><br><span class="line">samtools view -c -F 3 bwa_sorted.bam</span><br></pre></td></tr></table></figure>

<h3 id="使用PrettySam更好的可视化SAM文件"><a href="#使用PrettySam更好的可视化SAM文件" class="headerlink" title="使用PrettySam更好的可视化SAM文件"></a>使用PrettySam更好的可视化SAM文件</h3><p>尽管我上面说SAM是适合人类阅读的数据，但是直接读SAM还是挺费脑子的。GitHub上有一个PrettySam能够更好的展示SAM&#x2F;BAM文件，虽然感觉没多大实际效果，但是有利于我们方便了解SAM格式，项目地址为<a target="_blank" rel="noopener" href="http://lindenb.github.io/jvarkit/PrettySam.html">http://lindenb.github.io/jvarkit/PrettySam.html</a>.</p>
<p>他的安装比较麻烦，需要JDK版本为1.8且是Oracle, 以及GNU Make &gt;&#x3D;3.81, curl&#x2F;wget, git 和 xslproc.安装如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> <span class="string">&quot;https://github.com/lindenb/jvarkit.git&quot;</span></span><br><span class="line"><span class="built_in">cd</span> jvarkit</span><br><span class="line">make prettysam</span><br><span class="line"><span class="built_in">cp</span> dist/prettysam.jar ~/usr/jars/</span><br></pre></td></tr></table></figure>

<p>使用起来非常简单，效果也比较酷炫，比较适合演示用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar usr/jars/prettysam.jar ~/biostar/ebola.sam --colors</span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-cc3914ebeb956c14-4fefa542d581406db0bd6a048d49e97c.jpg" alt="PrettySam"></p>
<h3 id="为SAM-BAM添加Read-Groups"><a href="#为SAM-BAM添加Read-Groups" class="headerlink" title="为SAM&#x2F;BAM添加Read Groups"></a>为SAM&#x2F;BAM添加Read Groups</h3><p>使用GATK分析BAM文件时需要BAM文件的header里有RG部分，<code>@RG</code>至少由三个记录(ID,LB,SM)组成，需要根据实际情况增加。RG可以在前期比对时添加RG部分，也可以在后续处理时增加</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TAG=<span class="string">&#x27;@RG\tID:xzg\tSM:Ebola\tLB:patient_100&#x27;</span></span><br><span class="line"><span class="comment"># Add the tags during alignment</span></span><br><span class="line">bwa mem -R <span class="variable">$TAG</span> <span class="variable">$REF</span> <span class="variable">$R1</span> <span class="variable">$R2</span> | samtools <span class="built_in">sort</span> &gt; bwa.bam</span><br><span class="line">samtools index bwa.bam</span><br><span class="line"><span class="comment"># Add tags with samtools addreplacerg</span></span><br><span class="line">samtools addreplacerg -r <span class="variable">$TAG</span> bwa_sorted.bam -o bwa_sorted_with_rg.bam</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://samtools.github.io/hts-specs/SAMv1.pdf">Sequence Alignment&#x2F;Map Format Specification</a></li>
<li><a target="_blank" rel="noopener" href="http://samtools.github.io/hts-specs/SAMtags.pdf">SAM tags</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/27/SAMtools_%20SAM%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%A4%84%E7%90%86%E5%88%A9%E5%99%A8-samtools-usage-documents/" data-id="clm1z22b3000jehn5c3ti5h1d" data-title="SAMtools:SAM格式的处理利器" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/samtools/" rel="tag">samtools</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-使用Snakemake搭建分析流程-using-snakemake-to-build-pipeline" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/27/%E4%BD%BF%E7%94%A8Snakemake%E6%90%AD%E5%BB%BA%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B-using-snakemake-to-build-pipeline/" class="article-date">
  <time class="dt-published" datetime="2019-08-27T19:35:26.577Z" itemprop="datePublished">2019-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/27/%E4%BD%BF%E7%94%A8Snakemake%E6%90%AD%E5%BB%BA%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B-using-snakemake-to-build-pipeline/">使用Snakemake搭建分析流程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="目前已有的框架"><a href="#目前已有的框架" class="headerlink" title="目前已有的框架"></a>目前已有的框架</h2><p>A review of bioinformatics pipeline framework 的作者对已有的工具进行很好的分类</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/5-b9Y64zX54qeWQQir-40da005c8f7045bc9d29668fe5db8969.png" alt="工具推荐"></p>
<p>作者的看法：</p>
<ol>
<li>implicit，也就是Make rule语法更适合用于整合不同执行工具</li>
<li>基于配置的流程更加稳定，也比较适合用于集群分配任务。</li>
</ol>
<p>最后作者建议是：</p>
<ul>
<li>如果实验室既不是纯粹的生物学试验（不需要workbench这种UI界面），也不需要高性能基于类的流程设计， 不太好选， 主要原则是投入和产出比</li>
<li>如果实验室进行的是<strong>重复性</strong>的研究，那么就需要对数据和软件进行<strong>版本控制</strong>， 建议是 configuration-based pipelines</li>
<li>如果实验室做的是探索性的概念证明类工作（exploratory proofs-of-concept)，那么需要的是 DSL-based pipeline。</li>
<li>如果实验室用不到高性能计算机(HPC)，只能用云服务器，就是server-based frameworks.</li>
</ul>
<p>目前已有的流程可以在<a target="_blank" rel="noopener" href="https://github.com/pditommaso/awesome-pipeline">awesome-pipeline</a> 进行查找。</p>
<p>就目前来看，pipeline frameworks &amp; library 这部分的框架中 <a target="_blank" rel="noopener" href="https://github.com/nextflow-io/nextflow">nextflow</a> 是点赞数最多的生物学相关框架。只可惜nextflow在运行时需要创建fifo，而在NTFS文件系统上无法创建，所以我选择 <em>snakemake</em> , 一个基于Python写的DSL流程框架。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>为了能够顺利完成这部分的教程，请准备一个Linux环境，如果使用Windows，则按照<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f8cdb0e10940">biostarhandbook(一)分析环境和数据可重复</a> 部署一个虚拟机，并安装miniconda3。</p>
<p>如下步骤会下载所需数据，并安装所需要的软件，并且启动工作环境。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://bitbucket.org/snakemake/snakemake-tutorial/get/v3.11.0.tar.bz2</span><br><span class="line">tar -xf v3.11.0.tar.bz2 --strip 1</span><br><span class="line"><span class="built_in">cd</span> snakemake-snakemake-tutorial-623791d7ec6d</span><br><span class="line">conda <span class="built_in">env</span> create --name snakemake-tutorial --file environment.yaml</span><br><span class="line"><span class="built_in">source</span> activate snakemake-tutorial</span><br><span class="line"><span class="comment"># 退出当前环境</span></span><br><span class="line"><span class="built_in">source</span> deactivate</span><br></pre></td></tr></table></figure>

<p>当前环境下的所有文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">├── data</span><br><span class="line">│   ├── genome.fa</span><br><span class="line">│   ├── genome.fa.amb</span><br><span class="line">│   ├── genome.fa.ann</span><br><span class="line">│   ├── genome.fa.bwt</span><br><span class="line">│   ├── genome.fa.fai</span><br><span class="line">│   ├── genome.fa.pac</span><br><span class="line">│   ├── genome.fa.sa</span><br><span class="line">│   └── samples</span><br><span class="line">│       ├── A.fastq</span><br><span class="line">│       ├── B.fastq</span><br><span class="line">│       └── C.fastq</span><br><span class="line">├── environment.yaml</span><br><span class="line">└── README.md</span><br></pre></td></tr></table></figure>

<h2 id="基础：一个案例流程"><a href="#基础：一个案例流程" class="headerlink" title="基础：一个案例流程"></a>基础：一个案例流程</h2><p>如果你编译过软件，那你应该见过和用过<code>make</code>, 但是你估计也没有仔细想过make是干嘛用的。Make是最常用的软件构建工具，诞生于1977年，主要用于C语言的项目，是为了处理编译时存在各种依赖关系，尤其是部分文件更新后，Make能够重新生成需要更新的文件以及其对应的文件。</p>
<p><code>Snakemake</code>和Make功能一致，只不过用Python实现，增加了许多Python的特性，并且和Python一样非常容易阅读。下面将使用Snakemake写一个<strong>变异检测</strong>流程。</p>
<h3 id="第一步：序列比对"><a href="#第一步：序列比对" class="headerlink" title="第一步：序列比对"></a>第一步：序列比对</h3><p>Snakemake非常简单，就是写各种<strong>rule</strong>来完成不同的任务。我们第一条<strong>rule</strong>就是将序列比对到参考基因组上。如果在命令行下就是<code>bwa mem data/genome.fa data/samples/A.fastq | samtools view -Sb - &gt; mapped_reads/A.bam</code>。 但是按照Snakemake的规则就是下面的写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用你擅长的文本编辑器</span></span><br><span class="line">vim Snakefile</span><br><span class="line"><span class="comment"># 编辑如下内容</span></span><br><span class="line">rule bwa_map:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;data/genome.fa&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data/samples/A.fastq&quot;</span></span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;mapped_reads/A.bam&quot;</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        bwa mem &#123;input&#125; | samtools view -Sb - &gt; &#123;output&#125;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>解释一下：这几行定义了一个规则(rule)，在这个规则下，输入(input)有两个，而输出(output)只有一个，在<code>shell</code>中运行命令，只不过里面的文件都用<code>&#123;&#125;</code>形式替代。伪执行一下:<code>snakemake -np mapped_reads/A.bam</code>检查一下是否会出错，真实运行情况如下（不带规则，默认执行第一个规则）:</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-3f6c4c4c04c7e5e8-5fc6b2a1d4e9422eb6ad714fe512d731.jpg" alt="run snakemake"></p>
<h3 id="第二步：推广序列比对规则"><a href="#第二步：推广序列比对规则" class="headerlink" title="第二步：推广序列比对规则"></a>第二步：推广序列比对规则</h3><p>如果仅仅是上面这样子处理一个文件，还无法体现<code>snakemake</code>的用途，毕竟还不如手动敲代码来的方便。<code>snakemake</code>的一个有点在于它能够使用<strong>文件名通配</strong>的方式对一类文件进行处理。将上面的<code>A</code>改成<code>&#123;sample&#125;</code>,就可以将符合<code>*.fastq</code>的文件处理成<code>*.bam</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rule bwa_map:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;data/genome.fa&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data/samples/&#123;sample&#125;.fastq&quot;</span></span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;mapped_reads/&#123;sample&#125;.bam&quot;</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        bwa mem &#123;input&#125; | samtools view -Sb - &gt; &#123;output&#125;</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>那么，用<code>snakemake -np mapped_reads/&#123;A,B,C&#125;.bam</code>，就会发现，他非常机智的就比对了<code>B.fastq</code>和<code>C.fastq</code>，<strong>而不会</strong>再比对一遍A.fastq, <strong>也不需要</strong>你写一堆的判断语句去手动处理。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-ea6dea98af7d2507-1566905428169-26885941bfd647e8986dd32e73845752.jpg" alt="规则统配"></p>
<p>当然，如果你用<code>touch data/samples/A.fastq</code>改变A.fastq的时间戳，他就会认位A.fastq文件发生了改变，那么重复之前的命令就会比对A.fastq。</p>
<h3 id="第三步：比对后排序"><a href="#第三步：比对后排序" class="headerlink" title="第三步：比对后排序"></a>第三步：比对后排序</h3><p>比对后的文件还需要进一步的排序，才能用于后续分析，那么规则该如何写呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule samtools_sort:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;mapped_reads/&#123;sample&#125;.bam&quot;</span></span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;sorted_reads/&#123;sample&#125;.bam&quot;</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;samtools sort -T sorted_reads/&#123;wildcards.sample&#125;&quot;</span></span><br><span class="line">        <span class="string">&quot; -O bam &#123;input&#125; &gt; &#123;output&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>以之前的输出作为输出文件名，输出到另一个文件夹中。和之前的规则基本相同，只不过这里用到了<code>wildcards.sample</code>来获取通配名用作<code>-T</code>的临时文件的前缀<code>sample</code>实际名字。</p>
<p>运行<code>snakemake -np sorted_reads/B.bam</code>，你就会发现他就会非常智能的<strong>先比对再排序</strong>。这是因为<code>snakemake</code>会自动解决依赖关系，并且按照依赖的前后顺序进行执行。</p>
<h3 id="第四步：-建立索引和对任务可视化"><a href="#第四步：-建立索引和对任务可视化" class="headerlink" title="第四步： 建立索引和对任务可视化"></a>第四步： 建立索引和对任务可视化</h3><p>这里我们再写一个规则，对之前的排序后的BAM文件建立索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rule samtools_index:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;sorted_reads/&#123;sample&#125;.bam&quot;</span></span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;sorted_reads/&#123;sample&#125;.bam.bai&quot;</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;samtools index &#123;input&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>目前已经写了三个规则，那么这些规则的执行和依赖关系如何呢？ <code>snakemake</code>提供了<code>--dag</code>选项用于<code>dot</code>命令进行可视化</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snakemake --dag sorted_reads/&#123;A,B&#125;.bam.bai | dot -Tsvg &gt; dag.svg</span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/dag_index-7bf84371f6954fe2a087c8ecf1c7fedb.png" alt="运行流程"></p>
<h3 id="第五步：基因组变异识别"><a href="#第五步：基因组变异识别" class="headerlink" title="第五步：基因组变异识别"></a>第五步：基因组变异识别</h3><p>基因组变异识别需要整合之前所有的BAM文件，你可能会打算这样写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rule bcftools_call:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        fa=<span class="string">&quot;data/genome.fa&quot;</span>,</span><br><span class="line">        bamA=<span class="string">&quot;sorted_reads/A.bam&quot;</span></span><br><span class="line">        bamB=<span class="string">&quot;sorted_reads/B.bam&quot;</span></span><br><span class="line">        baiA=<span class="string">&quot;sorted_reads/A.bam.bai&quot;</span></span><br><span class="line">        baiB=<span class="string">&quot;sorted_reads/B.bam.bai&quot;</span></span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;calls/all.vcf&quot;</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;samtools mpileup -g -f &#123;input.fa&#125; &#123;input.bamA&#125; &#123;input.bamB&#125; | &quot;</span></span><br><span class="line">        <span class="string">&quot;bcftools call -mv - &gt; &#123;output&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这样写的却没有问题，但是以后每多一个样本就需要多写一个输入，太麻烦了。这里就体现出Snakemake和Python所带来的特性了，我们可以用列表推导式的方法搞定。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;sorted_reads/&#123;&#125;.bam&quot;</span>.<span class="built_in">format</span>(sample) <span class="keyword">for</span> sample <span class="keyword">in</span> [<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>]]</span><br></pre></td></tr></table></figure>

<p>进一步，可以在规则外定义<code>SAMPLES=[&quot;A&quot;,&quot;B&quot;]</code>，则规则内的输入可以写成<code>bam=[&quot;sorted_reads/&#123;&#125;.bam&quot;.format(sample) for sample in SAMPLES]</code>. 由于列表推导式比较常用，但是写起来有点麻烦，snakemake定义了<code>expand</code>进行简化, 上面可以继续改写成<code>expand(&quot;sorted_reads/&#123;sample&#125;.bam&quot;, sample=SAMPLES)</code></p>
<p>那么最后的规则就是</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SAMPLES=[<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>]</span><br><span class="line">rule bcftools_call:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        fa=<span class="string">&quot;data/genome.fa&quot;</span>,</span><br><span class="line">        bam=expand(<span class="string">&quot;sorted_reads/&#123;sample&#125;.bam&quot;</span>, sample=SAMPLES),</span><br><span class="line">        bai=expand(<span class="string">&quot;sorted_reads/&#123;sample&#125;.bam.bai&quot;</span>, sample=SAMPLES)</span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;calls/all.vcf&quot;</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;samtools mpileup -g -f &#123;input.fa&#125; &#123;input.bam&#125; | &quot;</span></span><br><span class="line">        <span class="string">&quot;bcftools call -mv - &gt; &#123;output&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>小练习： 请用snakemake生成当前的DAG图。</p>
<h3 id="第六步：编写报告"><a href="#第六步：编写报告" class="headerlink" title="第六步：编写报告"></a>第六步：编写报告</h3><p>上面都是在规则里执行shell脚本，snakemake的一个<strong>优点</strong>就是可以在规则里面写Python脚本，只需要把<code>shell</code>改成<code>run</code>，此外还不需要用到引号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rule report:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;calls/all.vcf&quot;</span></span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;report.html&quot;</span></span><br><span class="line">    run:</span><br><span class="line">        <span class="keyword">from</span> snakemake.utils <span class="keyword">import</span> report</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="built_in">input</span>[<span class="number">0</span>]) <span class="keyword">as</span> vcf:</span><br><span class="line">            n_calls = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> l <span class="keyword">in</span> vcf <span class="keyword">if</span> <span class="keyword">not</span> l.startswith(<span class="string">&quot;#&quot;</span>))</span><br><span class="line"></span><br><span class="line">        report(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        An example variant calling workflow</span></span><br><span class="line"><span class="string">        ===================================</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Reads were mapped to the Yeast</span></span><br><span class="line"><span class="string">        reference genome and variants were called jointly with</span></span><br><span class="line"><span class="string">        SAMtools/BCFtools.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This resulted in &#123;n_calls&#125; variants (see Table T1_).</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>, output[<span class="number">0</span>], T1=<span class="built_in">input</span>[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>这里还用到了<code>snakemake</code>的一个函数，<strong>report</strong>，可以对markdown语法进行渲染生成网页。</p>
<h3 id="第七步：增加目标规则"><a href="#第七步：增加目标规则" class="headerlink" title="第七步：增加目标规则"></a>第七步：增加<strong>目标规则</strong></h3><p>之前运行snakemake都是用的<code>snakemake 目标文件名</code>, 除了目标文件名外，snakemake还支持规则名作为目标。通常我们按照习惯定义一个<code>all</code>规则，来生成结果文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rule <span class="built_in">all</span>:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;report.html</span></span><br></pre></td></tr></table></figure>

<h3 id="基础部分小结："><a href="#基础部分小结：" class="headerlink" title="基础部分小结："></a>基础部分小结：</h3><p>总结下学习过程，知识点如下：</p>
<ul>
<li>Snakemake基于规则执行命令，规则一般由<code>input, output,shell</code>三部分组成。</li>
<li>Snakemake可以自动确定不同规则的输入输出的依赖关系，根据时间戳来判断文件是否需要重新生成</li>
<li>Snakemake<code>以&#123;sample&#125;.fa</code>形式进行文件名通配，用<code>&#123;wildcards.sample&#125;</code>获取sample的实际文件名</li>
<li>Snakemake用<code>expand()</code>生成多个文件名，本质是Python的列表推导式</li>
<li>Snakemake可以在规则外直接写Python代码，在规则内的<code>run</code>里也可以写Python代码。</li>
<li>Snakefile的第一个规则通常是<code>rule all</code>，因为默snakemake默认执行第一条规则</li>
</ul>
<h2 id="进阶：对流程进一步修饰"><a href="#进阶：对流程进一步修饰" class="headerlink" title="进阶：对流程进一步修饰"></a>进阶：对流程进一步修饰</h2><p>在基础部分中，我们完成了流程的框架，下一步则是对这个框架进行不断完善，比如说编写配置文件，声明不同rule的消耗资源，记录运行日志等。</p>
<h3 id="第一步：-声明所需进程数"><a href="#第一步：-声明所需进程数" class="headerlink" title="第一步： 声明所需进程数"></a>第一步： 声明所需进程数</h3><p>对于一些工具，比如说bwa，多进程或者多线程运行能够大大加速计算。snakemake使用<code>threads</code>来定义当前规则所用的进程数，我们可以对之前的<code>bwa_map</code>增加该指令。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule bwa_map:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;data/genome.fa&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data/samples/&#123;sample&#125;.fastq&quot;</span></span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;mapped_reads/&#123;sample&#125;.bam&quot;</span></span><br><span class="line">    threads:<span class="number">8</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;bwa mem -t &#123;threads&#125; &#123;input&#125; | samtools view -Sb - &gt; &#123;output&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>声明<code>threads</code>后，Snakemake任务调度器就会在程序运行的时候是否<strong>并行</strong>多个任务。这主要和参数中的<code>--cores</code>相关。比如说</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">snakemake --cores 10</span><br></pre></td></tr></table></figure>

<p>由于总体上就分配了10个核心，于是一次就只能运行一个需要消耗8个核心的<code>bwa_map</code>。但是当其中一个<code>bwa_map</code>运行完毕，这个时候snakemaek就会同时运行一个消耗8个核心的<code>bwa_map</code>和没有设置核心数的<code>samtools_sort</code>,来保证效率最大化。因此对于需要多线程或多进程运行的程序而言，将所需的进程<strong>单独编码</strong>，而不是硬编码到shell命令中，能够更有效的使用资源。</p>
<h3 id="第二步：配置文件"><a href="#第二步：配置文件" class="headerlink" title="第二步：配置文件"></a>第二步：配置文件</h3><p>之前的SAMPLES写在了snakefile，也就是意味这对于不同的项目，需要对snakefile进行修改，更好的方式是用一个配置文件。配置文件可以用JSON或YAML语法进行写，然后用<code>configfile: &quot;config.yaml&quot;</code>读取成字典，变量名为config。</p>
<p><code>config.yaml</code>内容为:</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">samples:</span></span><br><span class="line">    <span class="attr">A:</span> <span class="string">data/samples/A.fastq</span></span><br><span class="line">    <span class="attr">B:</span> <span class="string">data/samples/B.fastq</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>YAML使用缩进表示层级关系，其中缩进必须用空格，但是空格数目不重要，重要的是所今后左侧对齐。上面的YAML被Pytho读取之后，以字典保存，形式为<code>&#123;&#39;samples&#39;: &#123;&#39;A&#39;: &#39;data/samples/A.fastq&#39;, &#39;B&#39;: &#39;data/samples/B.fastq&#39;&#125;&#125;</code></p>
</blockquote>
<p>而snakefile也可以改写成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">configfile: <span class="string">&quot;config.yaml&quot;</span></span><br><span class="line">...</span><br><span class="line">rule bcftools_call:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        fa=<span class="string">&quot;data/genome.fa&quot;</span>,</span><br><span class="line">        bam=expand(<span class="string">&quot;sorted_reads/&#123;sample&#125;.bam&quot;</span>, sample=config[<span class="string">&quot;samples&quot;</span>]),</span><br><span class="line">        bai=expand(<span class="string">&quot;sorted_reads/&#123;sample&#125;.bam.bai&quot;</span>, sample=config[<span class="string">&quot;smaples])</span></span><br><span class="line"><span class="string">    output:</span></span><br><span class="line"><span class="string">        &quot;</span>calls/<span class="built_in">all</span>.vc<span class="string">f&quot;</span></span><br><span class="line"><span class="string">    shell:</span></span><br><span class="line"><span class="string">        &quot;</span>samtools mpileup -g -f &#123;<span class="built_in">input</span>.fa&#125; &#123;<span class="built_in">input</span>.bam&#125; | <span class="string">&quot;</span></span><br><span class="line"><span class="string">        &quot;</span>bcftools call -mv - &gt; &#123;output&#125;<span class="string">&quot;</span></span><br></pre></td></tr></table></figure>

<p>虽然sample是一个字典，但是展开的时候，只会使用他们的key值部分。</p>
<p>关于YAML格式的教程，见阮一峰的博客：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/07/yaml.html">http://www.ruanyifeng.com/blog/2016/07/yaml.html</a></p>
<h3 id="第三步：输入函数"><a href="#第三步：输入函数" class="headerlink" title="第三步：输入函数"></a>第三步：输入函数</h3><p>既然已经把文件路径都存入到配置文件中，那么可以进一步的改写之前的<code>bwa_map</code>里的输入部分。也就是从字典里面提取到存放的路径。最开始我就是打算这样写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule bwa_map:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;data/genome.fa&quot;</span>,</span><br><span class="line">        config[<span class="string">&#x27;samples&#x27;</span>][<span class="string">&quot;&#123;sample&#125;&quot;</span>]</span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;mapped_reads/&#123;sample&#125;.bam&quot;</span></span><br><span class="line">    threads:<span class="number">8</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;bwa mem -t &#123;threads&#125; &#123;input&#125; | samtools view -Sb - &gt; &#123;output&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>毕竟”{sample}”从理论上应该得到sample的名字。但是<code>snakemake -np</code>显示出现错误</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">KeyError <span class="keyword">in</span> line 11 of /home6/zgxu/snakemake-snakemake-tutorial-623791d7ec6d/Snakefile:</span><br><span class="line"><span class="string">&#x27;&#123;sample&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这可能是<code>&#123;sample&#125;</code>的形式只能在匹配的时候使用，而在获取值的时候应该用基础第三步的<code>wildcards.sample</code>形式。于是继续改成<code>config[&quot;samples&quot;][wildcards.sample]</code>。然而还是出现了错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name <span class="string">&#x27;wildcards&#x27;</span> is not defined</span><br></pre></td></tr></table></figure>

<p>为了理解错误的原因，并找到解决方法，我们需要理解Snakemake工作流程执行的一些原理，它执行分为三个阶段</p>
<ul>
<li>在<strong>初始化</strong>阶段，工作流程会被解析，所有规则都会被实例化</li>
<li>在<strong>DAG</strong>阶段，也就是生成有向无环图，确定依赖关系的时候，所有的通配名部分都会被真正的文件名代替。</li>
<li>在<strong>调度</strong>阶段，DAG的任务按照顺序执行</li>
</ul>
<p>也就是说在<strong>初始化</strong>阶段，我们是无法获知通配符所指代的具体文件名，必须要等到第二阶段，才会有<code>wildcards</code>变量出现。也就是说之前的出错的原因都是因为第一个阶段没通过。这个时候就需要<strong>输入函数</strong>推迟文件名的确定，可以用Python的匿名函数，也可以是普通的函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rule bwa_map:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;data/genome.fa&quot;</span>,</span><br><span class="line">        <span class="keyword">lambda</span> wildcards: config[<span class="string">&quot;samples&quot;</span>][wildcards.sample]</span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;mapped_reads/&#123;sample&#125;.bam&quot;</span></span><br><span class="line">    threads: <span class="number">8</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;bwa mem -t &#123;threads&#125; &#123;input&#125; | samtools view -Sb - &gt; &#123;output&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="第四步：规则参数"><a href="#第四步：规则参数" class="headerlink" title="第四步：规则参数"></a>第四步：规则参数</h3><p>有些时候，shell命令不仅仅是由input和output中的文件组成，还需要一些静态的参数设置。如果把这些参数放在input里，则会因为找不到文件而出错，所以需要专门的<code>params</code>用来设置这些参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rule bwa_map:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;data/genome.fa&quot;</span>,</span><br><span class="line">        <span class="keyword">lambda</span> wildcards: config[<span class="string">&quot;samples&quot;</span>][wildcards.sample]</span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;mapped_reads/&#123;sample&#125;.bam&quot;</span></span><br><span class="line">    threads: <span class="number">8</span></span><br><span class="line">    params:</span><br><span class="line">        rg=<span class="string">&quot;@RG\tID:&#123;sample&#125;\tSM:&#123;sample&#125;&quot;</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;bwa mem -R &#x27;&#123;params.rg&#125;&#x27; &#x27;-t &#123;threads&#125; &#123;input&#125; | samtools view -Sb - &gt; &#123;output&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>写在rule中的params的参数，可以在shell命令中或者是run里面的代码进行调用。</p>
<h3 id="第五步：-日志文件"><a href="#第五步：-日志文件" class="headerlink" title="第五步： 日志文件"></a>第五步： 日志文件</h3><p>当工作流程特别的大，每一步的输出日志都建议保存下来，而不是输出到屏幕，这样子出错的时候才能找到出错的所在。<code>snakemake</code>非常贴心的定义了<code>log</code>,用于记录日志。好处就在于出错的时候，在<code>log</code>里面定义的文件是不会被snakemake删掉，而output里面的文件则是会被删除。继续修改之前的<code>bwa_map</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rule bwa_map:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;data/genome.fa&quot;</span>,</span><br><span class="line">        <span class="keyword">lambda</span> wildcards: config[<span class="string">&quot;samples&quot;</span>][wildcards.sample]</span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;mapped_reads/&#123;sample&#125;.bam&quot;</span></span><br><span class="line">    params:</span><br><span class="line">        rg=<span class="string">&quot;@RG\tID:&#123;sample&#125;\tSM:&#123;sample&#125;&quot;</span></span><br><span class="line">    log:</span><br><span class="line">        <span class="string">&quot;logs/bwa_mem/&#123;sample&#125;.log&quot;</span></span><br><span class="line">    threads: <span class="number">8</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;(bwa mem -R &#x27;&#123;params.rg&#125;&#x27; -t &#123;threads&#125; &#123;input&#125; | &quot;</span></span><br><span class="line">        <span class="string">&quot;samtools view -Sb - &gt; &#123;output&#125;) 2&gt; &#123;log&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里将标准错误重定向到了log中。</p>
<h3 id="第六步：临时文件和受保护的文件"><a href="#第六步：临时文件和受保护的文件" class="headerlink" title="第六步：临时文件和受保护的文件"></a>第六步：临时文件和受保护的文件</h3><p>由于高通量测序的数据量通常很大，因此很多无用的中间文件会占据大量的磁盘空间。而特异在执行结束后写一个shell命令清除不但写起来麻烦，而且也不好管理。Snakemake使用<code>temp()</code>来将一些文件标记成临时文件，在执行结束后自动删除。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rule bwa_map:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;data/genome.fa&quot;</span>,</span><br><span class="line">        <span class="keyword">lambda</span> wildcards: config[<span class="string">&quot;samples&quot;</span>][wildcards.sample]</span><br><span class="line">    output:</span><br><span class="line">        temp(<span class="string">&quot;mapped_reads/&#123;sample&#125;.bam&quot;</span>)</span><br><span class="line">    params:</span><br><span class="line">        rg=<span class="string">&quot;@RG\tID:&#123;sample&#125;\tSM:&#123;sample&#125;&quot;</span></span><br><span class="line">    log:</span><br><span class="line">        <span class="string">&quot;logs/bwa_mem/&#123;sample&#125;.log&quot;</span></span><br><span class="line">    threads: <span class="number">8</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;(bwa mem -R &#x27;&#123;params.rg&#125;&#x27; -t &#123;threads&#125; &#123;input&#125; | &quot;</span></span><br><span class="line">        <span class="string">&quot;samtools view -Sb - &gt; &#123;output&#125;) 2&gt; &#123;log&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>修改之后的代码，当<code>samtools_sort</code>运行结束后就会把”mapped_reads”下的BAM删掉。同时由于比对和排序都比较耗时，得到的结果要是不小心被误删就会浪费大量计算时间，最后的方法就是用<code>protected()</code>保护起来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rule samtools_sort:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;mapped_reads/&#123;sample&#125;.bam&quot;</span></span><br><span class="line">    output:</span><br><span class="line">        protected(<span class="string">&quot;sorted_reads/&#123;sample&#125;.bam&quot;</span>)</span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;samtools sort -T sorted_reads/&#123;wildcards.sample&#125; &quot;</span></span><br><span class="line">        <span class="string">&quot;-O bam &#123;input&#125; &gt; &#123;output&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>最后，snakemake就会在文件系统中对该输出文件写保护，也就是最后的权限为<code>-r--r--r--</code>, 在删除的时候会问你<code>rm: remove write-protected regular file ‘A.bam’?</code>.</p>
<h3 id="进阶部分小结"><a href="#进阶部分小结" class="headerlink" title="进阶部分小结"></a>进阶部分小结</h3><ul>
<li>使用<code>threads:</code>定义不同规则所需线程数，有利于snakemake全局分配任务，最优化任务并行</li>
<li>使用<code>configfile:</code>读取配置文件，将配置和流程分离</li>
<li>snakemake在<strong>DAG</strong>阶段才会知道通配的具体文件名，因此在input和output出现的<code>wildcards</code>就需要推迟到第二步。</li>
<li>在<code>log</code>里定义的日志文件，不会因任务失败而被删除</li>
<li>在<code>params</code>定义的参数，可以在shell和run中直接调用</li>
<li><code>temp()</code>中的文件运行结束后会被删除，而<code>protected()</code>中的文件会有写保护，避免意外删除。</li>
</ul>
<h2 id="高级：实现流程的自动部署"><a href="#高级：实现流程的自动部署" class="headerlink" title="高级：实现流程的自动部署"></a>高级：实现流程的自动部署</h2><p>上面的分析流程都是基于当前环境下已经安装好要调用的软件，如果你希望在新的环境中也能快速部署你的分析流程，那么你需要用到snakmake更高级的特性，也就是为每个rule定义专门的运行环境。</p>
<h3 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h3><p>我建议你在新建一个snakemake项目时，都先用<code>conda create -n 项目名 python=版本号</code>创建一个全局环境，用于安装一些常用的软件，例如bwa、samtools、seqkit等。然后用如下命令将环境导出成yaml文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">env</span> <span class="built_in">export</span> -n 项目名 -f environment.yaml</span><br></pre></td></tr></table></figure>

<p>那么当你到了一个新的环境，你就可以用下面这个命令重建出你的运行环境</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env create -f environment.yaml</span><br></pre></td></tr></table></figure>

<h3 id="局部环境"><a href="#局部环境" class="headerlink" title="局部环境"></a>局部环境</h3><p>当然仅仅依赖于全局环境或许还不够，对于不同的规则(rule)可能还有Python2和Python3的区别，所以你还得为每个规则创建环境。</p>
<p>snakemake有一个参数<code>--use-conda</code>,会解析<code>rule</code>中的<code>conda</code>规则，根据其提供的yaml文件安装特定版本的工具，以基础第一步的序列比对为例，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rule bwa_map:</span><br><span class="line">    input:</span><br><span class="line">        <span class="string">&quot;data/genome.fa&quot;</span>,</span><br><span class="line">        <span class="string">&quot;data/samples/A.fastq&quot;</span></span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;mapped_reads/A.bam&quot;</span></span><br><span class="line">    conda:</span><br><span class="line">        <span class="string">&quot;envs/map.yaml&quot;</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">        mkdir -p mapped_reads</span></span><br><span class="line"><span class="string">        bwa mem &#123;input&#125; | samtools view -Sb - &gt; &#123;output&#125;</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>随后在snakemake执行的目录下创建envs文件夹，增加map.yaml, 内容如下</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">map</span></span><br><span class="line"><span class="attr">channels:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">defaults</span></span><br><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">bwa=0.7.17</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">samtools=1.9</span></span><br><span class="line"><span class="attr">show_channel_urls:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: YAML文件的<code>name</code>行不是必要的，但是建议加上。</p>
<p>那么当你用<code>snakmake --use-conda</code>执行时，他就会在<code>.snakemake/conda</code>下创建专门的conda环境用于处理当前规则。对于当前项目，该conda环境创建之后就会一直用于该规则，除非yaml文件发生改变。</p>
<p>如果你希望在实际运行项目之前先创建好环境，那么可以使用<code>--create-envs-only</code>参数。</p>
<p>由于默认情况下，每个项目运行时只会在当前的<code>.snakemake/conda</code>查找环境或者安装环境，所以在其他目录执行项目时，snakemake又会重新创建conda环境，如果你担心太占地方或者环境太大，安装的时候太废时间，你可以用<code>--conda-prefix</code>指定专门的文件夹。</p>
<blockquote>
<p>一定要使用最新的snakemake和最新的conda。因为conda在启动环境的命令发生过变化，从source activate改成了conda activate</p>
</blockquote>
<h2 id="代码总结"><a href="#代码总结" class="headerlink" title="代码总结"></a>代码总结</h2><p>最后的代码如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">configfile: <span class="string">&quot;config.yaml&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rule <span class="built_in">all</span>:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;report.html&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rule bwa_map:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;data/genome.fa&quot;</span>,</span><br><span class="line">        <span class="keyword">lambda</span> wildcards: config[<span class="string">&quot;samples&quot;</span>][wildcards.sample]</span><br><span class="line">    output:</span><br><span class="line">        temp(<span class="string">&quot;mapped_reads/&#123;sample&#125;.bam&quot;</span>)</span><br><span class="line">    params:</span><br><span class="line">        rg=<span class="string">&quot;@RG\tID:&#123;sample&#125;\tSM:&#123;sample&#125;&quot;</span></span><br><span class="line">    log:</span><br><span class="line">        <span class="string">&quot;logs/bwa_mem/&#123;sample&#125;.log&quot;</span></span><br><span class="line">    threads: <span class="number">8</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;(bwa mem -R &#x27;&#123;params.rg&#125;&#x27; -t &#123;threads&#125; &#123;input&#125; | &quot;</span></span><br><span class="line">        <span class="string">&quot;samtools view -Sb - &gt; &#123;output&#125;) 2&gt; &#123;log&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rule samtools_sort:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;mapped_reads/&#123;sample&#125;.bam&quot;</span></span><br><span class="line">    output:</span><br><span class="line">        protected(<span class="string">&quot;sorted_reads/&#123;sample&#125;.bam&quot;</span>)</span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;samtools sort -T sorted_reads/&#123;wildcards.sample&#125; &quot;</span></span><br><span class="line">        <span class="string">&quot;-O bam &#123;input&#125; &gt; &#123;output&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rule samtools_index:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;sorted_reads/&#123;sample&#125;.bam&quot;</span></span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;sorted_reads/&#123;sample&#125;.bam.bai&quot;</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;samtools index &#123;input&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rule bcftools_call:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        fa=<span class="string">&quot;data/genome.fa&quot;</span>,</span><br><span class="line">        bam=expand(<span class="string">&quot;sorted_reads/&#123;sample&#125;.bam&quot;</span>, sample=config[<span class="string">&quot;samples&quot;</span>]),</span><br><span class="line">        bai=expand(<span class="string">&quot;sorted_reads/&#123;sample&#125;.bam.bai&quot;</span>, sample=config[<span class="string">&quot;samples&quot;</span>])</span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;calls/all.vcf&quot;</span></span><br><span class="line">    shell:</span><br><span class="line">        <span class="string">&quot;samtools mpileup -g -f &#123;input.fa&#125; &#123;input.bam&#125; | &quot;</span></span><br><span class="line">        <span class="string">&quot;bcftools call -mv - &gt; &#123;output&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rule report:</span><br><span class="line">    <span class="built_in">input</span>:</span><br><span class="line">        <span class="string">&quot;calls/all.vcf&quot;</span></span><br><span class="line">    output:</span><br><span class="line">        <span class="string">&quot;report.html&quot;</span></span><br><span class="line">    run:</span><br><span class="line">        <span class="keyword">from</span> snakemake.utils <span class="keyword">import</span> report</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="built_in">input</span>[<span class="number">0</span>]) <span class="keyword">as</span> vcf:</span><br><span class="line">            n_calls = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> l <span class="keyword">in</span> vcf <span class="keyword">if</span> <span class="keyword">not</span> l.startswith(<span class="string">&quot;#&quot;</span>))</span><br><span class="line"></span><br><span class="line">        report(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        An example variant calling workflow</span></span><br><span class="line"><span class="string">        ===================================</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Reads were mapped to the Yeast</span></span><br><span class="line"><span class="string">        reference genome and variants were called jointly with</span></span><br><span class="line"><span class="string">        SAMtools/BCFtools.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This resulted in &#123;n_calls&#125; variants (see Table T1_).</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span>, output[<span class="number">0</span>], T1=<span class="built_in">input</span>[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h2 id="执行snakemake"><a href="#执行snakemake" class="headerlink" title="执行snakemake"></a>执行snakemake</h2><p>写完Snakefile之后就需要用<code>snakemake</code>执行。<code>snakemake</code>的选项非常多，这里列出一些比较常用的运行方式。</p>
<p>运行前检查潜在错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">snakemake -n</span><br><span class="line">snakemake -np</span><br><span class="line">snakemake -nr</span><br><span class="line"><span class="comment"># --dryrun/-n: 不真正执行</span></span><br><span class="line"><span class="comment"># --printshellcmds/-p: 输出要执行的shell命令</span></span><br><span class="line"><span class="comment"># --reason/-r: 输出每条rule执行的原因</span></span><br></pre></td></tr></table></figure>

<p>直接运行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">snakemake</span><br><span class="line">snakemake -s Snakefile -j 4</span><br><span class="line"><span class="comment"># -s/--snakefile 指定Snakefile，否则是当前目录下的Snakefile</span></span><br><span class="line"><span class="comment"># --cores/--jobs/-j N: 指定并行数，如果不指定N，则使用当前最大可用的核心数</span></span><br></pre></td></tr></table></figure>

<p>强制重新运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">snakemake -f</span><br><span class="line"><span class="comment"># --forece/-f: 强制执行选定的目标，或是第一个规则，无论是否已经完成</span></span><br><span class="line">snakemake -F</span><br><span class="line"><span class="comment"># --forceall/-F: 也是强制执行，同时该规则所依赖的规则都要重新执行</span></span><br><span class="line">snakemake -R some_rule</span><br><span class="line"><span class="comment"># --forecerun/-R TARGET: 重新执行给定的规则或生成文件。当你修改规则的时候，使用该命令</span></span><br></pre></td></tr></table></figure>

<p>可视化：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">snakemake --dag  | dot -Tsvg &gt; dag.svg</span><br><span class="line">snakemake --dag  | dit -Tpdf &gt; dag.pdf</span><br><span class="line"><span class="comment"># --dag: 生成依赖的有向图</span></span><br><span class="line">snakemake --gui 0.0.0.0:2468</span><br><span class="line"><span class="comment"># --gui: 通过网页查看运行状态</span></span><br></pre></td></tr></table></figure>

<p>集群执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">snakemake --cluster <span class="string">&quot;qsub -V -cwd -q 投递队列&quot;</span> -j 10</span><br><span class="line"><span class="comment"># --cluster /-c CMD: 集群运行指令</span></span><br><span class="line"><span class="comment">## qusb -V -cwd -q， 表示输出当前环境变量(-V),在当前目录下运行(-cwd), 投递到指定的队列(-q), 如果不指定则使用任何可用队列</span></span><br><span class="line"><span class="comment"># --local-cores N: 在每个集群中最多并行N核</span></span><br><span class="line"><span class="comment"># --cluster-config/-u FILE: 集群配置文件</span></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="http://snakemake.readthedocs.io/en/latest/">snakemake官方文档</a></li>
<li><a target="_blank" rel="noopener" href="http://pedagogix-tagc.univ-mrs.fr/courses/ABD/practical/snakemake/snake_intro.html">用snakemake写RNA-Seq流程</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/07/yaml.html">阮一峰的YAML教程</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/02/make.html">阮一峰的Make命令教程</a></li>
<li><a target="_blank" rel="noopener" href="https://conda.io/docs/user-guide/tasks/manage-environments.html">conda管理环境</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/27/%E4%BD%BF%E7%94%A8Snakemake%E6%90%AD%E5%BB%BA%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B-using-snakemake-to-build-pipeline/" data-id="clm1z22g900baehn59lpz7ols" data-title="使用Snakemake搭建分析流程" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7/" rel="tag">流程工具</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-LTR_retriever_ 一个更加准的LTR整合分析工具-LTR_retriever-accurate-identification-of-LTR-retrotransposons" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/27/LTR_retriever_%20%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%8A%A0%E5%87%86%E7%9A%84LTR%E6%95%B4%E5%90%88%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-LTR_retriever-accurate-identification-of-LTR-retrotransposons/" class="article-date">
  <time class="dt-published" datetime="2019-08-27T12:58:17.308Z" itemprop="datePublished">2019-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/27/LTR_retriever_%20%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%8A%A0%E5%87%86%E7%9A%84LTR%E6%95%B4%E5%90%88%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-LTR_retriever-accurate-identification-of-LTR-retrotransposons/">LTR_retriever:一个更加准的LTR整合分析工具</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="背景篇"><a href="#背景篇" class="headerlink" title="背景篇"></a>背景篇</h2><p>在植物基因组中，I类转座因子，LTR-RT(LTR retrotransposons)是基因组扩张的主要原因。完整的LTR长度在85<del>5000 bp之间，下图图A表示的是一个完整的LTR-RT，灰色框表示TSD(target site duplications), 红色三角形表示LTR motif(长度在2bp左右), 蓝色框表示LTR。LTR中间序列长度在1,000</del>15,000之间波动。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-538f429117b6891f-5b3fc254688246a18ebe845bab37279e.png" alt="LTR-RT结构"></p>
<p>完整的LTR-RT主要归为两大类: Gypsy和Copia。如果LTR中间的序列不包含开放阅读框(ORF), 那么所属的LTR-RT就无法独立的转座。</p>
<h2 id="安装篇"><a href="#安装篇" class="headerlink" title="安装篇"></a>安装篇</h2><p><code>LTR_retriever</code>不是一个独立的工具，他的主要作用就是整合 LTRharvest, LTR_FINDER, MGEScan 3.0.0, LTR_STRUC, 和 LtrDetector的结果，过滤其中的假阳性LTR-RT，得到高质量的LTR-RT库。</p>
<p>LTR_retriever托管在GitHub, <a target="_blank" rel="noopener" href="https://github.com/oushujun/LTR_retriever">https://github.com/oushujun/LTR_retriever</a>, 下载<code>LTR_retriever</code>本体</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/oushujun/LTR_retriever.git</span><br></pre></td></tr></table></figure>

<p>之后修改<code>LTR_retriever</code>下的<code>paths</code>, 提供BLAST+, RepeatMasker， HMMER， CDHIT这些工具的路径。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BLAST+=/your_path_to/BLAST+2.2.30/bin/</span><br><span class="line">RepeatMasker=/your_path_to/RepeatMasker4.0.0/</span><br><span class="line">HMMER=/your_path_to/HMMER3.1b2/bin/</span><br><span class="line">CDHIT=/your_path_to/CDHIT4.6.1/</span><br><span class="line">BLAST=/your_path_to/BLAST2.2.26/bin/ <span class="comment">#not required if CDHIT provided</span></span><br></pre></td></tr></table></figure>

<p>更加方便的安装方法用Bioconda安装好cd-hit repeatmasker， 然后下载LTR_retriever:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">conda create -n LTR_retriever</span><br><span class="line"><span class="built_in">source</span> activate LTR_retriever</span><br><span class="line">conda install -c conda-forge perl perl-text-soundex</span><br><span class="line">conda install -c bioconda cd-hit</span><br><span class="line">conda install -c bioconda/label/cf201901 repeatmasker</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/oushujun/LTR_retriever.git</span><br><span class="line">./LTR_retriever/LTR_retriever -h</span><br></pre></td></tr></table></figure>

<p>此外你还需要额外安装<code>LTRharvest</code>, <code>LTR_FINDER</code> 和<code>MGEScan_LTR</code>。</p>
<ul>
<li>LTRharverst: <a target="_blank" rel="noopener" href="http://genometools.org/">http://genometools.org/</a></li>
<li>LTR_FINDER: <a target="_blank" rel="noopener" href="https://github.com/xzhub/LTR_Finder">https://github.com/xzhub/LTR_Finder</a></li>
<li>修改版MGEScan_LTR: <a target="_blank" rel="noopener" href="http://dawgpaws.sourceforge.net/">http://dawgpaws.sourceforge.net/</a></li>
</ul>
<p>由于MGEScan_LTR装起来比我想象中麻烦，所以本文就仅使用LTRharverst和LTR_FINDER</p>
<h2 id="使用篇"><a href="#使用篇" class="headerlink" title="使用篇"></a>使用篇</h2><blockquote>
<p>尽管LTR_retriever支持多个LTR工具的输入，但其实上LTRharverst和LTR_FINDER的结果就已经很不错了。</p>
</blockquote>
<p>以拟南芥的基因组序列为例，分别使用LTRharverst和LTR_FINDER来寻找拟南芥中潜在LTR序列，之后用<code>LTR_retreiver</code>来合并结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#LTRharvest</span></span><br><span class="line">gt suffixerator \</span><br><span class="line">  -db TAIR10.fa \</span><br><span class="line">  -indexname TAIR10 \</span><br><span class="line">  -tis -suf -lcp -des -ssp -sds -dna</span><br><span class="line">gt ltrharvest \</span><br><span class="line">  -index TAIR10 \</span><br><span class="line">  -similar 90 -vic 10 -seed 20 -seqids <span class="built_in">yes</span> \</span><br><span class="line">  -minlenltr 100 -maxlenltr 7000 -mintsd 4 -maxtsd 6 \</span><br><span class="line">  -motif TGCA -motifmis 1  &gt; TAIR10.harvest.scn &amp;</span><br><span class="line"><span class="comment"># LTR_FINDER</span></span><br><span class="line">ltr_finder -D 15000 -d 1000 -L 7000 -l 100 -p 20 -C -M 0.9 TAIR10.fa &gt; TAIR10.finder.scn &amp;</span><br></pre></td></tr></table></figure>

<p><code>LTR_retriever</code>支持单个候选的LTR，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LTR_retriever -genome TAIR10.fa -inharvest TAIR10.harvest.scn</span><br></pre></td></tr></table></figure>

<p>也支持多个候选LTR输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LTR_retriever -genome TAIR10.fa -inharvest TAIR10.harvest.scn -infinder TAIR10.finder.scn -threads 20</span><br></pre></td></tr></table></figure>

<p>输出文件如下</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-37ef5a8181e7e271-2923e29399c34ee4a62f874be8b745e0.png" alt="运行结果"></p>
<h2 id="其他测试"><a href="#其他测试" class="headerlink" title="其他测试"></a>其他测试</h2><p>LAI值是作者提出用于衡量基因组完整度参数。比较2个LTR输入和1个LTR输入的LAI值，后者是15.62，前者是14.47，这也意味这个值其实是受到输入的候选LTR数目影响，但最终结果应该稳定在一个阈值内。</p>
<p>我测试了多个物种在两种软件下找到的LTR，以及最终pass留下的LTR, 发现最终能够pass，数量都相对较少。同时限速步骤就是LTR_finder 和 LTRharvest。</p>
<table>
<thead>
<tr>
<th>物种</th>
<th>基因组大小</th>
<th>LTR_finder</th>
<th>LTRharvest</th>
<th>Pass</th>
<th>LAI</th>
<th>测序技术</th>
</tr>
</thead>
<tbody><tr>
<td>A. lyrata</td>
<td>206M</td>
<td>1456</td>
<td>1017</td>
<td>1044</td>
<td>20.39</td>
<td>Sanger</td>
</tr>
<tr>
<td>A. thaliana (TAIR10)</td>
<td>120 M</td>
<td>207</td>
<td>550</td>
<td>184</td>
<td>15.62</td>
<td>Sanger</td>
</tr>
<tr>
<td>B. rapa (2.5)</td>
<td>391M</td>
<td>1251</td>
<td>3182</td>
<td>520</td>
<td>0</td>
<td>PacBio + 二代20Kb 40Kb文库</td>
</tr>
<tr>
<td>B. rapa (3.0)</td>
<td>353 M</td>
<td>3515</td>
<td>3635</td>
<td>1968</td>
<td>7.16</td>
<td>PacBio + BioNano + Hi-C</td>
</tr>
<tr>
<td>C.rubella</td>
<td>135 M</td>
<td>643</td>
<td>600</td>
<td>144</td>
<td>10.96</td>
<td>454 + Sanger</td>
</tr>
<tr>
<td>A. alpina</td>
<td>336 M</td>
<td>3840</td>
<td>3107</td>
<td>2556</td>
<td>11.01</td>
<td>PacBio + BioNano + Hi-C</td>
</tr>
<tr>
<td>某物种A</td>
<td>454 M</td>
<td>5384</td>
<td>2789</td>
<td>4294</td>
<td>17.89</td>
<td>PacBio</td>
</tr>
</tbody></table>
<p>还有一个有趣的现象，B. rapa 3.0版本尽管是最近用三代加Hi-C组装的基因，但是以LAI的标准，只能算是Draft级别, 当然也比2.5版本好出不少。</p>
<p>当然作者也对很多物种的多个版本组装进行了比较，下图来自于 Assessing genome assembly quality using the LTR Assembly Index (LAI)</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/2013053-48feb2021d9a65e3-f7061838e05b48cab7e47c4db73d3536.png" alt="基因组评估"></p>
<p>如果使用该软件记得引用下面两篇文献</p>
<ul>
<li>LTR_retriever: A Highly Accurate and Sensitive Program for Identification of Long Terminal Repeat Retrotransposons</li>
<li>Assessing genome assembly quality using the LTR Assembly Index (LAI)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/27/LTR_retriever_%20%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%8A%A0%E5%87%86%E7%9A%84LTR%E6%95%B4%E5%90%88%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-LTR_retriever-accurate-identification-of-LTR-retrotransposons/" data-id="clm1z22f2006nehn594or4etl" data-title="LTR_retriever:一个更加准的LTR整合分析工具" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" rel="tag">重复序列</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-HiC-Pro_ Hi-C数据预处理高效工具-hic-pro-an-optimized-and-flexible-pipeline-for-hi-c-data-processing" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/26/HiC-Pro_%20Hi-C%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7-hic-pro-an-optimized-and-flexible-pipeline-for-hi-c-data-processing/" class="article-date">
  <time class="dt-published" datetime="2019-08-26T21:29:00.048Z" itemprop="datePublished">2019-08-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/26/HiC-Pro_%20Hi-C%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7-hic-pro-an-optimized-and-flexible-pipeline-for-hi-c-data-processing/">HiC-Pro:Hi-C数据预处理高效工具</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>HiC-Pro是一个高效率的Hi-C数据预处理工具，能够应用于dilution Hi-C, in situ Hi-C, DNase Hi-C, Micro-C, capture-C, capture Hi-C 和 HiChip 这些数据。</p>
<p>HiC-Pro的工作流程如下, 简单的说就是先双端测序各自比对，然后进行合并，根据合并的结果筛选有效配对。之后有效配对用于构建contact maps.</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/hicpro_wkflow-7cce986ba7d84c05857b509f2beb1c79.png" alt="工作流程"></p>
<h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>HiC-Pro依赖于如下的软件</p>
<ul>
<li>Bowtie2(&gt;2.2.2), 用于序列比对</li>
<li>Python2.7, 并安装 Pysam, bx-python, numpy, scipy</li>
<li>R, <em>RColorBrewer</em>  + <em>ggplot2</em> </li>
<li>samtools &gt; 1.1</li>
<li>GNU sort, 支持 -V， 按照version进行排序</li>
</ul>
<p>如果有root权限，更加推荐使用Singularity，比Conda更简单。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载</span></span><br><span class="line">wget https://zerkalo.curie.fr/partage/HiC-Pro/singularity_images/hicpro_latest_ubuntu.img</span><br><span class="line"><span class="comment"># 使用</span></span><br><span class="line">singularity <span class="built_in">exec</span> /opt/biosoft/HiC-Pro/hicpro_latest_ubuntu.img HiC-Pro -h</span><br></pre></td></tr></table></figure>


<p>没有Root的安装方法: 为了保证环境的干净，我用conda进行了一个环境进行安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">conda create -y -n hic-pro python=2.7 pysam bx-python numpy scipy samtools bowtie2</span><br><span class="line">conda activate hic-pro</span><br></pre></td></tr></table></figure>

<p>以2.11.1版本为例进行介绍，最新的版本在<a target="_blank" rel="noopener" href="https://github.com/nservant/HiC-Pro/releases%E6%A3%80%E6%9F%A5">https://github.com/nservant/HiC-Pro/releases检查</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/nservant/HiC-Pro/archive/v2.11.1.tar.gz</span><br><span class="line">tar -zxvf v2.11.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> HiC-Pro-2.11.1</span><br></pre></td></tr></table></figure>

<p>因为我希望把HiC-Pro安装到<code>~/opt/bisofot</code>下，所以我需要修改当前目录下的<code>config-install.txt</code>中的PREFIX部分，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PREFIX =  /home/xzg/opt/bisofot</span><br></pre></td></tr></table></figure>

<p>如果服务器支持任务投递，可以修改CLUSTER_SYS部分, 设置为TORQUE, SGE, SLURM 或 LSF，</p>
<p>我的miniconda的安装目录是<code>~/miniconda3</code>, 所以hic-pro环境的实际路径是<code>~/miniconda3/envs/hic-pro</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make configure</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>安装结束之后，<code>/home/xzg/opt/bisofot</code>文件夹下就出现了<code>HiC-Pro_2.11.1</code>，之后的软件调用方式为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosfot/HiC-Pro_2.11.1/bin/HiC-Pro -h</span><br></pre></td></tr></table></figure>

<p>如果没有出现Error 就说明安装成功了。</p>
<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><p>让我们新建一个项目文件夹，以一个测试数据集为例进行介绍。</p>
<p>下载测试数据并解压缩，该数据来自于Dixon et al. 2012 ， 使用HindIII 进行酶切</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p hic-pro &amp;&amp; <span class="built_in">cd</span> hic-pro</span><br><span class="line">wget https://zerkalo.curie.fr/partage/HiC-Pro/HiCPro_testdata.tar.gz &amp;&amp; tar -zxvf HiCPro_testdata.tar.gz</span><br></pre></td></tr></table></figure>
<p>之后将测序结果移动或者软连接到fastq文件夹下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p fastq</span><br><span class="line"><span class="built_in">mv</span> test_data/* fastq</span><br><span class="line"><span class="built_in">ls</span> fastq</span><br><span class="line"><span class="comment"># dixon_2M  dixon_2M_2</span></span><br></pre></td></tr></table></figure>

<h3 id="创建注释文件"><a href="#创建注释文件" class="headerlink" title="创建注释文件"></a>创建注释文件</h3><p>为了处理原始数据，HiC-Pro需要三个注释文件</p>
<ul>
<li>BED文件，记录可能的酶切位点</li>
<li>table文件，记录每条contig&#x2F;scaffold&#x2F;chromosome的长度</li>
<li>bowtie2索引</li>
</ul>
<p>其中BED文件和table文件必须要放在<code>HiC-Pro_2.11.1/annotations</code>目录下，该文件夹下已经有了人类hg19和小鼠mm10。 我们以GRCh38为例, 介绍如何创建这三个注释信息 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line"><span class="built_in">cd</span> ~/opt/biosfot/HiC-Pro_2.11.1/annotation</span><br><span class="line"><span class="comment"># 下载GRCh38的序列</span></span><br><span class="line">wget ftp://ftp.ensembl.org/pub/release-97/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.primary_assembly.fa.gz</span><br><span class="line">gunzip Homo_sapiens.GRCh38.dna.primary_assembly.fa.gz</span><br><span class="line"><span class="comment"># BED</span></span><br><span class="line">~/opt/biosoft/HiC-Pro_2.11.1/bin/utils/digest_genome.py -r HindIII  -o GRCh38_HindIII.bed Homo_sapiens.GRCh38.dna.primary_assembly.fa</span><br><span class="line"><span class="comment"># chromosome size</span></span><br><span class="line">seqkit fx2tab -<span class="built_in">nl</span> Homo_sapiens.GRCh38.dna.primary_assembly.fa | awk <span class="string">&#x27;&#123;print $1&quot;\t&quot;$2&#125;&#x27;</span> &gt; GRCh38.chrom.size</span><br><span class="line"><span class="comment"># bowtie2 index</span></span><br><span class="line">bowtie2-build --threads 20 Homo_sapiens.GRCh38.dna.primary_assembly.fa GRCh38</span><br></pre></td></tr></table></figure>

<h3 id="配置HiC-Pro"><a href="#配置HiC-Pro" class="headerlink" title="配置HiC-Pro"></a>配置HiC-Pro</h3><p>拷贝HiC-Pro的配置文件到项目文件夹下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> ~/opt/biosfot/HiC-Pro_2.11.1/config-hicpro.txt .</span><br></pre></td></tr></table></figure>

<p>修改配置文件config-hicpro.txt</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线程数</span></span><br><span class="line">N_CPU = 80</span><br><span class="line"><span class="comment"># bowtie2索引, 绝对路径</span></span><br><span class="line">BOWTIE2_IDX_PATH = /home/xzg/opt/biosfot/HiC-Pro_2.11.1/annotation</span><br><span class="line"><span class="comment"># bowtie2索引时的前缀</span></span><br><span class="line">REFERENCE_GENOME = GRCh38</span><br><span class="line"><span class="comment"># 参考基因组各染色体长度</span></span><br><span class="line"><span class="comment"># 绝对路径</span></span><br><span class="line">GENOME_SIZE = /home/xzg/opt/biosfot/HiC-Pro_2.11.1/annotationGRCh38.chrom.size</span><br><span class="line"><span class="comment"># 酶切位点</span></span><br><span class="line"><span class="comment"># 绝对路径</span></span><br><span class="line">GENOME_FRAGMENT = /home/xzg/opt/biosfot/HiC-Pro_2.11.1/annotationGRCh38_HindIII.bed</span><br><span class="line">LIGATION_SITE = AAGCTAGCTT</span><br></pre></td></tr></table></figure>

<p>对于LIGATION_SITE，不同酶切位点对应的序列为HindIII(AAGCTAGCTT), MboI(GATCGATC) , DpnII(GATCGATC), NcoI(CCATGCATGG)。</p>
<p>我们要修改的参数其实就是上面几个。当然该配置文件还有许多参数可以修改，具体见<a target="_blank" rel="noopener" href="https://github.com/nservant/HiC-Pro/blob/master/doc/MANUAL.md">https://github.com/nservant/HiC-Pro/blob/master/doc/MANUAL.md</a></p>
<p>运行如下代码，启动分析项目</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/HiC-Pro_2.11.1/bin/HiC-Pro -i fastq -o results -c config-hicpro.txt</span><br></pre></td></tr></table></figure>

<p>HiC-Pro会新建一个工作目录，results, 之后会遍历fastq目录，寻找其中的fastq文件，将其软连接到results下的rawdata, 之后就开始用bowtie2比对以及后续的分析。</p>
<blockquote>
<p>测试数据代码运行到<code>Run ICE Normalization</code>就中断了，可能是用的参考基因组和原来的教程(hg19)不一样， 不过我自己的数据集是没有问题的。</p>
</blockquote>
<p>最后的结果如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ tree -L 2 results </span><br><span class="line">results</span><br><span class="line">├── bowtie_results <span class="comment"># 比对之后的输出 </span></span><br><span class="line">│   ├── bwt2</span><br><span class="line">│   ├── bwt2_global</span><br><span class="line">│   └── bwt2_local</span><br><span class="line">├── config-hicpro.txt</span><br><span class="line">├── hic_results</span><br><span class="line">│   ├── data <span class="comment"># 有效配对</span></span><br><span class="line">│   ├── matrix <span class="comment"># contact maps</span></span><br><span class="line">│   ├── pic <span class="comment"># 可视化质控信息</span></span><br><span class="line">│   └── stats <span class="comment">#文字版质控信息</span></span><br><span class="line">├── logs <span class="comment"># 各种日志</span></span><br><span class="line">│   ├── dixon_2M</span><br><span class="line">│   └── dixon_2M_2</span><br><span class="line">├── rawdata -&gt; /home/xzg/project/Tutorial/hic-pro/fastq</span><br><span class="line">└── tmp</span><br></pre></td></tr></table></figure>

<p>一个关键的结果就是data文件里的以*.validPairs*结尾的文件，有7+1列，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read_name chr_reads1  pos_reads1  strand_reads1  chr_reads2  pos_reads2  strand_reads2  fragment_size [allele_specific_tag] </span><br></pre></td></tr></table></figure>

<p>此外，HiC-Pro提供了一个脚本用于将输出的allValidPairs转成<a target="_blank" rel="noopener" href="https://github.com/aidenlab/juicer/wiki/Juicer-Tools-Quick-Start">JABT</a>的输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~/HiC-Pro_2.11.1/bin/utils/hicpro2juicebox.sh \</span><br><span class="line">    -i hic_results/data/dixon_2M/dixon_2M.allValidPairs \</span><br><span class="line">    -g /home/xzg/opt/biosfot/HiC-Pro_2.11.1/annotation/GRCh38.chrom.size \</span><br><span class="line">    -j ~/opt/biosoft/juicer/scripts/common/juicer_tools.jar</span><br></pre></td></tr></table></figure>

<p>最终会输出一个以.hic结尾的文件。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>官方手册: <a target="_blank" rel="noopener" href="https://github.com/nservant/HiC-Pro/blob/master/doc/MANUAL.md">https://github.com/nservant/HiC-Pro/blob/master/doc/MANUAL.md</a></li>
<li>官方帮助文档: <a target="_blank" rel="noopener" href="https://nservant.github.io/HiC-Pro/MANUAL.html">https://nservant.github.io/HiC-Pro/MANUAL.html</a></li>
<li><em>Servant N., Varoquaux N., Lajoie BR., Viara E., Chen CJ., Vert JP., Dekker J., Heard E., Barillot E.</em> HiC-Pro: An optimized and flexible pipeline for Hi-C processing. Genome Biology 2015, 16:259 <a target="_blank" rel="noopener" href="https://doi.org/10.1186/s13059-015-0831-x">doi:10.1186&#x2F;s13059-015-0831-x</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/26/HiC-Pro_%20Hi-C%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E9%AB%98%E6%95%88%E5%B7%A5%E5%85%B7-hic-pro-an-optimized-and-flexible-pipeline-for-hi-c-data-processing/" data-id="clm1z22f0006gehn566p36qam" data-title="HiC-Pro:Hi-C数据预处理高效工具" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Hi-C/" rel="tag">Hi-C</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-「基因组注释」使用RepeatModeler从头注释基因组的重复序列-Repeat-annotation-with-RepeatModeler" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/26/%E3%80%8C%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%B3%A8%E9%87%8A%E3%80%8D%E4%BD%BF%E7%94%A8RepeatModeler%E4%BB%8E%E5%A4%B4%E6%B3%A8%E9%87%8A%E5%9F%BA%E5%9B%A0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97-Repeat-annotation-with-RepeatModeler/" class="article-date">
  <time class="dt-published" datetime="2019-08-26T17:31:51.898Z" itemprop="datePublished">2019-08-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/26/%E3%80%8C%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%B3%A8%E9%87%8A%E3%80%8D%E4%BD%BF%E7%94%A8RepeatModeler%E4%BB%8E%E5%A4%B4%E6%B3%A8%E9%87%8A%E5%9F%BA%E5%9B%A0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97-Repeat-annotation-with-RepeatModeler/">「基因组注释」使用RepeatModeler从头注释基因组的重复序列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>RepeatModeler可用来从头对基因组的重复序列家族进行建模注释，它的核心组件是RECON和RepatScout。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>以拟南芥的参考基因组为例，假设基因组的名字为”Athaliana.fa”</p>
<p>第一步：为RepeatModeler创建索引数据库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BuildDatabase -name ath -engine ncbi Athaliana.fa</span><br><span class="line"><span class="comment"># -engine ncbi： 表示使用rmblast</span></span><br><span class="line"><span class="comment"># -name aht： 表示数据库的名字为ath</span></span><br></pre></td></tr></table></figure>

<p>这一步其实认为调用了<code>makeblastdb</code>，结果文章和<code>makeblastdb</code>一致</p>
<p>第二步：运行RepeatModeler</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RepeatModeler -database ath -engine ncbi -pa 10 &amp;&gt; ath.out &amp;</span><br><span class="line"><span class="comment"># -database 要和上一步一致</span></span><br><span class="line"><span class="comment"># -engine 要和上一步一致</span></span><br><span class="line"><span class="comment"># -pa 表示线程数</span></span><br></pre></td></tr></table></figure>

<p>运行中的的文件存放在<code>RM_.xxx</code>文件夹下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RM_82213.MonOct151054032018</span><br><span class="line">├── consensi.fa </span><br><span class="line">├── consensi.fa.classified</span><br><span class="line">├── consensi.fa.masked</span><br><span class="line">├── families-classified.stk</span><br><span class="line">├── families.stk</span><br><span class="line">├── round-1</span><br><span class="line">├── round-2</span><br><span class="line">├── round-3</span><br><span class="line">├── round-4</span><br><span class="line">└── round-5</span><br></pre></td></tr></table></figure>

<p>运行结束后，就得到了<code>ath-families.fa</code>和<code>ath-families.stk</code>。 前者是找到的重复序列，后者是Stockholm格式的种子联配文件(seed alignment file), 可以用<code>util/dfamConsensusTool.pl</code>上传到<code>Dfam_consensus</code>数据库中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -i Unkown ath-families.fa</span><br><span class="line"><span class="comment"># 没有结果，全都归类，毕竟拟南芥</span></span><br></pre></td></tr></table></figure>

<p><code>RM_.xxx</code>的<code>consensi.fa.classified</code>和<code>ath-families.fa</code>内容一样，也是FASTA格式的文件，，只不过每个序列的ID会标注它来自于哪个重复序列家族，如果无法归类，则用”Unkown”标注。</p>
<p>你可以将<code>ath-families.fa</code>分ModelerID.lib和Modelerunknown.lib, </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">seqkit grep -nrp Unknown ath-families.fa &gt; Modelerunknown.lib</span><br><span class="line">seqkit grep -vnrp Unknown ath-families.fa &gt;  ModelerID.lib</span><br></pre></td></tr></table></figure>

<p>其中Modelerunknown.lib用RepeatMasker或TEclass进一步注释，如果能够被分类则从Modelerunknown.lib,移动到ModelerID.lib</p>
<p>这里用TEclass进行分类，软件安装使用参考<a href="/archives/Classify-TE-consensus-sequence-by-TEclass">使用TEclass对TE一致性序列进行分类</a>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TEclassTest Modelerunknown.lib</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这一步其实无法运行，因为没有输入。</p>
</blockquote>
<p>第三步：过滤基因片段</p>
<blockquote>
<p>许多文章都没有这样子做，因此这一步完全可以不用看</p>
</blockquote>
<p>RepeatModeler找到的重复序列进一步在植物蛋白数据库（不包括转座子蛋白）进行搜索，如果和植物蛋白匹配，或者在序列的侧翼50bp以内，就将该重复序列剔除。这一步可用工具是<code>ProtExcluder</code><br>ProtExcluder的安装需要HMMER3， 方法如下</p>
<p>首先一定要装HMMER3.0，然后安装方法为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wget http://eddylab.org/software/hmmer/hmmer-3.0.tar.gz</span><br><span class="line">tar xf hmmer-3.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> hmmer-3.0</span><br><span class="line">./configure --prefix=<span class="variable">$HOME</span>/opt/biosoft/hmmer-3.0</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="built_in">cd</span> easel</span><br><span class="line">./configure --prefix=<span class="variable">$HOME</span>/opt/biosoft/hmmer-3.0</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>后续安装的ProtExcluder1.1非常坑爹，他居然认为hmmer的运行文件是放在binaries目录下，所以你还需要去<code>~/opt/biosoft/hmmer-3.0</code>把bin文件夹改成binaries</p>
<p>然后安装ProtExcluder1.1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar zxf  ProtExcluder1.1.tar.gz</span><br><span class="line"><span class="built_in">mv</span> ProtExcluder1.1 ~/opt/biosoft</span><br><span class="line"><span class="built_in">cd</span>  ~/opt/biosoft/ProtExcluder1.1 </span><br><span class="line">./Installer.pl   -m   ~/opt/biosoft/hmmer-3.0 -p P ~/opt/biosoft/ProtExcluder1.1/</span><br><span class="line"><span class="comment"># 注意运行路径后一定要有&quot;/&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后将找到的重复序列用blastx比对到植物的蛋白数据库中，你可以到RefSeq上进行下载。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blastx -query ath-families.fa -db /path/to/refseq-plant/db/plant.protein -num_threads 70 &gt; ath-families.blastx &amp;</span><br></pre></td></tr></table></figure>

<p>最后运行ProtExcluder.pl</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/path/to/ProtExcluder.pl -f 50   ath-families.blastx  ath-families.fa </span><br></pre></td></tr></table></figure>

<p>从理论上说结果是”XXXnoProtFinal”，但这个破软件各种报错，而且报错信息信息量太少，直接放弃这个破软件了。</p>
<p>考虑到目前看了很多文献也没人说要过滤，所以这一步就放弃吧</p>
<p>注1： 一般而言RepeatModeler在一周内就能运行完，物种小一点，服务器好一点，基本上一天就行了<br>注2： 一般而言，同源注释所用的重复序列库的数据比较可靠，但不一定全，而我们自己建立的重复序列库比较全，但是未必准。<br>注3： SwissProt的植物蛋白数据库的下载地址为：<a href="ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/taxonomic_divisions">ftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/taxonomic_divisions</a>，而NCBI的Refseq植物蛋白数据库下载地址为<a href="ftp://ftp.ncbi.nih.gov/refseq/release/plant/">ftp://ftp.ncbi.nih.gov/refseq/release/plant/</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/26/%E3%80%8C%E5%9F%BA%E5%9B%A0%E7%BB%84%E6%B3%A8%E9%87%8A%E3%80%8D%E4%BD%BF%E7%94%A8RepeatModeler%E4%BB%8E%E5%A4%B4%E6%B3%A8%E9%87%8A%E5%9F%BA%E5%9B%A0%E7%BB%84%E7%9A%84%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97-Repeat-annotation-with-RepeatModeler/" data-id="clm1z22ja00krehn52ww0fjl5" data-title="「基因组注释」使用RepeatModeler从头注释基因组的重复序列" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" rel="tag">注释 | 重复序列</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-利用3D-DNA流程组装基因组-scaffolding-genome-using-3d-dna-workflow" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/25/%E5%88%A9%E7%94%A83D-DNA%E6%B5%81%E7%A8%8B%E7%BB%84%E8%A3%85%E5%9F%BA%E5%9B%A0%E7%BB%84-scaffolding-genome-using-3d-dna-workflow/" class="article-date">
  <time class="dt-published" datetime="2019-08-25T16:22:03.560Z" itemprop="datePublished">2019-08-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/25/%E5%88%A9%E7%94%A83D-DNA%E6%B5%81%E7%A8%8B%E7%BB%84%E8%A3%85%E5%9F%BA%E5%9B%A0%E7%BB%84-scaffolding-genome-using-3d-dna-workflow/">利用3D-DNA流程组装基因组</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="利用3D-DNA流程组装基因组"><a href="#利用3D-DNA流程组装基因组" class="headerlink" title="利用3D-DNA流程组装基因组"></a>利用3D-DNA流程组装基因组</h1><p>使用二代数据或三代数据得到contig后，下一步就是将contig提升到染色体水平。有很多策略可以做到这一点，比如说遗传图谱，BioNano(看运气), HiC, 参考近源物种。</p>
<p>如果利用HiC进行准染色体水平，那么目前常见的组装软件有下面几个</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/DovetailGenomics/HiRise_July2015_GR">HiRise</a>: 2015年后的GitHub就不再更新</li>
<li><a target="_blank" rel="noopener" href="https://github.com/shendurelab/LACHESIS">LACHESIS</a>: 发表在NBT，2017年后不再更新</li>
<li><a target="_blank" rel="noopener" href="https://github.com/marbl/SALSA">SALSA</a>: 发表在BMC genomics,  仍在更新中</li>
<li><a target="_blank" rel="noopener" href="https://github.com/theaidenlab/3d-dna">3D-DNA</a>: 发表在science，仍在更新中</li>
<li><a target="_blank" rel="noopener" href="https://github.com/tangerzhang/ALLHiC">ALLHiC</a>: 发表在Nature Plants, 用于解决植物多倍体组装问题</li>
</ul>
<p>对于<strong>二倍体</strong>物种而言，目前3D-DNA应该是组装效果最好的一个软件。</p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>使用3D-DNA做基因组组装的整体流程如下图，分别为组装，Juicer分析Hi-C数据，3D-DNA进行scaffolding，使用JBAT对组装结果进行手工纠正，最终得到准染色体水平的基因组。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/3d-dna-pipeline-86ffcd937b294ec8834c704d90bc149b.png" alt="总体流程"></p>
<p>基因组组装可以是二代测序方法，也可以是三代测序组装方法，总之会得到contig。</p>
<p>Juicer的工作流程见下图，输入原始的fastq文件，处理得到中间文件.hic, 之后对.hic文件用于下游分析，包括</p>
<ul>
<li>Arrowhead: 寻找存在关联的区域</li>
<li>HiCCUPS: 分析局部富集peaks</li>
<li>MotifFinder: 用于锚定peaks</li>
<li>Persons: 计算观测&#x2F;期望的皮尔森相关系数矩阵</li>
<li>Eigenvector: 确定分隔</li>
</ul>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/juicer-workflow-28cf57888a514546b1666cc5c101af00.png" alt="juicer工作流程"></p>
<p>之后Juicer的输出结果给3D-DNA，分析流程见下图。3D-DNA先根据Hi-C数据分析contig中的misjoin，对其进行纠错。之后通过四步,分别是Polish, Split, Seal和Merge, 得到最终的基因组序列</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/3d-dna-pipeline-2-4f9ac6cd65b44dcb86e967e3f407da08.png" alt="3d-dna流程"></p>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><p>在安装之前，确保服务器上有了下面这些依赖软件工具</p>
<ul>
<li>LastZ（仅在杂合基因组的二倍体模式下使用）</li>
<li>Java &gt;&#x3D; 1.7</li>
<li>GNU Awk &gt;&#x3D; 4.02</li>
<li>GNU coreutils sort &gt; 8.11</li>
<li>Python &gt;&#x3D; 2.7</li>
<li>scipy, numpy, matplotlib</li>
<li>GNU Parallel &gt;&#x3D;20150322 (不必要，但是强力推荐)</li>
<li>bwa</li>
</ul>
<p>我们需要安装两个软件，一个是3D-DNA，另一个是juicer。</p>
<p>CPU版本的juicer安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/opt/biosoft/</span><br><span class="line"><span class="built_in">cd</span> ~/opt/biosoft</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theaidenlab/juicer.git</span><br><span class="line"><span class="built_in">cd</span> juicer</span><br><span class="line"><span class="built_in">ln</span> -s CPU scripts</span><br><span class="line"><span class="built_in">cd</span> scripts/common</span><br><span class="line">wget https://hicfiles.tc4ga.com/public/juicer/juicer_tools.1.9.9_jcuda.0.8.jar</span><br><span class="line"><span class="built_in">ln</span> -s juicer_tools.1.9.9_jcuda.0.8.jar  juicer_tools.jar</span><br></pre></td></tr></table></figure>

<p>然后用<code>~/opt/biosoft/juicer/scripts/juicer.sh -h</code>检查是否有帮助信息输出</p>
<p>3D-DNA安装也很容易，只需要从Github上将内容克隆到本地即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/opt/biosoft</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theaidenlab/3d-dna.git</span><br></pre></td></tr></table></figure>

<p>用<code>sh ~/opt/biosoft/3d-dna/run-asm-pipeline.sh -h</code>查看是否有帮助文档输出。</p>
<h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><p>以CPU版本的为例，juicer.sh的参数如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage: juicer.sh [-g genomeID] [-d topDir] [-s site] [-a about] [-R end]</span><br><span class="line">                 [-S stage] [-p chrom.sizes path] [-y restriction site file]</span><br><span class="line">                 [-z reference genome file] [-D Juicer scripts directory]</span><br><span class="line">                 [-b ligation] [-t threads] [-r] [-h] [-f] [-j] </span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<ul>
<li><code>-g</code>: 定义一个物种名</li>
<li><code>-s</code>: 酶切类型, HindIII(AAGCTAGCTT),  MboI(GATCGATC) , DpnII(GATCGATC),  NcoI(CCATGCATGG)</li>
<li><code>-z</code> : 参考基因组文件</li>
<li><code>-y</code>: 限制性酶切位点可能出现位置文件</li>
<li><code>-p</code>: 染色体大小文件</li>
<li><code>-C</code>: 将原来的文件进行拆分，必须是4的倍数，默认是90000000, 即22.5M reads</li>
<li><code>-S</code>: 和任务重运行有关，从中途的某一步开始,”merge”, “dedup”, “final”, “postproc” 或 “early”</li>
<li><code>-D</code>: juicer的目录，我们安装在<code>~/opt/biosoft/</code>，所以设置为<code>~/opt/biosoft/juicer</code></li>
<li><code>-a</code>: 实验的描述说明，可以不用设置</li>
<li><code>-t</code>: 线程数</li>
</ul>
<p><code>juicer.sh</code>还有AWS, LSF, PBS, SLURM版本，由于我的服务器是单主机，无法进行测试讲解。</p>
<p>如果你的基因组不是复杂基因组，比如说高杂合，高重复序列，或者Hi-C数据测太少，那么3d-dna的流程更加简单, <code>run-asm-pipeline.sh -h</code>只有四个参数需要改</p>
<ul>
<li><code>-i|--input</code>: 过滤长度低于给定阈值的contig&#x2F;scaffold, 默认是15000</li>
<li><code>-r|--round</code>: 基因组中misjoin的纠错轮数，默认是2，当基因组比较准确时，设置为0，然后在JABT中调整会更好</li>
<li><code>-m|--mode</code>: 是否调用merge模块，当且仅当在杂合度比较高的情况下使用，也就是组装的单倍型基因组明显偏大</li>
<li><code>-s|--stage</code>:  从polish, split, seal, merge 或finalize 的某一个阶段开始</li>
</ul>
<p>但是，一旦基因组复杂起来，那么需要调整的参数就非常多了, <code>run-asm-pipeline.sh --help</code>会输出更多的信息，你需要根据当前结果去确定每个阶段的参数应该如何调整。</p>
<p>最终的输出文件最关键的是下面三类:</p>
<ul>
<li><code>.fasta</code>: 以FINAL标记的是最终结果</li>
<li><code>.hic</code>: 各个阶段都会有输出结果，用于在JABT中展示</li>
<li><code>.assembly</code>: 各个阶段都会有输出，一共两列，存放contig的组装顺序</li>
</ul>
<h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>假如你现在目录下有2个文件夹，reference</p>
<ul>
<li>reference: 存放一个genome.fa, 为组装的contigs</li>
<li>fastq: 存放HiC二代双端测序结果，read_R1_fastq.gz, read_R2_fastq.gz</li>
</ul>
<blockquote>
<p>注意，genome.fa中的序列一定得是80个字符分隔的情况，也就是多行FASTA。</p>
</blockquote>
<h3 id="增加一个新的基因组"><a href="#增加一个新的基因组" class="headerlink" title="增加一个新的基因组"></a>增加一个新的基因组</h3><p><strong>第一步</strong>： 为基因组建立BWA索引</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> reference</span><br><span class="line">bwa index genome.fa</span><br></pre></td></tr></table></figure>

<p><strong>第二步</strong>: 根据基因组构建创建可能的酶切位点文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python ~/opt/biosoft/juicer/misc/generate_site_positions.py DpnII genome genome.fa</span><br></pre></td></tr></table></figure>

<p><strong>第三步</strong>: 运行如下命令, 获取每条contig的长度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN&#123;OFS=&quot;\t&quot;&#125;&#123;print $1, $NF&#125;&#x27;</span> genome_DpnII.txt &gt; genome.chrom.size</span><br><span class="line"><span class="comment"># 返回上级目录</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure>

<h3 id="运行juicer"><a href="#运行juicer" class="headerlink" title="运行juicer"></a>运行juicer</h3><p>保证当前目录下有fastq和reference文件夹，然后运行如下命令，一定要设置<code>-z</code>,<code>-p</code>,<code>-y</code>这三个参数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/juicer/scripts/juicer.sh \</span><br><span class="line">	-g genome \</span><br><span class="line">	-s MboI \</span><br><span class="line">	-z reference/genome.fa \</span><br><span class="line">	-y reference/genome_DpnII.txt \</span><br><span class="line">	-p reference/genome.chrom.size \</span><br><span class="line">	-D ~/opt/biosoft/juicer \</span><br><span class="line">	-t 40 &amp;&gt; juicer.log &amp;</span><br></pre></td></tr></table></figure>

<p>你可能会好奇为啥这里出现两个酶，DpnII和MboI。这是因为DpnI, DpnII, MboI, Sau3AI, 识别相同的序列，GATC，仅仅是对甲基化敏感度不同。</p>
<p>输出的结果文件都在aligned目录下，其中”merged_nodups.txt”就是下一步3D-DNA的输入文件之一</p>
<h3 id="运行3d-dna"><a href="#运行3d-dna" class="headerlink" title="运行3d-dna"></a>运行3d-dna</h3><p>3d-dna的运行也没有多少参数可以调整，如果对组装的信心高，就用<code>-r 0</code>, 否则用默认的<code>-r 2</code>就行了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/3d-dna/run-asm-pipeline.sh -r 2 reference/genome.fa aligned/merged_nodups.txt &amp;&gt; 3d.<span class="built_in">log</span> &amp;</span><br></pre></td></tr></table></figure>

<p>然后在<a target="_blank" rel="noopener" href="https://github.com/aidenlab/juicer/wiki/Juicer-Tools-Quick-Start">Juicer-Tools</a>中对结果进行可视化，对可能的错误进行纠正</p>
<p>最后输出文件中，包含FINAL就是我们需要的结果。</p>
<h3 id="使用juicerbox进行手工纠错"><a href="#使用juicerbox进行手工纠错" class="headerlink" title="使用juicerbox进行手工纠错"></a>使用juicerbox进行手工纠错</h3><p>关于juicerbox的用法，我已经将原视频搬运到哔哩哔哩, 见<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av65134634">https://www.bilibili.com/video/av65134634</a></p>
<p>最常见的几种组装错误:</p>
<ul>
<li>misjoin: 切割</li>
<li>translocations: 移动</li>
<li>inversions:  翻转</li>
<li>chromosome boundaries: 确定染色体的边界</li>
</ul>
<p>这些错误的判断依赖于经验，所以只能靠自己多试试了。</p>
<p>最后输出genome.review.assembly用于下一步的分析</p>
<h3 id="再次运行3d-dna"><a href="#再次运行3d-dna" class="headerlink" title="再次运行3d-dna"></a>再次运行3d-dna</h3><p>根据JABT手工纠正的结果, genome.review.assembly, 使用<code>run-asm-pipeline-post-review.sh</code>重新组装基因组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~/opt/biosoft/3d-dna/run-asm-pipeline-post-review.sh \</span><br><span class="line">    -r genome.review.assembly genome.fa aligned/merged_nodups.txt &amp;&gt; 3d.<span class="built_in">log</span> &amp;</span><br></pre></td></tr></table></figure>

<h2 id="个人使用评价"><a href="#个人使用评价" class="headerlink" title="个人使用评价"></a>个人使用评价</h2><p>juicer的代码个人感觉不是特别的好，至少以下几个地方都需要改，</p>
<ul>
<li>临时文件不会去及时删除</li>
<li>bwa得到的SAM文件处理方式有待优化，使用BAM能更快的并行计算</li>
<li>参数命令的判断很差，用-z判断字符串是否为0，而不是用-f或-d去判断文件是否存在，这个我已经提了一个issue，希望能改吧</li>
<li>Linux的sort支持多线程，但是没看到用</li>
<li>脚本中有些限速步骤的awk代码，不知道什么时候能改成更高效的处理</li>
</ul>
<p>前两条导致了运行过程中要占用大量的硬盘，所以不准备2T左右的硬盘，很容易出错。第三条是一些报错不会及时停止运算，也不容易排查。估计公司从效率角度出发，应该是写了很多脚本来替换原来的awk脚本了</p>
<p>另外，juicer在多倍体物种上表现很差，建议使用ALLHiC</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/theaidenlab/3d-dna">https://github.com/theaidenlab/3d-dna</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/aidenlab/juicer">https://github.com/aidenlab/juicer</a></li>
<li><a target="_blank" rel="noopener" href="http://aidenlab.org/assembly/manual_180322.pdf">http://aidenlab.org/assembly/manual_180322.pdf</a></li>
<li><a target="_blank" rel="noopener" href="https://www.neb.com/faqs/0001/01/01/what-s-the-difference-between-dpni-dpnii-mboi-and-sau3ai">https://www.neb.com/faqs/0001/01/01/what-s-the-difference-between-dpni-dpnii-mboi-and-sau3ai</a></li>
</ul>
<p>假如你不小心设置了错误的<code>-p</code>参数，也不是特别的要紧，因为之后在最后阶段（final） 才会遇到了下面这个报错</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Could not find chromosome sizes file <span class="keyword">for</span>: reference/genome.chrom.size</span><br><span class="line">***! Can<span class="string">&#x27;t find inter.hic in aligned/inter_30.hic</span></span><br><span class="line"><span class="string">***! Error! Either inter.hic or inter_30.hic were not created</span></span><br><span class="line"><span class="string">Either inter.hic or inter_30.hic were not created. Check aligned for results</span></span><br></pre></td></tr></table></figure>

<p>即便遇到了这个报错也不要紧，因为inter.hic 和 inter_30.hic在3d-dna流程中用不到，所以不需要解决。</p>
<p>如果需要解决的话，有两个解决方案，一种重新运行命令，只不过多加一个参数<code>-S final</code>, 就会跳过之前的比对，合并和去重步骤，直接到后面STATISTICS环节。但是这样依旧会有一些不必要的计算工作，所以另一种方法就是运行原脚本必要的代码</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">juiceDir=~/opt/biosoft/juicer</span><br><span class="line">outputdir=aligned</span><br><span class="line">genomePath=reference/genome.chrom.size</span><br><span class="line">site_file=reference/genome_DpnII.txt</span><br><span class="line">ligation=GATCGATC</span><br><span class="line"><span class="comment"># output is inter.hic</span></span><br><span class="line"><span class="variable">$&#123;juiceDir&#125;</span>/scripts/common/juicer_tools pre -f <span class="variable">$site_file</span> -s <span class="variable">$outputdir</span>/inter.txt -g <span class="variable">$outputdir</span>/inter_hists.m -q 1 <span class="variable">$outputdir</span>/merged_nodups.txt <span class="variable">$outputdir</span>/inter.hic <span class="variable">$genomePath</span> </span><br><span class="line"><span class="comment"># output is inter_30.txt</span></span><br><span class="line"><span class="variable">$&#123;juiceDir&#125;</span>/scripts/common/statistics.pl -s <span class="variable">$site_file</span> -l <span class="variable">$ligation</span> -o <span class="variable">$outputdir</span>/inter_30.txt -q 30 <span class="variable">$outputdir</span>/merged_nodups.txt</span><br><span class="line"><span class="comment"># output is inter_30.hic</span></span><br><span class="line"><span class="variable">$&#123;juiceDir&#125;</span>/scripts/common/juicer_tools pre -f <span class="variable">$site_file</span> -s <span class="variable">$outputdir</span>/inter_30.txt -g <span class="variable">$outputdir</span>/inter_30_hists.m -q 30 <span class="variable">$outputdir</span>/merged_nodups.txt <span class="variable">$outputdir</span>/inter_30.hic <span class="variable">$genomePath</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/25/%E5%88%A9%E7%94%A83D-DNA%E6%B5%81%E7%A8%8B%E7%BB%84%E8%A3%85%E5%9F%BA%E5%9B%A0%E7%BB%84-scaffolding-genome-using-3d-dna-workflow/" data-id="clm1z22gm00cpehn5gi0i9hok" data-title="利用3D-DNA流程组装基因组" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%84%E8%A3%85-Hi-C/" rel="tag">组装 | Hi-C</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-样本足够多时别用DESeq2，用非参数检验都行-DESeq2-vs-wilcox-in-DE-analysis" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/25/%E6%A0%B7%E6%9C%AC%E8%B6%B3%E5%A4%9F%E5%A4%9A%E6%97%B6%E5%88%AB%E7%94%A8DESeq2%EF%BC%8C%E7%94%A8%E9%9D%9E%E5%8F%82%E6%95%B0%E6%A3%80%E9%AA%8C%E9%83%BD%E8%A1%8C-DESeq2-vs-wilcox-in-DE-analysis/" class="article-date">
  <time class="dt-published" datetime="2019-08-25T14:00:16.175Z" itemprop="datePublished">2019-08-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/R/">R</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/25/%E6%A0%B7%E6%9C%AC%E8%B6%B3%E5%A4%9F%E5%A4%9A%E6%97%B6%E5%88%AB%E7%94%A8DESeq2%EF%BC%8C%E7%94%A8%E9%9D%9E%E5%8F%82%E6%95%B0%E6%A3%80%E9%AA%8C%E9%83%BD%E8%A1%8C-DESeq2-vs-wilcox-in-DE-analysis/">样本足够多时别用DESeq2，用非参数检验都行</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>果子老师做过一个非常惊人的举动，用DESeq2处理1225例样本的TCGA数据，在没有使用<code>DESeq</code>多线程参数<code>parallel</code>的情况下，跑了将近40个小时。</p>
<p>那么问题来了，在那么大的样本量的情况下，应该用DESeq2进行数据处理吗？我的结论是不应该，DESeq2的适用场景是小样本的差异表分析，降低假阳性。当你的样本量足够多的时候，我们其实有更好的选择。</p>
<p>这里以果子老师的数据为例，来对比DESeq2的结果和我的分析结果进行比较.</p>
<p>加载DESeq2结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">load(file=<span class="string">&quot;dds_very_long.Rdata&quot;</span>)</span><br><span class="line">library(DESeq2)</span><br><span class="line">deseq2_result &lt;- results(dds)</span><br><span class="line">table(deseq2_result$padj &lt; <span class="number">0.01</span>)</span><br><span class="line"><span class="comment"># FALSE  TRUE </span></span><br><span class="line"><span class="comment"># 23997 25072</span></span><br></pre></td></tr></table></figure>

<p>下面我分析时的数据预处理 部分，</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">options<span class="punctuation">(</span>stringsAsFactors <span class="operator">=</span> <span class="literal">FALSE</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">load<span class="punctuation">(</span>file <span class="operator">=</span> <span class="string">&quot;BRCA_RNASEQ_exprdf.Rdata&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取表达量矩阵</span></span><br><span class="line">expr_mt <span class="operator">&lt;-</span> as.matrix<span class="punctuation">(</span>expr_df<span class="punctuation">[</span><span class="punctuation">,</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">row.names<span class="punctuation">(</span>expr_mt<span class="punctuation">)</span> <span class="operator">&lt;-</span> expr_df<span class="operator">$</span>gene_id</span><br><span class="line">colnames<span class="punctuation">(</span>expr_mt<span class="punctuation">)</span> <span class="operator">&lt;-</span> colnames<span class="punctuation">(</span>expr_df<span class="punctuation">)</span><span class="punctuation">[</span><span class="operator">-</span><span class="number">1</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据文库大小标准化</span></span><br><span class="line">expr_mt <span class="operator">&lt;-</span> expr_mt <span class="operator">/</span> <span class="built_in">rep</span><span class="punctuation">(</span>colSums<span class="punctuation">(</span>expr_mt<span class="punctuation">)</span><span class="punctuation">,</span> each<span class="operator">=</span>nrow<span class="punctuation">(</span>expr_mt<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">*</span> <span class="number">1e6</span></span><br><span class="line"><span class="comment"># 过滤地表达基因</span></span><br><span class="line">expr_mt <span class="operator">&lt;-</span> expr_mt<span class="punctuation">[</span>rowSums<span class="punctuation">(</span>expr_mt <span class="operator">&gt;</span> <span class="number">0</span><span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="punctuation">(</span>ncol<span class="punctuation">(</span>expr_mt<span class="punctuation">)</span> <span class="operator">/</span> <span class="number">3</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计癌症和癌旁</span></span><br><span class="line">TCGA_id <span class="operator">&lt;-</span> colnames<span class="punctuation">(</span>expr_mt<span class="punctuation">)</span></span><br><span class="line">table<span class="punctuation">(</span>substring<span class="punctuation">(</span>TCGA_id<span class="punctuation">,</span><span class="number">14</span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">### 我们发现了7个转移的样本，本次分析，我们关注的是癌症和癌旁，先把转移的样本去掉</span></span><br><span class="line"><span class="comment">### 原发和转移的对比作为家庭作业</span></span><br><span class="line"></span><br><span class="line">TCGA_id <span class="operator">&lt;-</span> TCGA_id<span class="punctuation">[</span>substring<span class="punctuation">(</span>TCGA_id<span class="punctuation">,</span><span class="number">14</span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">)</span><span class="operator">!=</span><span class="string">&quot;06&quot;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 创建metadata</span></span><br><span class="line">sample <span class="operator">&lt;-</span> ifelse<span class="punctuation">(</span>substring<span class="punctuation">(</span>TCGA_id<span class="punctuation">,</span><span class="number">14</span><span class="punctuation">,</span><span class="number">15</span><span class="punctuation">)</span><span class="operator">==</span><span class="string">&quot;01&quot;</span><span class="punctuation">,</span><span class="string">&quot;cancer&quot;</span><span class="punctuation">,</span><span class="string">&quot;normal&quot;</span><span class="punctuation">)</span></span><br><span class="line">sample <span class="operator">&lt;-</span> factor<span class="punctuation">(</span>sample<span class="punctuation">,</span>levels <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;normal&quot;</span><span class="punctuation">,</span><span class="string">&quot;cancer&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span>ordered <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">)</span></span><br><span class="line">metadata <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>TCGA_id<span class="punctuation">,</span>sample<span class="punctuation">)</span> </span><br></pre></td></tr></table></figure>

<p>下一步，利用非参数检验方法， wilcox.test，关于非参数检验的缘起可以看「女士品茶」的第16章摆脱参数</p>
<blockquote>
<p>威尔科克森注释着计算t检验和方法分析的公式，意识到这些不同寻常的极端数值会对结果产生极大的影响，导致“学生”的t检验偏小。 … 如果异常值体现了某种因素对系统数据的系统性污染，那么使用非参数方法只会让事情变得更糟。</p>
</blockquote>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># wilcox.test差异分析 ---------------------------------------------------------</span></span><br><span class="line">cancer_sample <span class="operator">&lt;-</span> metadata<span class="punctuation">[</span>metadata<span class="operator">$</span>sample <span class="operator">==</span> <span class="string">&quot;cancer&quot;</span><span class="punctuation">,</span> <span class="string">&quot;TCGA_id&quot;</span><span class="punctuation">]</span></span><br><span class="line">normal_sample <span class="operator">&lt;-</span> metadata<span class="punctuation">[</span>metadata<span class="operator">$</span>sample <span class="operator">==</span> <span class="string">&quot;normal&quot;</span><span class="punctuation">,</span> <span class="string">&quot;TCGA_id&quot;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">cancer_mt <span class="operator">&lt;-</span> expr_mt<span class="punctuation">[</span><span class="punctuation">,</span>colnames<span class="punctuation">(</span>expr_mt<span class="punctuation">)</span> <span class="operator">%in%</span> cancer_sample <span class="punctuation">]</span></span><br><span class="line">normal_mt <span class="operator">&lt;-</span> expr_mt<span class="punctuation">[</span><span class="punctuation">,</span>colnames<span class="punctuation">(</span>expr_mt<span class="punctuation">)</span> <span class="operator">%in%</span> normal_sample <span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算logFoldChanges</span></span><br><span class="line">logFC <span class="operator">&lt;-</span> log2<span class="punctuation">(</span>rowMeans<span class="punctuation">(</span>as.matrix<span class="punctuation">(</span>cancer_df<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">/</span> rowMeans<span class="punctuation">(</span>as.matrix<span class="punctuation">(</span>normal_df<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">library<span class="punctuation">(</span>future.apply<span class="punctuation">)</span></span><br><span class="line">plan<span class="punctuation">(</span>multiprocess<span class="punctuation">)</span></span><br><span class="line">p_values <span class="operator">&lt;-</span> future_lapply<span class="punctuation">(</span>seq<span class="punctuation">(</span>nrow<span class="punctuation">(</span>cancer_df<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="keyword">function</span><span class="punctuation">(</span>x<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  res <span class="operator">&lt;-</span> wilcox.test<span class="punctuation">(</span>x <span class="operator">=</span> cancer_mt<span class="punctuation">[</span>x<span class="punctuation">,</span><span class="punctuation">]</span><span class="punctuation">,</span> y <span class="operator">=</span>  normal_mt<span class="punctuation">[</span>x<span class="punctuation">,</span><span class="punctuation">]</span><span class="punctuation">)</span></span><br><span class="line">  res<span class="operator">$</span>p.value</span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">p <span class="operator">&lt;-</span> unlist<span class="punctuation">(</span>p_values<span class="punctuation">)</span></span><br><span class="line">p.adj <span class="operator">&lt;-</span> p.adjust<span class="punctuation">(</span>p<span class="punctuation">,</span> method <span class="operator">=</span> <span class="string">&quot;fdr&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">table<span class="punctuation">(</span>p.adj <span class="operator">&lt;</span> <span class="number">0.01</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># FALSE  TRUE </span></span><br><span class="line"><span class="comment"># 10997 24030</span></span><br></pre></td></tr></table></figure>

<p>我们得到了24,030个校正后p值小于0.01的基因，而DESeq2是25,072个。如果比较全部的基因的话，韦恩图上可以发现，绝大部分基因都是相同的。</p>
<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/compare_total-e4635c9e41a94c169d51af5a4ae35810.png" alt="总体比较"></p>
<p>但是通常情况下，我们会更去关注一些变化比较大且p值显著的基因，用这些基因去做下游的富集分析。所以，下一步就是看看后面富集分析结果两者有什么区别。</p>
<p>我们用Y叔的clusterProfiler，去分析倍数变化4倍，矫正p值小于0.01的基因</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提取基因</span></span><br><span class="line">library<span class="punctuation">(</span>clusterProfiler<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>org.Hs.eg.db<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">org <span class="operator">&lt;-</span> org.Hs.eg.db</span><br><span class="line">diffgene1 <span class="operator">&lt;-</span> row.names<span class="punctuation">(</span>expr_mt<span class="punctuation">)</span><span class="punctuation">[</span>p.adj <span class="operator">&lt;</span> <span class="number">0.01</span> <span class="operator">&amp;</span> <span class="built_in">abs</span><span class="punctuation">(</span>logFC<span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">diffgene1 <span class="operator">&lt;-</span> substr<span class="punctuation">(</span>diffgene1<span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">15</span><span class="punctuation">)</span></span><br><span class="line">diffgene2 <span class="operator">&lt;-</span> row.names<span class="punctuation">(</span>deseq2_result<span class="punctuation">)</span><span class="punctuation">[</span>deseq2_result<span class="operator">$</span>padj <span class="operator">&lt;</span> <span class="number">0.01</span> <span class="operator">&amp;</span> </span><br><span class="line">                                           <span class="operator">!</span> <span class="built_in">is.na</span><span class="punctuation">(</span>deseq2_result<span class="operator">$</span>padj<span class="punctuation">)</span> <span class="operator">&amp;</span></span><br><span class="line">                                           <span class="built_in">abs</span><span class="punctuation">(</span>deseq2_result<span class="operator">$</span>log2FoldChange<span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">diffgene2 <span class="operator">&lt;-</span> substr<span class="punctuation">(</span>diffgene2<span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">15</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p>GO富集分析</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>clusterProfiler<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>org.Hs.eg.db<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">org <span class="operator">&lt;-</span> org.Hs.eg.db</span><br><span class="line">diffgene1 <span class="operator">&lt;-</span> row.names<span class="punctuation">(</span>expr_mt<span class="punctuation">)</span><span class="punctuation">[</span>p.adj <span class="operator">&lt;</span> <span class="number">0.01</span> <span class="operator">&amp;</span> <span class="built_in">abs</span><span class="punctuation">(</span>logFC<span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">diffgene1 <span class="operator">&lt;-</span> substr<span class="punctuation">(</span>diffgene1<span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">15</span><span class="punctuation">)</span></span><br><span class="line">diffgene2 <span class="operator">&lt;-</span> row.names<span class="punctuation">(</span>deseq2_result<span class="punctuation">)</span><span class="punctuation">[</span>deseq2_result<span class="operator">$</span>padj <span class="operator">&lt;</span> <span class="number">0.01</span> <span class="operator">&amp;</span> </span><br><span class="line">                                           <span class="operator">!</span> <span class="built_in">is.na</span><span class="punctuation">(</span>deseq2_result<span class="operator">$</span>padj<span class="punctuation">)</span> <span class="operator">&amp;</span></span><br><span class="line">                                           <span class="built_in">abs</span><span class="punctuation">(</span>deseq2_result<span class="operator">$</span>log2FoldChange<span class="punctuation">)</span> <span class="operator">&gt;</span> <span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">diffgene2 <span class="operator">&lt;-</span> substr<span class="punctuation">(</span>diffgene2<span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">,</span> <span class="number">15</span><span class="punctuation">)</span></span><br><span class="line">ego1 <span class="operator">&lt;-</span> enrichGO<span class="punctuation">(</span>diffgene1<span class="punctuation">,</span> </span><br><span class="line">                 OrgDb <span class="operator">=</span> org<span class="punctuation">,</span></span><br><span class="line">                 keyType <span class="operator">=</span> <span class="string">&quot;ENSEMBL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                 ont <span class="operator">=</span> <span class="string">&quot;BP&quot;</span></span><br><span class="line">                 <span class="punctuation">)</span></span><br><span class="line">ego2 <span class="operator">&lt;-</span> enrichGO<span class="punctuation">(</span>diffgene2<span class="punctuation">,</span> </span><br><span class="line">                 OrgDb <span class="operator">=</span> org<span class="punctuation">,</span></span><br><span class="line">                 keyType <span class="operator">=</span> <span class="string">&quot;ENSEMBL&quot;</span><span class="punctuation">,</span></span><br><span class="line">                 ont <span class="operator">=</span> <span class="string">&quot;BP&quot;</span></span><br><span class="line"><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line">merge_result <span class="operator">&lt;-</span> merge_result<span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span>wilcox<span class="operator">=</span>ego1<span class="punctuation">,</span>DESeq2<span class="operator">=</span>ego2<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">dotplot<span class="punctuation">(</span>merge_result<span class="punctuation">,</span>showCategory<span class="operator">=</span> <span class="number">20</span> <span class="punctuation">)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://halo-1252249331.cos.ap-shanghai.myqcloud.com/upload/2019/8/compare_dotplot-916bf6b3815d45b288e3a5e3459bf62e.png" alt="比较20个GO词条"></p>
<p>从点图中，你可以认为这两个分析结果是一致。</p>
<p>综上，当你在样本量足够多（两组都不少于10吧），其实没有去用DESeq2这些复杂的工具，用基础的统计学检验方法就能得到很好的结果了。</p>
<p>在样本量比较小的时候，用复杂的模型是无奈之举，它有很多假设成分在，尤其是你还想从无重复的实验设计中算p值。当你样本量够多的时候，用最简单的模型其实就会有很好的结果。</p>
<blockquote>
<p>本次分析用到的数据可以通过在微信公众号搜索 果子学生信 后台回复 “果子学统计” ，就可以拿到了</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/25/%E6%A0%B7%E6%9C%AC%E8%B6%B3%E5%A4%9F%E5%A4%9A%E6%97%B6%E5%88%AB%E7%94%A8DESeq2%EF%BC%8C%E7%94%A8%E9%9D%9E%E5%8F%82%E6%95%B0%E6%A3%80%E9%AA%8C%E9%83%BD%E8%A1%8C-DESeq2-vs-wilcox-in-DE-analysis/" data-id="clm1z22if00i1ehn57n6q40dj" data-title="样本足够多时别用DESeq2，用非参数检验都行" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90-TCGA/" rel="tag">转录组 | 差异分析 | TCGA</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-如何安装perl模块-How-to-install-perl-module" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/08/23/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85perl%E6%A8%A1%E5%9D%97-How-to-install-perl-module/" class="article-date">
  <time class="dt-published" datetime="2019-08-23T12:57:37.759Z" itemprop="datePublished">2019-08-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux/">Linux</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/08/23/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85perl%E6%A8%A1%E5%9D%97-How-to-install-perl-module/">如何安装perl模块</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>由于生物信息早期最多用的语言是perl，因此不可避免就要用别人的perl脚本或者基于perl的项目来处理数据。</p>
<p>使用perl脚本和使用其他编程语言的脚本没啥不同，毕竟你只要传入参数，它就能给你结果。因此对于我们这些不用perl写脚本，只需要调用的人而言，唯一要学会的事情就是**如何安装perl的模块”。</p>
<p>关于perl模块安装，最古老的方法就是使用<code>perl -MCPAN -e shell</code>或者是<code>cpan</code>（两者等价），这也是我最先接触的方法，这里介绍如何使用<code>local::lib</code>和<code>cpanm</code>实现非root权限安装perl模块。</p>
<h2 id="使用系统自带的perl"><a href="#使用系统自带的perl" class="headerlink" title="使用系统自带的perl"></a>使用系统自带的perl</h2><p>安装任何软件最怕遇到的问题就是权限问题，因此我们需要先安装<code>local::lib</code>，使得我们能够将perl模块安装到任何地方，简单的说就是安装到我们的家目录下</p>
<p>第一步，下载源代码进行编译安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://cpan.metacpan.org/authors/id/H/HA/HAARG/local-lib-2.000024.tar.gz</span><br><span class="line">tar xf local-lib-2.000024.tar.gz</span><br><span class="line"><span class="built_in">cd</span> local-lib-2.000024</span><br><span class="line">perl Makefile.PL --bootstrap=~/opt</span><br><span class="line">make <span class="built_in">test</span> &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>第二步：<strong>设置环境变量</strong>，使得perl在安装模块的时候会优先使用我们指定的路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(perl -I$HOME/opt/lib/perl5 -Mlocal::lib=$HOME/opt)&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>先用<code>perl -I$HOME/opt/lib/perl5 -Mlocal::lib=$HOME/opt</code>表示运行前先添加<code>$HOME/opt/lib/perl5</code>到自己的搜索路径<code>@INC</code>中，然后传入参数<code>$HOME/opt</code>执行模块<code>local::lob</code>，这个模块的执行结果会输出如下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Attempting to create directory /home6/wangjw/opt</span><br><span class="line">PATH=<span class="string">&quot;/home/zgxu/opt/bin<span class="variable">$&#123;PATH:+:<span class="variable">$&#123;PATH&#125;</span>&#125;</span>&quot;</span>; <span class="built_in">export</span> PATH;</span><br><span class="line">PERL5LIB=<span class="string">&quot;/home/zgxu/opt/lib/perl5<span class="variable">$&#123;PERL5LIB:+:<span class="variable">$&#123;PERL5LIB&#125;</span>&#125;</span>&quot;</span>; <span class="built_in">export</span> PERL5LIB;</span><br><span class="line">PERL_LOCAL_LIB_ROOT=<span class="string">&quot;/home/zgxu/opt<span class="variable">$&#123;PERL_LOCAL_LIB_ROOT:+:<span class="variable">$&#123;PERL_LOCAL_LIB_ROOT&#125;</span>&#125;</span>&quot;</span>; <span class="built_in">export</span> PERL_LOCAL_LIB_ROOT;</span><br><span class="line">PERL_MB_OPT=<span class="string">&quot;--install_base \&quot;/home/zgxu/opt\&quot;&quot;</span>; <span class="built_in">export</span> PERL_MB_OPT;</span><br><span class="line">PERL_MM_OPT=<span class="string">&quot;INSTALL_BASE=/home/zgxu/opt&quot;</span>; <span class="built_in">export</span> PERL_MM_OPT;</span><br></pre></td></tr></table></figure>

<p>这些就作为<code>eval</code>的参数进行执行，也就是说你重启终端后后，<code>PERL5LIB</code> <code>PERL_LOCAL_LIB_ROOT</code>,<code>PERL_MB_OPT</code>,<code>PERL_MM_OPT</code>这几个变量就会重新设置，以此保证你后续安装perl模块时，会优先安装到自己的选择的目录</p>
<p>第三步：安装cpam. 由于之前已经配置了<code>local::lib</code>，因此perl编译的工具都会默认安装到<code>~/opt</code>目录下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://cpan.metacpan.org/authors/id/M/MI/MIYAGAWA/App-cpanminus-1.7043.tar.gz</span><br><span class="line">tar xf App-cpanminus-1.7043.tar.gz</span><br><span class="line"><span class="built_in">cd</span> App-cpanminus-1.7043</span><br><span class="line">perl Makefile.PL</span><br><span class="line">make <span class="built_in">test</span> &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>第四步：使用国内镜像提高下载速度，可以通过别名的方式实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;alias cpanm=&quot;cpanm --mirror http://mirrors.163.com/cpan --mirror-only&quot;&#x27;</span> &gt;&gt;~/.bashrc</span><br></pre></td></tr></table></figure>

<p>之后便可以使用<code>cpanm Module::Name</code>安装任意的软件了。</p>
<h2 id="自己编译一个perl"><a href="#自己编译一个perl" class="headerlink" title="自己编译一个perl"></a>自己编译一个perl</h2><p>自己编译Perl的好处就在于之后的perl模块都会安装到自己的Perl目录下，而不会对系统造成影响。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/src</span><br><span class="line">wget -4 http://www.cpan.org/src/5.0/perl-5.26.1.tar.gz</span><br><span class="line">tar xf perl-5.26.1.tar.gz</span><br><span class="line"><span class="built_in">cd</span> perl-5.26.1</span><br><span class="line">./Configure -des -Dprefix=<span class="variable">$HOME</span>/opt/sysoft/perl-5.26.1</span><br><span class="line">make <span class="built_in">test</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>然后用<code>perl -e &#39;&#123;print &quot;$_\n&quot; foreach @INC&#125;&#39;</code>会发现perl只会在自己的目录<code>~/opt/sysoft/perl-5.26.1</code>下查找模块。那么使用<code>cpanm Module::Name</code>安装的任何包都只会安装到<code>~/opt/sysoft/perl-5.26.1</code>下，你也不需要安装<code>local::lib</code>了</p>
<h2 id="conda的perl和系统的perl冲突"><a href="#conda的perl和系统的perl冲突" class="headerlink" title="conda的perl和系统的perl冲突"></a>conda的perl和系统的perl冲突</h2><p>有一次我遇到这个问题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">perl: symbol lookup error: /home/wangjw/perl5/lib/perl5/x86_64-linux-thread-multi/auto/Cwd/Cwd.so: undefined symbol</span><br></pre></td></tr></table></figure>

<p>这个问题是因为用系统perl安装的软件被conda的perl优先查找到导致，用<code>perl -V</code>和<code>perl -e &#39;&#123;print &quot;$_\n&quot; foreach @INC&#125;&#39;</code>可以发现conda的perl查找路径低于我为系统perl安装的路径，解决方案如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PERL5LIB=<span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://xuzhougeng.top/2019/08/23/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85perl%E6%A8%A1%E5%9D%97-How-to-install-perl-module/" data-id="clm1z22ha00eyehn56iypapzc" data-title="如何安装perl模块" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Perl-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" rel="tag">Perl | 软件安装</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/21/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><a class="page-number" href="/page/24/">24</a><a class="page-number" href="/page/25/">25</a><a class="extend next" rel="next" href="/page/23/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/R/">R</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Rust/">Rust</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%85%B6%E4%BB%96/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/">基因组学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/">数据科学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/">文献阅读</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%96%87%E7%AB%A0%E9%87%8D%E7%8E%B0/">文章重现</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1/">生信软件工具箱</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E4%BF%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7%E7%AE%B1-%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/">生信软件工具箱 | 基因组学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AC%E5%BD%95%E7%BB%84%E5%AD%A6/">转录组学</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ATAC-seq-%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">ATAC-seq | 单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ATAC-seq-%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90/" rel="tag">ATAC-seq | 差异分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ATAC-seq-%E8%A1%A8%E8%A7%82%E7%BB%84-ChIP-seq/" rel="tag">ATAC-seq | 表观组 | ChIP-seq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ATAC-seq-%E8%A1%A8%E8%A7%82%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">ATAC-seq | 表观组 | 单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BigWig/" rel="tag">BigWig</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/BioNano/" rel="tag">BioNano</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C/" rel="tag">C&#x2F;C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-C-%E7%AE%97%E6%B3%95/" rel="tag">C&#x2F;C++ | 算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ChIP-seq/" rel="tag">ChIP-seq</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub/" rel="tag">GitHub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hi-C/" rel="tag">Hi-C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JCVI/" rel="tag">JCVI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MacOS/" rel="tag">MacOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NGS/" rel="tag">NGS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NGS-%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" rel="tag">NGS | 遗传定位</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBMC/" rel="tag">PBMC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Perl-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" rel="tag">Perl | 软件安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/QT-MSVC/" rel="tag">QT | MSVC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Seurat/" rel="tag">Seurat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Seurat-%E5%8D%95%E7%BB%86%E8%83%9E-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" rel="tag">Seurat | 单细胞 | 数据挖掘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Seurat-%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">Seurat | 转录组 | 单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web%E5%BC%80%E5%8F%91/" rel="tag">Web开发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Zotero-%E6%96%87%E7%8C%AE-%E5%9D%9A%E6%9E%9C%E4%BA%91/" rel="tag">Zotero | 文献 | 坚果云</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/biocondutor/" rel="tag">biocondutor</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/conda/" rel="tag">conda</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/samtools/" rel="tag">samtools</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/typora/" rel="tag">typora</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" rel="tag">个人博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/" rel="tag">可视化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-CIRCOS/" rel="tag">可视化 | CIRCOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-JCVI/" rel="tag">可视化 | JCVI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">可视化 | 单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-%E6%AF%94%E8%BE%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/" rel="tag">可视化 | 比较基因组学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F/" rel="tag">基因家族</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E5%9B%A0%E7%BB%84/" rel="tag">基因组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" rel="tag">小技巧</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7-SSH/" rel="tag">小技巧 | SSH</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" rel="tag">序列比对</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" rel="tag">数据挖掘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-C/" rel="tag">数据结构 | C&#x2F;C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/" rel="tag">正则表达式 | 字符串处理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%AF%94%E8%BE%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/" rel="tag">比较基因组学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B0%B4%E7%A8%BB-%E8%BD%AC%E5%BD%95%E7%BB%84/" rel="tag">水稻 | 转录组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B0%B4%E7%A8%BB-%E8%BD%AC%E5%BD%95%E7%BB%84-%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" rel="tag">水稻 | 转录组 | 遗传定位</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A/" rel="tag">注释</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-MAKER/" rel="tag">注释 | MAKER</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" rel="tag">注释 | 序列比对</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7/" rel="tag">注释 | 流程工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-MAKER/" rel="tag">注释 | 流程工具 | MAKER</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B3%A8%E9%87%8A-%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" rel="tag">注释 | 重复序列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7/" rel="tag">流程工具</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F/" rel="tag">流程工具 | 基因家族</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">流程工具 | 服务器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" rel="tag">源码解读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-hash/" rel="tag">源码解读 | hash</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%88%AC%E8%99%AB/" rel="tag">爬虫</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" rel="tag">环境变量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-WSL/" rel="tag">环境配置 | WSL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B3%BB%E7%BB%9F%E5%8F%91%E8%82%B2/" rel="tag">系统发育</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E8%A3%85/" rel="tag">组装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E8%A3%85-Hi-C/" rel="tag">组装 | Hi-C</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%84%E8%A3%85-%E8%BD%AC%E5%BD%95%E7%BB%84-%E6%B3%A8%E9%87%8A/" rel="tag">组装 | 转录组 | 注释</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" rel="tag">编程语言</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" rel="tag">自然语言 | 深度学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A1%A8%E8%A7%82%E7%BB%84/" rel="tag">表观组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag">读书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84/" rel="tag">转录组</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" rel="tag">转录组 | 单细胞</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90-TCGA/" rel="tag">转录组 | 差异分析 | TCGA</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" rel="tag">转录组 | 序列比对</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" rel="tag">软件安装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" rel="tag">遗传定位</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" rel="tag">重复序列</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/ATAC-seq-%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 20px;">ATAC-seq | 单细胞</a> <a href="/tags/ATAC-seq-%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90/" style="font-size: 10px;">ATAC-seq | 差异分析</a> <a href="/tags/ATAC-seq-%E8%A1%A8%E8%A7%82%E7%BB%84-ChIP-seq/" style="font-size: 10px;">ATAC-seq | 表观组 | ChIP-seq</a> <a href="/tags/ATAC-seq-%E8%A1%A8%E8%A7%82%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 10px;">ATAC-seq | 表观组 | 单细胞</a> <a href="/tags/BigWig/" style="font-size: 10px;">BigWig</a> <a href="/tags/BioNano/" style="font-size: 10px;">BioNano</a> <a href="/tags/C-C/" style="font-size: 19px;">C/C++</a> <a href="/tags/C-C-%E7%AE%97%E6%B3%95/" style="font-size: 10px;">C/C++ | 算法</a> <a href="/tags/ChIP-seq/" style="font-size: 10px;">ChIP-seq</a> <a href="/tags/GitHub/" style="font-size: 11px;">GitHub</a> <a href="/tags/Hi-C/" style="font-size: 10px;">Hi-C</a> <a href="/tags/JCVI/" style="font-size: 10px;">JCVI</a> <a href="/tags/MacOS/" style="font-size: 16px;">MacOS</a> <a href="/tags/NGS/" style="font-size: 11px;">NGS</a> <a href="/tags/NGS-%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">NGS | 遗传定位</a> <a href="/tags/PBMC/" style="font-size: 10px;">PBMC</a> <a href="/tags/Perl-%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" style="font-size: 10px;">Perl | 软件安装</a> <a href="/tags/QT-MSVC/" style="font-size: 10px;">QT | MSVC</a> <a href="/tags/Seurat/" style="font-size: 10px;">Seurat</a> <a href="/tags/Seurat-%E5%8D%95%E7%BB%86%E8%83%9E-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" style="font-size: 10px;">Seurat | 单细胞 | 数据挖掘</a> <a href="/tags/Seurat-%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 10px;">Seurat | 转录组 | 单细胞</a> <a href="/tags/Web%E5%BC%80%E5%8F%91/" style="font-size: 11px;">Web开发</a> <a href="/tags/Zotero-%E6%96%87%E7%8C%AE-%E5%9D%9A%E6%9E%9C%E4%BA%91/" style="font-size: 11px;">Zotero | 文献 | 坚果云</a> <a href="/tags/biocondutor/" style="font-size: 10px;">biocondutor</a> <a href="/tags/conda/" style="font-size: 11px;">conda</a> <a href="/tags/samtools/" style="font-size: 10px;">samtools</a> <a href="/tags/typora/" style="font-size: 10px;">typora</a> <a href="/tags/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">个人博客</a> <a href="/tags/%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 13px;">单细胞</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/" style="font-size: 12px;">可视化</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-CIRCOS/" style="font-size: 14px;">可视化 | CIRCOS</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-JCVI/" style="font-size: 12px;">可视化 | JCVI</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 10px;">可视化 | 单细胞</a> <a href="/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-%E6%AF%94%E8%BE%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/" style="font-size: 10px;">可视化 | 比较基因组学</a> <a href="/tags/%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F/" style="font-size: 11px;">基因家族</a> <a href="/tags/%E5%9F%BA%E5%9B%A0%E7%BB%84/" style="font-size: 11px;">基因组</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7/" style="font-size: 17px;">小技巧</a> <a href="/tags/%E5%B0%8F%E6%8A%80%E5%B7%A7-SSH/" style="font-size: 10px;">小技巧 | SSH</a> <a href="/tags/%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" style="font-size: 10px;">序列比对</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/" style="font-size: 11px;">数据挖掘</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12px;">数据结构</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-C-C/" style="font-size: 16px;">数据结构 | C/C++</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 12px;">服务器</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 10px;">正则表达式</a> <a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/" style="font-size: 10px;">正则表达式 | 字符串处理</a> <a href="/tags/%E6%AF%94%E8%BE%83%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%AD%A6/" style="font-size: 10px;">比较基因组学</a> <a href="/tags/%E6%B0%B4%E7%A8%BB-%E8%BD%AC%E5%BD%95%E7%BB%84/" style="font-size: 10px;">水稻 | 转录组</a> <a href="/tags/%E6%B0%B4%E7%A8%BB-%E8%BD%AC%E5%BD%95%E7%BB%84-%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">水稻 | 转录组 | 遗传定位</a> <a href="/tags/%E6%B3%A8%E9%87%8A/" style="font-size: 12px;">注释</a> <a href="/tags/%E6%B3%A8%E9%87%8A-MAKER/" style="font-size: 13px;">注释 | MAKER</a> <a href="/tags/%E6%B3%A8%E9%87%8A-%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" style="font-size: 10px;">注释 | 序列比对</a> <a href="/tags/%E6%B3%A8%E9%87%8A-%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">注释 | 流程工具</a> <a href="/tags/%E6%B3%A8%E9%87%8A-%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-MAKER/" style="font-size: 10px;">注释 | 流程工具 | MAKER</a> <a href="/tags/%E6%B3%A8%E9%87%8A-%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" style="font-size: 12px;">注释 | 重复序列</a> <a href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7/" style="font-size: 17px;">流程工具</a> <a href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-%E5%9F%BA%E5%9B%A0%E5%AE%B6%E6%97%8F/" style="font-size: 10px;">流程工具 | 基因家族</a> <a href="/tags/%E6%B5%81%E7%A8%8B%E5%B7%A5%E5%85%B7-%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 10px;">流程工具 | 服务器</a> <a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">深度学习</a> <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/" style="font-size: 10px;">源码解读</a> <a href="/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-hash/" style="font-size: 10px;">源码解读 | hash</a> <a href="/tags/%E7%88%AC%E8%99%AB/" style="font-size: 10px;">爬虫</a> <a href="/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/" style="font-size: 10px;">环境变量</a> <a href="/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE-WSL/" style="font-size: 10px;">环境配置 | WSL</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 11px;">算法</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E5%8F%91%E8%82%B2/" style="font-size: 12px;">系统发育</a> <a href="/tags/%E7%BB%84%E8%A3%85/" style="font-size: 18px;">组装</a> <a href="/tags/%E7%BB%84%E8%A3%85-Hi-C/" style="font-size: 16px;">组装 | Hi-C</a> <a href="/tags/%E7%BB%84%E8%A3%85-%E8%BD%AC%E5%BD%95%E7%BB%84-%E6%B3%A8%E9%87%8A/" style="font-size: 10px;">组装 | 转录组 | 注释</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 11px;">编程语言</a> <a href="/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" style="font-size: 11px;">自然语言 | 深度学习</a> <a href="/tags/%E8%A1%A8%E8%A7%82%E7%BB%84/" style="font-size: 10px;">表观组</a> <a href="/tags/%E8%AF%BB%E4%B9%A6/" style="font-size: 11px;">读书</a> <a href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84/" style="font-size: 11px;">转录组</a> <a href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%8D%95%E7%BB%86%E8%83%9E/" style="font-size: 11px;">转录组 | 单细胞</a> <a href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90-TCGA/" style="font-size: 10px;">转录组 | 差异分析 | TCGA</a> <a href="/tags/%E8%BD%AC%E5%BD%95%E7%BB%84-%E5%BA%8F%E5%88%97%E6%AF%94%E5%AF%B9/" style="font-size: 10px;">转录组 | 序列比对</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" style="font-size: 15px;">软件安装</a> <a href="/tags/%E9%81%97%E4%BC%A0%E5%AE%9A%E4%BD%8D/" style="font-size: 10px;">遗传定位</a> <a href="/tags/%E9%87%8D%E5%A4%8D%E5%BA%8F%E5%88%97/" style="font-size: 12px;">重复序列</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 10px;">随笔</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/06/">六月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/03/">三月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">十二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">八月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">四月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">二月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">十二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">六月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">二月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">十一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">十月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">五月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">四月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">三月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">一月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">十二月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">十一月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/09/02/%E5%A6%82%E4%BD%95%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8D%E5%86%8D%E9%BE%9F%E9%80%9F%E4%B8%8B%E8%BD%BDgithub%E7%9A%84%E6%95%B0%E6%8D%AE/">如何让服务器不再龟速下载github的数据</a>
          </li>
        
          <li>
            <a href="/2023/08/27/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E5%AE%B9%E5%99%A8singularity/">编译安装容器singularity</a>
          </li>
        
          <li>
            <a href="/2023/08/25/%E5%85%B3%E4%BA%8E%E7%94%B3%E8%AF%B7OpenAI%E7%9A%84API%E7%9A%84%E5%87%A0%E7%82%B9%E8%A1%A5%E5%85%85/">关于申请OpenAI的API的几点补充</a>
          </li>
        
          <li>
            <a href="/2023/08/18/%E4%BB%8Ehalo%E8%BF%81%E7%A7%BB%E5%88%B0hexo/">从halo迁移到hexo</a>
          </li>
        
          <li>
            <a href="/2023/06/24/Oatk%EF%BC%9A%E5%88%A9%E7%94%A8HiFi%20Read%E8%BF%9B%E8%A1%8C%E7%BB%86%E8%83%9E%E5%99%A8%E7%BB%84%E8%A3%85-oatk-assembly-of-organelles-using-hifi-read/">Oatk：利用HiFi Read进行细胞器组装</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 xuzhougeng<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>